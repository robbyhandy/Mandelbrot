; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	D:\Stanley\Desktop\quickman_v110\source\quickman.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_num_threads
PUBLIC	_file_strs
PUBLIC	_main_man_calc_struct
PUBLIC	_save_man_calc_struct
_BSS	SEGMENT
$SG42031 DB	01H DUP (?)
	ALIGN	4

?dragging@?1??MainWndProc@@9@9 DD 01H DUP (?)		; `MainWndProc'::`2'::dragging
?have_box@?1??MainWndProc@@9@9 DD 01H DUP (?)		; `MainWndProc'::`2'::have_box
?zoom_mode_pending@?1??MainWndProc@@9@9 DD 01H DUP (?)	; `MainWndProc'::`2'::zoom_mode_pending
?prev_sizing@?1??MainWndProc@@9@9 DD 01H DUP (?)	; `MainWndProc'::`2'::prev_sizing
?prev_max_restore@?1??MainWndProc@@9@9 DD 01H DUP (?)	; `MainWndProc'::`2'::prev_max_restore
?ictr@?1??get_image_info@@9@9 DQ 01H DUP (?)		; `get_image_info'::`2'::ictr
?guessed_pct@?1??get_image_info@@9@9 DQ 01H DUP (?)	; `get_image_info'::`2'::guessed_pct
?miters_s@?1??get_image_info@@9@9 DQ 01H DUP (?)	; `get_image_info'::`2'::miters_s
?avg_iters@?1??get_image_info@@9@9 DQ 01H DUP (?)	; `get_image_info'::`2'::avg_iters
_cur_pan_xstep DQ 01H DUP (?)
_cur_pan_ystep DQ 01H DUP (?)
_pan_xstep_accum DQ 01H DUP (?)
_pan_ystep_accum DQ 01H DUP (?)
?key_lock@?1??get_pan_steps@@9@9 DD 01H DUP (?)		; `get_pan_steps'::`2'::key_lock
_num_threads_ind DD 01H DUP (?)
?stopped_counter@?1??get_pan_steps@@9@9 DD 01H DUP (?)	; `get_pan_steps'::`2'::stopped_counter
?stopped@?1??get_pan_steps@@9@9 DD 01H DUP (?)		; `get_pan_steps'::`2'::stopped
_precision_loss DD 01H DUP (?)
	ALIGN	8

_iter_time DQ	01H DUP (?)
_calc_interval_time DQ 01H DUP (?)
_calc_total_time DQ 01H DUP (?)
_interval_time DQ 01H DUP (?)
_total_time DQ	01H DUP (?)
_total_frames DD 01H DUP (?)
_interval_frames DD 01H DUP (?)
_file_tot_time DQ 01H DUP (?)
_all_recalculated DD 01H DUP (?)
_sse_support DD	01H DUP (?)
_do_rtzoom DD	01H DUP (?)
_prev_do_rtzoom DD 01H DUP (?)
_hwnd_dialog DD	01H DUP (?)
_hinstance DD	01H DUP (?)
_hscreen_dc DD	01H DUP (?)
_status	DD	01H DUP (?)
_main_man_calc_struct DB 029310H DUP (?)
_save_man_calc_struct DB 029310H DUP (?)
_log_entries DD	01H DUP (?)
_log_pos DD	01H DUP (?)
_log_count DD	01H DUP (?)
?prev_width@?1??create_bitmap@@9@9 DD 01H DUP (?)	; `create_bitmap'::`2'::prev_width
?prev_height@?1??create_bitmap@@9@9 DD 01H DUP (?)	; `create_bitmap'::`2'::prev_height
$SG40559 DB	01H DUP (?)
	ALIGN	4

$SG41606 DB	01H DUP (?)
	ALIGN	4

$SG40584 DB	01H DUP (?)
	ALIGN	4

$SG41686 DB	01H DUP (?)
	ALIGN	4

$SG41688 DB	01H DUP (?)
	ALIGN	4

?fileNo@?1??queue_point_c@@9@9 DD 01H DUP (?)		; `queue_point_c'::`2'::fileNo
?currLines@?1??queue_point_c@@9@9 DD 01H DUP (?)	; `queue_point_c'::`2'::currLines
?adj_iters_prev@?1??man_dialog_proc@@9@9 DD 01H DUP (?)	; `man_dialog_proc'::`2'::adj_iters_prev
?ignore_next_change@?1??man_dialog_proc@@9@9 DD 01H DUP (?) ; `man_dialog_proc'::`2'::ignore_next_change
?new_file_entered@?1??man_dialog_proc@@9@9 DD 01H DUP (?) ; `man_dialog_proc'::`2'::new_file_entered
?new_file_selected@?1??man_dialog_proc@@9@9 DD 01H DUP (?) ; `man_dialog_proc'::`2'::new_file_selected
_BSS	ENDS
CONST	SEGMENT
_help_text DB	'For complete documentation, please go to the QuickMAN', 0aH
	DB	'project webpage and click on the Documentation tab.', 0aH, 0aH
	DB	'http://quickman.sourceforge.net', 0aH, 0aH, 'Operation Summar'
	DB	'y:', 0aH, 0aH, 'Mouse buttons: zoom in/out; zoom rectangle in'
	DB	' magnifier mode', 0aH, 0aH, 'Mouse wheel: increase/decrease M'
	DB	'ax Iters', 0aH, 0aH, 'Z: switch between realtime zooming and '
	DB	'magnifier modes', 0aH, 0aH, 'Arrow keys or A, S, D, W: move a'
	DB	'round the image (pan)', 0aH, 0aH, 'Space (with mouse): drag t'
	DB	'he image', 0aH, 0aH, 'Shift (with/without arrow keys): start/'
	DB	'stop automatic panning', 0aH, 0aH, 'Ctrl (during panning): in'
	DB	'crease panning speed', 0aH, 0aH, 'F or Fullscreen button: swi'
	DB	'tch between windowed and fullscreen', 0aH, 0aH, 'Esc: exit fu'
	DB	'llscreen mode', 0aH, 0aH, 'C: show/hide the control window', 0aH
	DB	0aH, 'N or Next button: go to the next logfile image', 0aH, 0aH
	DB	'P or Previous button: go to the previous logfile image', 0aH, 0aH
	DB	'H or Home button: go to the home image', 0aH, 0aH, 'L: lock t'
	DB	'he current palette (ignore logfile palettes)', 0aH, 0aH, 'I: '
	DB	'invert the current palette', 0aH, 0aH, 'F1: show this message'
	DB	00H
	ORG $+3
_wave_ystart DD	03H
	DD	01H
	DD	03H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
_wave_xstart DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
_wave_inc DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	02H
	DD	02H
	DD	02H
_wave_xoffs DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0fffffffeH
	DD	02H
	DD	0fffffffeH
	DD	02H
	DD	00H
	DD	0fffffffeH
	DD	02H
	DD	00H
	DD	00H
	DD	0fffffffeH
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
_wave_yoffs DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0fffffffeH
	DD	0fffffffeH
	DD	02H
	DD	02H
	DD	0fffffffeH
	DD	00H
	DD	00H
	DD	02H
	DD	0fffffffeH
	DD	00H
	DD	00H
	DD	02H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	01H
CONST	ENDS
_DATA	SEGMENT
$SG42034 DB	'Logged', 00H
	ORG $+1
?prev_mouse_x@?1??MainWndProc@@9@9 DD 0ffffffffH	; `MainWndProc'::`2'::prev_mouse_x
?allow_mode_change@?1??MainWndProc@@9@9 DD 01H		; `MainWndProc'::`2'::allow_mode_change
?prev_nav_mode@?1??MainWndProc@@9@9 DD 02H		; `MainWndProc'::`2'::prev_nav_mode
?classname@?1??WinMain@@9@9 DD FLAT:$SG42311		; `WinMain'::`2'::classname
$SG41258 DB	'%-4.4gM (%-.2f GFlops)', 00H
	ORG $+1
$SG41259 DB	'Real', 09H, '%-16.16lf', 0dH, 0aH, 'Imag', 09H, '%-16.16'
	DB	'lf', 0dH, 0aH, 'Mag', 09H, '%-16lf', 0dH, 0aH, 0dH, 0aH, 'Siz'
	DB	'e', 09H, '%u x %u', 0dH, 0aH, 'Time', 09H, '%-3.3fs', 0dH, 0aH
	DB	'Iters/s', 09H, '%s', 0dH, 0aH, 0dH, 0aH, 'Avg iters/pixel', 09H
	DB	'%-.1lf', 0dH, 0aH, 'Points guessed', 09H, '%-.1lf%%', 0dH, 0aH
	DB	'Total iters', 09H, '%-.0lf', 0dH, 0aH, 00H
	ORG $+2
$SG41260 DB	0dH, 0aH, 'Thread load %%', 09H, 'Cur    Total', 0dH, 0aH
	DB	00H
$SG41261 DB	'Thread %d', 09H, '%#3.3g   %#3.3g', 0dH, 0aH, 00H
$SG41278 DB	'%c Fps %3.0f/%-3.0f', 00H
$SG41264 DB	'Efficiency %%', 09H, '%#3.3g   %#3.3g', 0dH, 0aH, 0dH, 0aH
	DB	'Total calc time', 09H, '%-.3lfs', 0dH, 0aH, 0dH, 0aH, '(C) 20'
	DB	'06-2008 Paul Gentieu', 00H
	ORG $+1
$SG41279 DB	'Iter %2.0f%%', 00H
	ORG $+3
$SG42311 DB	'ManWin', 00H
	ORG $+1
$SG42313 DB	'QuickMAN 1.10  |  F1: Help', 00H
	ORG $+1
_precision_strs DD FLAT:$SG40267
	DD	FLAT:$SG40268
	DD	FLAT:$SG40269
	DD	FLAT:$SG40270
$SG42314 DB	0aH, 'Did you extract all the files from the QuickMAN .zi'
	DB	'p archive?', 00H
	ORG $+1
$SG40267 DB	'Auto', 00H
	ORG $+3
$SG40268 DB	'Single', 00H
	ORG $+1
$SG40269 DB	'Double', 00H
	ORG $+1
$SG40270 DB	'Extended', 00H
	ORG $+3
_alg_strs DD	FLAT:$SG40272
	DD	FLAT:$SG40273
	DD	FLAT:$SG40274
	DD	FLAT:$SG40275
	DD	FLAT:$SG40276
	DD	FLAT:$SG40277
$SG40272 DB	'Fast, AMD', 00H
	ORG $+2
$SG40273 DB	'Exact, AMD', 00H
	ORG $+1
$SG40274 DB	'Fast, Intel', 00H
$SG40275 DB	'Exact, Intel', 00H
	ORG $+3
$SG40276 DB	'Fast, C', 00H
$SG40277 DB	'Exact, C', 00H
	ORG $+3
_palette_strs DD FLAT:$SG40279
	DD	FLAT:$SG40280
	DD	FLAT:$SG40281
	DD	FLAT:$SG40282
	DD	FLAT:$SG40283
	DD	FLAT:$SG40284
	DD	FLAT:$SG40285
	DD	FLAT:$SG40286
	DD	FLAT:$SG40287
	DD	FLAT:$SG40288
	DD	FLAT:$SG40289
	DD	FLAT:$SG40290
	DD	FLAT:$SG40291
	DD	FLAT:$SG40292
$SG40279 DB	'Monochrome', 00H
	ORG $+1
$SG40280 DB	'Striped', 00H
$SG40281 DB	'Loud', 00H
	ORG $+3
$SG40282 DB	'Muted', 00H
	ORG $+2
$SG40283 DB	'Purple', 00H
	ORG $+1
$SG40284 DB	'Earthy', 00H
	ORG $+1
$SG40285 DB	'Smoky', 00H
	ORG $+2
$SG40286 DB	'Acid', 00H
	ORG $+3
$SG40287 DB	'Flaming', 00H
$SG40288 DB	'Metallic', 00H
	ORG $+3
$SG40289 DB	'Angry', 00H
	ORG $+2
$SG40290 DB	'Dreamy', 00H
	ORG $+1
$SG40291 DB	'Flaming+', 00H
	ORG $+3
$SG40292 DB	'Plantlike', 00H
	ORG $+2
_rendering_strs DD FLAT:$SG40294
	DD	FLAT:$SG40295
$SG40294 DB	'Standard', 00H
	ORG $+3
$SG40295 DB	'Normalized', 00H
	ORG $+1
_num_threads_strs DD FLAT:$SG40297
	DD	FLAT:$SG40298
	DD	FLAT:$SG40299
	DD	FLAT:$SG40300
	DD	FLAT:$SG40301
	DD	FLAT:$SG40302
	DD	FLAT:$SG40303
	DD	FLAT:$SG40304
	DD	FLAT:$SG40305
$SG40297 DB	'1', 00H
	ORG $+2
$SG40298 DB	'2', 00H
	ORG $+2
$SG40299 DB	'4', 00H
	ORG $+2
$SG40300 DB	'8', 00H
	ORG $+2
$SG40301 DB	'16', 00H
	ORG $+1
$SG40302 DB	'32', 00H
	ORG $+1
$SG40303 DB	'64', 00H
	ORG $+1
$SG40304 DB	'128', 00H
$SG40305 DB	'256', 00H
_num_threads DD	01H
$SG40321 DB	'auto_panzoom.log', 00H
	ORG $+3
_logfile DB	'quickman.log', 00H
	ORG $+243
_savefile DB	'image1', 00H
	ORG $+249
_file_strs DD	FLAT:_logfile
	DD	FLAT:$SG40321
_nav_mode DD	02H
$SG40380 DB	'Pan', 00H
_rtzoom_mag_steps DQ 03ff0028f5c28f5c3r		; 1.00063
	DQ	03ff0051eb851eb85r		; 1.00125
	DQ	03ff00a3d70a3d70ar		; 1.0025
	DQ	03ff0147ae147ae14r		; 1.005
	DQ	03ff028f5c28f5c29r		; 1.01
	DQ	03ff03d70a3d70a3dr		; 1.015
	DQ	03ff051eb851eb852r		; 1.02
	DQ	03ff0666666666666r		; 1.025
	DQ	03ff07ae147ae147br		; 1.03
	DQ	03ff0a3d70a3d70a4r		; 1.04
	DQ	03ff0cccccccccccdr		; 1.05
	DQ	03ff0f5c28f5c28f6r		; 1.06
	DQ	03ff11eb851eb851fr		; 1.07
	DQ	03ff147ae147ae148r		; 1.08
	DQ	03ff170a3d70a3d71r		; 1.09
	DQ	03ff199999999999ar		; 1.1
	DQ	03ff1c28f5c28f5c3r		; 1.11
	DQ	03ff1eb851eb851ecr		; 1.12
	DQ	03ff23d70a3d70a3dr		; 1.14
	DQ	03ff2b851eb851eb8r		; 1.17
	DQ	03ff3333333333333r		; 1.2
_pan_step_scales DQ 03f547ae147ae147br		; 0.00125
	DQ	03f647ae147ae147br		; 0.0025
	DQ	03f747ae147ae147br		; 0.005
	DQ	03f847ae147ae147br		; 0.01
	DQ	03f947ae147ae147br		; 0.02
	DQ	03fa47ae147ae147br		; 0.04
	DQ	03fb47ae147ae147br		; 0.08
	DQ	03fc999999999999ar		; 0.2
	DQ	03fd999999999999ar		; 0.4
	DQ	03fe3333333333333r		; 0.6
	DQ	03fe999999999999ar		; 0.8
	DQ	03ff0000000000000r		; 1
	DQ	03ff3333333333333r		; 1.2
	DQ	03ff6666666666666r		; 1.4
	DQ	03ff999999999999ar		; 1.6
	DQ	03ffccccccccccccdr		; 1.8
	DQ	04000000000000000r		; 2
	DQ	0400199999999999ar		; 2.2
	DQ	04003333333333333r		; 2.4
	DQ	04004cccccccccccdr		; 2.6
	DQ	04006666666666666r		; 2.8
?pan_time@?1??do_panning@@9@9 DQ 0bff0000000000000r ; -1 ; `do_panning'::`2'::pan_time
_cfg_settings DD FLAT:$SG40379
	DD	0aH
	DD	0aH
	DD	00H
	DD	014H
	DD	FLAT:$SG40380
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffH
	DD	FLAT:$SG40381
	DD	0aH
	DD	0aH
	DD	00H
	DD	014H
	DD	FLAT:$SG40382
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffH
	DD	FLAT:$SG40383
	DD	02bcH
	DD	02bcH
	DD	00H
	DD	0ffffH
	DD	FLAT:$SG40384
	DD	02bcH
	DD	02bcH
	DD	00H
	DD	0ffffH
	DD	FLAT:$SG40385
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffH
	DD	FLAT:$SG40386
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffH
	DD	FLAT:$SG40387
	DD	01H
	DD	01H
	DD	00H
	DD	0ffffH
	DD	FLAT:$SG40388
	DD	0234471H
	DD	0234471H
	DD	00H
	DD	0ffffffH
	DD	FLAT:$SG40389
	DD	010H
	DD	010H
	DD	01H
	DD	0ffffffH
	DD	FLAT:$SG40390
	DD	096H
	DD	096H
	DD	01H
	DD	02710H
	DD	FLAT:$SG40391
	DD	012cH
	DD	012cH
	DD	01H
	DD	02710H
$SG40379 DB	'panrate', 00H
$SG40381 DB	'zoomrate', 00H
	ORG $+3
$SG40382 DB	'Zoom', 00H
	ORG $+3
$SG40383 DB	'Xsize', 00H
	ORG $+2
$SG40384 DB	'Ysize', 00H
	ORG $+2
$SG40385 DB	'Maxiters_color', 00H
	ORG $+1
$SG40386 DB	'Pal_xor', 00H
$SG40387 DB	'options', 00H
$SG40388 DB	'spt', 00H
$SG40389 DB	'bst', 00H
$SG40390 DB	'pfcmin', 00H
	ORG $+1
$SG40391 DB	'pfcmax', 00H
	ORG $+1
$SG41455 DB	'AuthenticAMD', 00H
	ORG $+3
$SG41460 DB	'Warning', 00H
$SG41461 DB	'Your (obsolete) CPU does not support SSE2 instructions.', 0dH
	DB	0aH, 'Performance will be suboptimal.', 00H
	ORG $+3
$SG40493 DB	'real', 00H
	ORG $+3
$SG40522 DB	'rb', 00H
	ORG $+1
$SG40523 DB	'rt', 00H
	ORG $+1
$SG41548 DB	'Error allocating storage arrays.', 00H
	ORG $+3
$SG40525 DB	'Could not open ''%s'' for read.%s', 00H
$SG40526 DB	'Warning', 00H
$SG40575 DB	'at', 00H
	ORG $+1
$SG40576 DB	'Could not open ''%s'' for write.', 00H
	ORG $+1
$SG40579 DB	'%d', 00H
	ORG $+1
$SG41604 DB	'bmp', 00H
$SG40580 DB	'"%s"', 00H
	ORG $+3
$SG40582 DB	0aH, 'pal_xor 0x%06X', 00H
$SG41610 DB	'Unrecognized file format.', 00H
	ORG $+2
$SG40583 DB	0aH, 'Real     %-16.16lf', 0aH, 'Imag     %-16.16lf', 0aH
	DB	'Mag      %-16lf', 0aH, 'Iters    %d', 0aH, 'Palette  %s', 0aH
	DB	00H
$SG41609 DB	'Unsupported file format. Please supply an uncompressed 2'
	DB	'4-bit bitmap.', 00H
	ORG $+2
$SG40608 DB	'quickman.cfg', 00H
	ORG $+3
$SG40626 DB	'*.pal', 00H
	ORG $+2
$SG40627 DB	'*.bmp', 00H
	ORG $+2
$SG40628 DB	'*.log', 00H
	ORG $+2
?vkeys@?1??get_keys_pressed@@9@9 DW 025H		; `get_keys_pressed'::`2'::vkeys
	DW	041H
	DW	027H
	DW	044H
	DW	026H
	DW	057H
	DW	028H
	DW	053H
	DW	011H
	DW	010H
?keybits@?1??get_keys_pressed@@9@9 DD 01H		; `get_keys_pressed'::`2'::keybits
	DD	01H
	DD	02H
	DD	02H
	DD	04H
	DD	04H
	DD	08H
	DD	08H
	DD	010H
	DD	040H
$SG41687 DB	'[Prec Loss]', 00H
$SG41689 DB	'Calculating...', 00H
	ORG $+1
$SG41690 DB	'Ready ', 00H
	ORG $+1
$SG41691 DB	'%s%s', 00H
	ORG $+3
$SG41692 DB	'%d/%d  %c', 00H
	ORG $+2
$SG41700 DB	'%c Palette', 00H
	ORG $+1
$SG41708 DB	'This feature is not implemented yet.', 00H
	ORG $+3
$SG41716 DB	'Your (obsolete) CPU cannot run this algorithm/precision '
	DB	'combination.', 0aH, 'Using C algorithm.', 00H
$SG41723 DB	'Warning', 00H
$SG41724 DB	'Using the Fast algorithm with Normalized rendering may', 0aH
	DB	'cause image artifacts. Switch to the Exact algorithm?', 00H
	ORG $+3
$SG41732 DB	'  Algorithm', 00H
$SG41807 DB	'QuickMAN Help', 00H
	ORG $+2
$SG40789 DB	'oversample_debug.%d.csv', 00H
$SG40790 DB	'a', 00H
	ORG $+2
$SG40794 DB	'%16.16lf,%16.16lf', 00H
	ORG $+2
$SG40797 DB	'%16.16lf,%16.16lf', 00H
	ORG $+2
$SG40798 DB	',', 00H
	ORG $+2
$SG40801 DB	',%d', 00H
$SG40803 DB	',', 00H
	ORG $+2
$SG40804 DB	0aH, 00H
	ORG $+2
$SG40806 DB	0aH, 00H
	ORG $+2
$SG41859 DB	'.png', 00H
	ORG $+3
$SG41860 DB	'.png', 00H
	ORG $+3
$SG41862 DB	'rb', 00H
	ORG $+1
$SG41863 DB	'%s already exists. Overwrite?', 00H
	ORG $+2
$SG41865 DB	'Warning', 00H
$SG41869 DB	'Saving... (%3.1f%%)', 00H
$SG41870 DB	'Saved in %.1fs', 00H
_DATA	ENDS
PUBLIC	_WinMain@16
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsprintf_s_l
PUBLIC	_sprintf_s
PUBLIC	_do_man_calculate
PUBLIC	_copy_changed_settings
PUBLIC	_autoreset_settings
PUBLIC	_invalidate_settings
PUBLIC	_log_read_entry
PUBLIC	_open_file
PUBLIC	_log_read
PUBLIC	_log_update
PUBLIC	_log_get
PUBLIC	_read_cfg_file
PUBLIC	_add_user_palettes_and_logfiles
PUBLIC	_get_timer
PUBLIC	_get_seconds_elapsed
PUBLIC	_get_keys_pressed
PUBLIC	_reset_thread_load_counters
PUBLIC	_reset_fps_values
PUBLIC	_get_re_im_offs
PUBLIC	_update_re_im
PUBLIC	_update_re_im_mag
PUBLIC	_man_calculate_threaded@4
PUBLIC	_check_precision_loss
PUBLIC	_man_setup
PUBLIC	_man_calculate
PUBLIC	_swap_quadrants
PUBLIC	_reset_quadrants
PUBLIC	_intersect_rect
PUBLIC	_man_calculate_quadrants
PUBLIC	_pan_image
PUBLIC	_get_image_info
PUBLIC	_print_fps_status_line
PUBLIC	_update_benchmarks
PUBLIC	_reset_pan_state
PUBLIC	_get_pan_steps
PUBLIC	_do_panning
PUBLIC	_get_mouse_re_im
PUBLIC	_do_zooming
PUBLIC	_do_recalc
PUBLIC	_init_man
PUBLIC	_get_cpu_info
PUBLIC	_alloc_man_mem
PUBLIC	_free_man_mem
PUBLIC	_create_bitmap
PUBLIC	_init_combo_box
PUBLIC	_get_string_index
PUBLIC	_get_builtin_palette
PUBLIC	_get_user_palette
PUBLIC	_get_rendering_alg
PUBLIC	_get_precision
PUBLIC	_get_alg
PUBLIC	_get_num_threads
PUBLIC	_update_iters
PUBLIC	_set_home_image
PUBLIC	_get_dialog_fields
PUBLIC	_set_slider_pos
PUBLIC	_setup_sliders
PUBLIC	_print_status_line
PUBLIC	_print_palette_status
PUBLIC	_not_implemented_yet
PUBLIC	_unsupported_alg_prec
PUBLIC	_unrecommended_alg
PUBLIC	_set_alg_warning
PUBLIC	_check_alg
PUBLIC	_get_system_metrics
PUBLIC	_update_dialog
PUBLIC	_toggle_fullscreen
PUBLIC	_show_help@4
PUBLIC	_resize_window
PUBLIC	_do_save@4
PUBLIC	_man_dialog_proc@16
PUBLIC	_striped_blit
PUBLIC	_confine_mouse_cursor
PUBLIC	_MainWndProc@16
PUBLIC	_fancy_intro
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ea9273b38557509
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	__real@3edbf647612f3696
PUBLIC	__real@3f1a36e2eb1c432d
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@3f947ae147ae147b
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fd3333333333333
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff11eb851eb851f
PUBLIC	__real@3ff599999999999a
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@4022000000000000
PUBLIC	__real@4030000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@40c3880000000000
PUBLIC	__real@411de84000000000
PUBLIC	__real@41800000
PUBLIC	__real@bfe0000000000000
PUBLIC	__real@bfe6666666666666
PUBLIC	__real@bff0000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	_memset:PROC
EXTRN	_strcat_s:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	__strnicmp:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__imp__QueueUserWorkItem@12:PROC
EXTRN	__imp__WaitForMultipleObjects@16:PROC
EXTRN	__imp__BitBlt@36:PROC
EXTRN	__imp__CreateCompatibleDC@4:PROC
EXTRN	__imp__CreatePen@12:PROC
EXTRN	__imp__DeleteObject@4:PROC
EXTRN	__imp__GetDeviceCaps@8:PROC
EXTRN	__imp__Rectangle@20:PROC
EXTRN	__imp__SelectObject@8:PROC
EXTRN	__imp__SetROP2@8:PROC
EXTRN	__imp__CreateDIBSection@24:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__RegisterClassExA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__GetWindowPlacement@8:PROC
EXTRN	__imp__CreateDialogParamA@20:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__SetDlgItemInt@16:PROC
EXTRN	__imp__GetDlgItemInt@16:PROC
EXTRN	__imp__GetDlgItemTextA@16:PROC
EXTRN	__imp__IsDlgButtonChecked@8:PROC
EXTRN	__imp__SendDlgItemMessageA@20:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	__imp__GetFocus@0:PROC
EXTRN	__imp__GetAsyncKeyState@4:PROC
EXTRN	__imp__SetCapture@4:PROC
EXTRN	__imp__ReleaseCapture@0:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__UpdateWindow@4:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__GetWindowRect@8:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__SetCursor@4:PROC
EXTRN	__imp__ClipCursor@4:PROC
EXTRN	__imp__GetCursor@0:PROC
EXTRN	__imp__ClientToScreen@8:PROC
EXTRN	__imp__SetRect@20:PROC
EXTRN	__imp__SetWindowLongA@12:PROC
EXTRN	__imp__GetDesktopWindow@0:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	__imp__IsDialogMessageA@8:PROC
EXTRN	_fopen_s:PROC
EXTRN	_fclose:PROC
EXTRN	_feof:PROC
EXTRN	_fgets:PROC
EXTRN	_fputs:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_abs:PROC
EXTRN	_atof:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__timeBeginPeriod@4:PROC
EXTRN	__imp__timeEndPeriod@4:PROC
EXTRN	__imp__InitCommonControls@0:PROC
EXTRN	_png_save_start:PROC
EXTRN	_png_save_write_row:PROC
EXTRN	_png_save_end:PROC
EXTRN	_init_palettes:PROC
EXTRN	_load_palette:PROC
EXTRN	_load_palette_from_bmp:PROC
EXTRN	_get_palette_rgb_val:PROC
EXTRN	_apply_palette:PROC
EXTRN	__allshl:PROC
EXTRN	__dtoui3:PROC
EXTRN	__ltod3:PROC
EXTRN	__ultod3:PROC
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_prev_xsize DD	01H DUP (?)
_prev_ysize DD	01H DUP (?)
_mouse_re DQ	01H DUP (?)
_mouse_im DQ	01H DUP (?)
_zoom_start_mag DQ 01H DUP (?)
_num_builtin_palettes DD 01H DUP (?)
_palette_file DB 0100H DUP (?)
_zoom_start_time DD 01H DUP (?)
_mouse_x DD	02H DUP (?)
_mouse_y DD	02H DUP (?)
_mag_cursor DD	01H DUP (?)
_rtzoom_cursor DD 01H DUP (?)
_hopen_cursor DD 01H DUP (?)
_hclosed_cursor DD 01H DUP (?)
_arrow_cursor DD 01H DUP (?)
_wait_cursor DD	01H DUP (?)
_mag_zoom_cursor DD 01H DUP (?)
_main_rect DB	010H DUP (?)
_hwnd_main DD	01H DUP (?)
_hwnd_info DD	01H DUP (?)
_hwnd_status DD	01H DUP (?)
_hwnd_status2 DD 01H DUP (?)
_hwnd_iters DD	01H DUP (?)
_hwnd_thumbnail_frame DD 01H DUP (?)
_x_border DD	01H DUP (?)
_y_border DD	01H DUP (?)
_y_thinborder DD 01H DUP (?)
_x_dialog_border DD 01H DUP (?)
_y_dialog_border DD 01H DUP (?)
_lpix_per_inch DD 01H DUP (?)
_update_rect DB	028H DUP (?)
_quad	DB	0e0H DUP (?)
_screen_xpos DD	01H DUP (?)
_screen_ypos DD	01H DUP (?)
_wave_ptr_offs DD 01cH DUP (?)
_cur_file_settings DB 0104H DUP (?)
?s@?1??get_image_info@@9@9 DB 0800H DUP (?)		; `get_image_info'::`2'::s
?iters_str@?1??get_image_info@@9@9 DB 0100H DUP (?)	; `get_image_info'::`2'::iters_str
?wait_release@?1??get_pan_steps@@9@9 DD 01H DUP (?)	; `get_pan_steps'::`2'::wait_release
?start_time@?1??do_panning@@9@9 DD 01H DUP (?)		; `do_panning'::`2'::start_time
?hpen@?1??MainWndProc@@9@9 DD 01H DUP (?)		; `MainWndProc'::`2'::hpen
?prev_mouse_y@?1??MainWndProc@@9@9 DD 01H DUP (?)	; `MainWndProc'::`2'::prev_mouse_y
_BSS	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@bfe6666666666666
CONST	SEGMENT
__real@bfe6666666666666 DQ 0bfe6666666666666r	; -0.7
CONST	ENDS
;	COMDAT __real@bfe0000000000000
CONST	SEGMENT
__real@bfe0000000000000 DQ 0bfe0000000000000r	; -0.5
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@411de84000000000
CONST	SEGMENT
__real@411de84000000000 DQ 0411de84000000000r	; 490000
CONST	ENDS
;	COMDAT __real@40c3880000000000
CONST	SEGMENT
__real@40c3880000000000 DQ 040c3880000000000r	; 10000
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4030000000000000
CONST	SEGMENT
__real@4030000000000000 DQ 04030000000000000r	; 16
CONST	ENDS
;	COMDAT __real@4022000000000000
CONST	SEGMENT
__real@4022000000000000 DQ 04022000000000000r	; 9
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff599999999999a
CONST	SEGMENT
__real@3ff599999999999a DQ 03ff599999999999ar	; 1.35
CONST	ENDS
;	COMDAT __real@3ff11eb851eb851f
CONST	SEGMENT
__real@3ff11eb851eb851f DQ 03ff11eb851eb851fr	; 1.07
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fd3333333333333
CONST	SEGMENT
__real@3fd3333333333333 DQ 03fd3333333333333r	; 0.3
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3f947ae147ae147b
CONST	SEGMENT
__real@3f947ae147ae147b DQ 03f947ae147ae147br	; 0.02
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@3f1a36e2eb1c432d
CONST	SEGMENT
__real@3f1a36e2eb1c432d DQ 03f1a36e2eb1c432dr	; 0.0001
CONST	ENDS
;	COMDAT __real@3edbf647612f3696
CONST	SEGMENT
__real@3edbf647612f3696 DQ 03edbf647612f3696r	; 6.66667e-06
CONST	ENDS
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-06
CONST	ENDS
;	COMDAT __real@3ea9273b38557509
CONST	SEGMENT
__real@3ea9273b38557509 DQ 03ea9273b38557509r	; 7.49625e-07
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _fancy_intro
_TEXT	SEGMENT
_m$ = -4						; size = 4
_fancy_intro PROC					; COMDAT

; 4781 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4782 :    #define MAG_STEP 1.07 // slow down a bit from previous versions
; 4783 : 
; 4784 :    man_calc_struct *m;
; 4785 : 
; 4786 :    m = &main_man_calc_struct;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 4787 : 
; 4788 :    set_home_image();

  00010	e8 00 00 00 00	 call	 _set_home_image

; 4789 :    m->max_iters = 64;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00018	c7 80 c0 8d 00
	00 40 00 00 00	 mov	 DWORD PTR [eax+36288], 64 ; 00000040H

; 4790 :    m->mag = MAG_START;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00025	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3fd3333333333333
  0002d	f2 0f 11 80 b8
	8d 00 00	 movsd	 QWORD PTR [eax+36280], xmm0

; 4791 :    do_rtzoom = 1; // prevent status line from being updated

  00035	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _do_rtzoom, 1
$LN4@fancy_intr:

; 4792 :    do
; 4793 :    {
; 4794 :       do_man_calculate(1);

  0003f	6a 01		 push	 1
  00041	e8 00 00 00 00	 call	 _do_man_calculate
  00046	83 c4 04	 add	 esp, 4

; 4795 :       m->mag *= MAG_STEP;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  0004c	f2 0f 10 80 b8
	8d 00 00	 movsd	 xmm0, QWORD PTR [eax+36280]
  00054	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ff11eb851eb851f
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  0005f	f2 0f 11 81 b8
	8d 00 00	 movsd	 QWORD PTR [ecx+36280], xmm0

; 4796 :    }
; 4797 :    while (m->mag <= 1.35);

  00067	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  0006a	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff599999999999a
  00072	66 0f 2f 80 b8
	8d 00 00	 comisd	 xmm0, QWORD PTR [eax+36280]
  0007a	73 c3		 jae	 SHORT $LN4@fancy_intr

; 4798 : 
; 4799 :    set_home_image();

  0007c	e8 00 00 00 00	 call	 _set_home_image

; 4800 :    do_man_calculate(1);

  00081	6a 01		 push	 1
  00083	e8 00 00 00 00	 call	 _do_man_calculate
  00088	83 c4 04	 add	 esp, 4

; 4801 :    do_rtzoom = 0;

  0008b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _do_rtzoom, 0

; 4802 :    status &= ~STAT_RECALC_IMMEDIATELY; // "resized" initially, but no need to calc again

  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  0009a	83 e0 f7	 and	 eax, -9			; fffffff7H
  0009d	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 4803 : 
; 4804 :    SetWindowText(hwnd_info, get_image_info(1)); // print first info, status

  000a2	6a 01		 push	 1
  000a4	e8 00 00 00 00	 call	 _get_image_info
  000a9	83 c4 04	 add	 esp, 4
  000ac	50		 push	 eax
  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_info
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 4805 :    print_status_line(0);

  000b9	6a 00		 push	 0
  000bb	e8 00 00 00 00	 call	 _print_status_line
  000c0	83 c4 04	 add	 esp, 4

; 4806 : 
; 4807 :    file_tot_time = 0.0; // don't count intro time in file total time

  000c3	0f 57 c0	 xorps	 xmm0, xmm0
  000c6	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _file_tot_time, xmm0

; 4808 : }

  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi
  000d0	5b		 pop	 ebx
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
_fancy_intro ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _MainWndProc@16
_TEXT	SEGMENT
tv459 = -212						; size = 4
tv409 = -212						; size = 4
tv407 = -212						; size = 4
tv395 = -212						; size = 4
tv390 = -212						; size = 4
tv388 = -212						; size = 4
tv64 = -212						; size = 4
_offs_y$1 = -144					; size = 4
_offs_x$2 = -140					; size = 4
_m$ = -136						; size = 4
_wp$ = -132						; size = 44
_q$ = -88						; size = 4
_ps$ = -84						; size = 64
_hdc$ = -20						; size = 4
_rc$ = -16						; size = 16
_hwnd$ = 8						; size = 4
_nMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_MainWndProc@16 PROC					; COMDAT

; 4406 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 4407 :    RECT rc;
; 4408 :    HDC hdc;
; 4409 :    PAINTSTRUCT ps;
; 4410 :    quadrant *q;
; 4411 :    WINDOWPLACEMENT wp;
; 4412 : 
; 4413 :    static HPEN hpen;                   // for drawing the zoom box
; 4414 :    static int prev_mouse_x = -1, prev_mouse_y;
; 4415 :    static int dragging = 0, have_box = 0;
; 4416 :    static int allow_mode_change = 1;   // flag indicating whether zoom/pan mode change is allowed
; 4417 :    static int zoom_mode_pending = 0;   // flag indicating need a change back to zoom mode
; 4418 :    static int prev_nav_mode = MODE_RTZOOM;
; 4419 :    static int prev_sizing = 0;
; 4420 :    static int prev_max_restore = 0;    // used to detect when window transitioned from maximized to restored
; 4421 : 
; 4422 :    man_calc_struct *m;
; 4423 : 
; 4424 :    m = &main_man_calc_struct;

  0000c	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 4425 : 
; 4426 :    switch (nMsg)

  00016	8b 45 0c	 mov	 eax, DWORD PTR _nMsg$[ebp]
  00019	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  0001f	81 bd 2c ff ff
	ff 11 01 00 00	 cmp	 DWORD PTR tv64[ebp], 273 ; 00000111H
  00029	0f 87 88 00 00
	00		 ja	 $LN85@MainWndPro
  0002f	81 bd 2c ff ff
	ff 11 01 00 00	 cmp	 DWORD PTR tv64[ebp], 273 ; 00000111H
  00039	0f 84 aa 0d 00
	00		 je	 $LN72@MainWndPro
  0003f	83 bd 2c ff ff
	ff 47		 cmp	 DWORD PTR tv64[ebp], 71	; 00000047H
  00046	77 3d		 ja	 SHORT $LN86@MainWndPro
  00048	83 bd 2c ff ff
	ff 47		 cmp	 DWORD PTR tv64[ebp], 71	; 00000047H
  0004f	0f 84 1d 0c 00
	00		 je	 $LN65@MainWndPro
  00055	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv64[ebp], ecx
  00064	83 bd 2c ff ff
	ff 1f		 cmp	 DWORD PTR tv64[ebp], 31	; 0000001fH
  0006b	0f 87 88 0d 00
	00		 ja	 $LN2@MainWndPro
  00071	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv64[ebp]
  00077	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN87@MainWndPro[edx]
  0007e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN90@MainWndPro[eax*4]
$LN86@MainWndPro:
  00085	83 bd 2c ff ff
	ff 53		 cmp	 DWORD PTR tv64[ebp], 83	; 00000053H
  0008c	0f 84 e9 0a 00
	00		 je	 $LN54@MainWndPro
  00092	81 bd 2c ff ff
	ff 00 01 00 00	 cmp	 DWORD PTR tv64[ebp], 256 ; 00000100H
  0009c	0f 84 42 08 00
	00		 je	 $LN38@MainWndPro
  000a2	81 bd 2c ff ff
	ff 01 01 00 00	 cmp	 DWORD PTR tv64[ebp], 257 ; 00000101H
  000ac	0f 84 eb 0a 00
	00		 je	 $LN55@MainWndPro
  000b2	e9 42 0d 00 00	 jmp	 $LN2@MainWndPro
$LN85@MainWndPro:
  000b7	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  000bd	81 e9 00 02 00
	00		 sub	 ecx, 512		; 00000200H
  000c3	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv64[ebp], ecx
  000c9	83 bd 2c ff ff
	ff 32		 cmp	 DWORD PTR tv64[ebp], 50	; 00000032H
  000d0	0f 87 23 0d 00
	00		 ja	 $LN2@MainWndPro
  000d6	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv64[ebp]
  000dc	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN88@MainWndPro[edx]
  000e3	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN91@MainWndPro[eax*4]
$LN6@MainWndPro:

; 4427 :    {
; 4428 :       case WM_CREATE: // The window is being created
; 4429 : 
; 4430 :          hscreen_dc = CreateCompatibleDC(NULL); // screen device context

  000ea	6a 00		 push	 0
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  000f2	a3 00 00 00 00	 mov	 DWORD PTR _hscreen_dc, eax

; 4431 :          hwnd_dialog = CreateDialog(hinstance, MAKEINTRESOURCE(IDD_MAN_DIALOG), hwnd, man_dialog_proc);

  000f7	6a 00		 push	 0
  000f9	68 00 00 00 00	 push	 OFFSET _man_dialog_proc@16
  000fe	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00101	50		 push	 eax
  00102	6a 65		 push	 101			; 00000065H
  00104	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hinstance
  0010a	51		 push	 ecx
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamA@20
  00111	a3 00 00 00 00	 mov	 DWORD PTR _hwnd_dialog, eax

; 4432 :          hpen = CreatePen(PS_SOLID, 2, RGB(0, 0, 0)); // pen for the zoom rectangle; easier to see than PS_DOT

  00116	6a 00		 push	 0
  00118	6a 02		 push	 2
  0011a	6a 00		 push	 0
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreatePen@12
  00122	a3 00 00 00 00	 mov	 DWORD PTR ?hpen@?1??MainWndProc@@9@9, eax

; 4433 :          setup_sliders();

  00127	e8 00 00 00 00	 call	 _setup_sliders

; 4434 :          set_alg_warning(); // warn if normalized rendering and fast alg

  0012c	e8 00 00 00 00	 call	 _set_alg_warning

; 4435 : 
; 4436 :          return FALSE;

  00131	33 c0		 xor	 eax, eax
  00133	e9 d7 0c 00 00	 jmp	 $LN1@MainWndPro
$LN7@MainWndPro:

; 4437 : 
; 4438 :       case WM_PAINT: // The window needs to be painted (redrawn).
; 4439 : 
; 4440 :          hdc = BeginPaint(hwnd, &ps);

  00138	8d 45 ac	 lea	 eax, DWORD PTR _ps$[ebp]
  0013b	50		 push	 eax
  0013c	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0013f	51		 push	 ecx
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BeginPaint@8
  00146	89 45 ec	 mov	 DWORD PTR _hdc$[ebp], eax

; 4441 : 
; 4442 :          // Blit the mandelbrot bitmap. Could take rectangular regions from 1 to 4 quadrants.
; 4443 :          // Blits thin horizontal stripes. See comments at striped_blit().
; 4444 :          // Do upper quadrants (UL and UR), then lower (LL and LR).
; 4445 : 
; 4446 :          // Also optimize for the case where we've recalculated the whole image (only UL
; 4447 :          // is valid). In this case do a normal blit.
; 4448 :          q = &quad[UL];

  00149	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  0014e	6b c8 00	 imul	 ecx, eax, 0
  00151	81 c1 00 00 00
	00		 add	 ecx, OFFSET _quad
  00157	89 4d a8	 mov	 DWORD PTR _q$[ebp], ecx

; 4449 :          if (q->blit_xsize == m->xsize && q->blit_ysize == m->ysize)

  0015a	8b 45 a8	 mov	 eax, DWORD PTR _q$[ebp]
  0015d	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00163	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00166	3b 91 88 8d 00
	00		 cmp	 edx, DWORD PTR [ecx+36232]
  0016c	75 55		 jne	 SHORT $LN8@MainWndPro
  0016e	8b 45 a8	 mov	 eax, DWORD PTR _q$[ebp]
  00171	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00177	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  0017a	3b 91 8c 8d 00
	00		 cmp	 edx, DWORD PTR [ecx+36236]
  00180	75 41		 jne	 SHORT $LN8@MainWndPro

; 4450 :          {
; 4451 :             SelectObject(hscreen_dc, q->handle);

  00182	8b 45 a8	 mov	 eax, DWORD PTR _q$[ebp]
  00185	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00188	51		 push	 ecx
  00189	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hscreen_dc
  0018f	52		 push	 edx
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 4452 :             BitBlt(hdc, 0, 0, q->blit_xsize, q->blit_ysize, hscreen_dc, 0, 0, SRCCOPY);

  00196	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  0019b	6a 00		 push	 0
  0019d	6a 00		 push	 0
  0019f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hscreen_dc
  001a4	50		 push	 eax
  001a5	8b 4d a8	 mov	 ecx, DWORD PTR _q$[ebp]
  001a8	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  001ab	52		 push	 edx
  001ac	8b 45 a8	 mov	 eax, DWORD PTR _q$[ebp]
  001af	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  001b2	51		 push	 ecx
  001b3	6a 00		 push	 0
  001b5	6a 00		 push	 0
  001b7	8b 55 ec	 mov	 edx, DWORD PTR _hdc$[ebp]
  001ba	52		 push	 edx
  001bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 4453 :          }

  001c1	eb 5e		 jmp	 SHORT $LN9@MainWndPro
$LN8@MainWndPro:

; 4454 :          else
; 4455 :          {
; 4456 :             striped_blit(&quad[UL], &quad[UR], hdc, hscreen_dc);

  001c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _hscreen_dc
  001c8	50		 push	 eax
  001c9	8b 4d ec	 mov	 ecx, DWORD PTR _hdc$[ebp]
  001cc	51		 push	 ecx
  001cd	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  001d2	c1 e2 00	 shl	 edx, 0
  001d5	81 c2 00 00 00
	00		 add	 edx, OFFSET _quad
  001db	52		 push	 edx
  001dc	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  001e1	6b c8 00	 imul	 ecx, eax, 0
  001e4	81 c1 00 00 00
	00		 add	 ecx, OFFSET _quad
  001ea	51		 push	 ecx
  001eb	e8 00 00 00 00	 call	 _striped_blit
  001f0	83 c4 10	 add	 esp, 16			; 00000010H

; 4457 :             striped_blit(&quad[LL], &quad[LR], hdc, hscreen_dc);

  001f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _hscreen_dc
  001f8	50		 push	 eax
  001f9	8b 4d ec	 mov	 ecx, DWORD PTR _hdc$[ebp]
  001fc	51		 push	 ecx
  001fd	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  00202	6b c2 03	 imul	 eax, edx, 3
  00205	05 00 00 00 00	 add	 eax, OFFSET _quad
  0020a	50		 push	 eax
  0020b	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00210	d1 e1		 shl	 ecx, 1
  00212	81 c1 00 00 00
	00		 add	 ecx, OFFSET _quad
  00218	51		 push	 ecx
  00219	e8 00 00 00 00	 call	 _striped_blit
  0021e	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@MainWndPro:

; 4458 :          }
; 4459 :          EndPaint(hwnd, &ps);

  00221	8d 45 ac	 lea	 eax, DWORD PTR _ps$[ebp]
  00224	50		 push	 eax
  00225	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00228	51		 push	 ecx
  00229	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndPaint@8

; 4460 :          return FALSE;

  0022f	33 c0		 xor	 eax, eax
  00231	e9 d9 0b 00 00	 jmp	 $LN1@MainWndPro
$LN10@MainWndPro:

; 4461 : 
; 4462 :       case WM_LBUTTONDOWN:
; 4463 : 
; 4464 :          // Save the coordinates of the mouse cursor.
; 4465 :          mouse_x[0] = LOWORD(lParam);

  00236	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00239	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0023e	b9 04 00 00 00	 mov	 ecx, 4
  00243	6b d1 00	 imul	 edx, ecx, 0
  00246	0f b7 c0	 movzx	 eax, ax
  00249	89 82 00 00 00
	00		 mov	 DWORD PTR _mouse_x[edx], eax

; 4466 :          mouse_y[0] = HIWORD(lParam);

  0024f	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00252	c1 e8 10	 shr	 eax, 16			; 00000010H
  00255	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0025a	b9 04 00 00 00	 mov	 ecx, 4
  0025f	6b d1 00	 imul	 edx, ecx, 0
  00262	0f b7 c0	 movzx	 eax, ax
  00265	89 82 00 00 00
	00		 mov	 DWORD PTR _mouse_y[edx], eax

; 4467 :          mouse_x[1] = LOWORD(lParam); // Init this for switch from zoom to pan also

  0026b	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0026e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00273	b9 04 00 00 00	 mov	 ecx, 4
  00278	c1 e1 00	 shl	 ecx, 0
  0027b	0f b7 d0	 movzx	 edx, ax
  0027e	89 91 00 00 00
	00		 mov	 DWORD PTR _mouse_x[ecx], edx

; 4468 :          mouse_y[1] = HIWORD(lParam);

  00284	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00287	c1 e8 10	 shr	 eax, 16			; 00000010H
  0028a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0028f	b9 04 00 00 00	 mov	 ecx, 4
  00294	c1 e1 00	 shl	 ecx, 0
  00297	0f b7 d0	 movzx	 edx, ax
  0029a	89 91 00 00 00
	00		 mov	 DWORD PTR _mouse_y[ecx], edx

; 4469 : 
; 4470 :          update_re_im(m, m->pan_xoffs, m->pan_yoffs);    // update re/im from any pan offsets and reset offsets

  002a0	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  002a6	8b 88 a4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36260]
  002ac	51		 push	 ecx
  002ad	8b 90 a0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36256]
  002b3	52		 push	 edx
  002b4	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  002ba	8b 88 9c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36252]
  002c0	51		 push	 ecx
  002c1	8b 90 98 8d 00
	00		 mov	 edx, DWORD PTR [eax+36248]
  002c7	52		 push	 edx
  002c8	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  002ce	50		 push	 eax
  002cf	e8 00 00 00 00	 call	 _update_re_im
  002d4	83 c4 14	 add	 esp, 20			; 00000014H

; 4471 :          get_mouse_re_im(mouse_x[0], mouse_y[0]);  // Get re/im coords at the mouse position, for realtime zoom

  002d7	b8 04 00 00 00	 mov	 eax, 4
  002dc	6b c8 00	 imul	 ecx, eax, 0
  002df	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _mouse_y[ecx]
  002e5	52		 push	 edx
  002e6	b8 04 00 00 00	 mov	 eax, 4
  002eb	6b c8 00	 imul	 ecx, eax, 0
  002ee	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _mouse_x[ecx]
  002f4	52		 push	 edx
  002f5	e8 00 00 00 00	 call	 _get_mouse_re_im
  002fa	83 c4 08	 add	 esp, 8

; 4472 :          prev_mouse_x = -1;

  002fd	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?prev_mouse_x@?1??MainWndProc@@9@9, -1

; 4473 :          dragging = 1; // dragging either rectangle (for zoom) or image (for pan)

  00307	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?dragging@?1??MainWndProc@@9@9, 1

; 4474 : 
; 4475 :          confine_mouse_cursor();

  00311	e8 00 00 00 00	 call	 _confine_mouse_cursor

; 4476 : 
; 4477 :          if (nav_mode == MODE_PAN)

  00316	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _nav_mode, 3
  0031d	75 0c		 jne	 SHORT $LN11@MainWndPro

; 4478 :             SetCursor(hclosed_cursor);  // set closed hand

  0031f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hclosed_cursor
  00324	50		 push	 eax
  00325	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
$LN11@MainWndPro:

; 4479 :          if (nav_mode == MODE_RTZOOM)   // if in realtime zoom mode,

  0032b	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _nav_mode, 2
  00332	75 0c		 jne	 SHORT $LN12@MainWndPro

; 4480 :             do_rtzoom = RTZOOM_IN;      // set global flag for do_zooming()

  00334	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _do_rtzoom, 1
  0033e	eb 0a		 jmp	 SHORT $LN13@MainWndPro
$LN12@MainWndPro:

; 4481 :          else
; 4482 :             allow_mode_change = 0;      // don't allow mode change while button is down if not in rtzoom mode

  00340	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?allow_mode_change@?1??MainWndProc@@9@9, 0
$LN13@MainWndPro:

; 4483 : 
; 4484 :          return FALSE;

  0034a	33 c0		 xor	 eax, eax
  0034c	e9 be 0a 00 00	 jmp	 $LN1@MainWndPro
$LN14@MainWndPro:

; 4485 : 
; 4486 :       case WM_LBUTTONUP: // Zoom in
; 4487 : 
; 4488 :          mouse_x[1] = LOWORD(lParam);

  00351	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00354	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00359	b9 04 00 00 00	 mov	 ecx, 4
  0035e	c1 e1 00	 shl	 ecx, 0
  00361	0f b7 d0	 movzx	 edx, ax
  00364	89 91 00 00 00
	00		 mov	 DWORD PTR _mouse_x[ecx], edx

; 4489 :          mouse_y[1] = HIWORD(lParam);

  0036a	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0036d	c1 e8 10	 shr	 eax, 16			; 00000010H
  00370	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00375	b9 04 00 00 00	 mov	 ecx, 4
  0037a	c1 e1 00	 shl	 ecx, 0
  0037d	0f b7 d0	 movzx	 edx, ax
  00380	89 91 00 00 00
	00		 mov	 DWORD PTR _mouse_y[ecx], edx

; 4490 :          allow_mode_change = 1;  // Allow mode change again after button released

  00386	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?allow_mode_change@?1??MainWndProc@@9@9, 1

; 4491 : 
; 4492 :          if (dragging)

  00390	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?dragging@?1??MainWndProc@@9@9, 0
  00397	0f 84 83 00 00
	00		 je	 $LN15@MainWndPro

; 4493 :          {
; 4494 :             dragging = 0;

  0039d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dragging@?1??MainWndProc@@9@9, 0

; 4495 :             if (nav_mode == MODE_ZOOM)

  003a7	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _nav_mode, 1
  003ae	75 59		 jne	 SHORT $LN16@MainWndPro

; 4496 :             {
; 4497 :                // Update mandelbrot parms from rectangle and recalculate
; 4498 :                update_re_im_mag(have_box, 1, mouse_x[0], mouse_y[0], mouse_x[1], mouse_y[1]);

  003b0	b8 04 00 00 00	 mov	 eax, 4
  003b5	c1 e0 00	 shl	 eax, 0
  003b8	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _mouse_y[eax]
  003be	51		 push	 ecx
  003bf	ba 04 00 00 00	 mov	 edx, 4
  003c4	c1 e2 00	 shl	 edx, 0
  003c7	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_x[edx]
  003cd	50		 push	 eax
  003ce	b9 04 00 00 00	 mov	 ecx, 4
  003d3	6b d1 00	 imul	 edx, ecx, 0
  003d6	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_y[edx]
  003dc	50		 push	 eax
  003dd	b9 04 00 00 00	 mov	 ecx, 4
  003e2	6b d1 00	 imul	 edx, ecx, 0
  003e5	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_x[edx]
  003eb	50		 push	 eax
  003ec	6a 01		 push	 1
  003ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?have_box@?1??MainWndProc@@9@9
  003f4	51		 push	 ecx
  003f5	e8 00 00 00 00	 call	 _update_re_im_mag
  003fa	83 c4 18	 add	 esp, 24			; 00000018H

; 4499 :                do_man_calculate(1);

  003fd	6a 01		 push	 1
  003ff	e8 00 00 00 00	 call	 _do_man_calculate
  00404	83 c4 04	 add	 esp, 4

; 4500 :             }

  00407	eb 17		 jmp	 SHORT $LN15@MainWndPro
$LN16@MainWndPro:

; 4501 :             else // Update image info (excluding iters/sec) after pan or realtime zoom
; 4502 :                SetWindowText(hwnd_info, get_image_info(0));

  00409	6a 00		 push	 0
  0040b	e8 00 00 00 00	 call	 _get_image_info
  00410	83 c4 04	 add	 esp, 4
  00413	50		 push	 eax
  00414	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_info
  00419	50		 push	 eax
  0041a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
$LN15@MainWndPro:

; 4503 :          }
; 4504 :          have_box = 0;

  00420	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?have_box@?1??MainWndProc@@9@9, 0

; 4505 : 
; 4506 :          if (zoom_mode_pending) // go back to zoom mode if change was pending

  0042a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?zoom_mode_pending@?1??MainWndProc@@9@9, 0
  00431	74 2e		 je	 SHORT $LN18@MainWndPro

; 4507 :          {
; 4508 :             nav_mode = prev_nav_mode;

  00433	a1 00 00 00 00	 mov	 eax, DWORD PTR ?prev_nav_mode@?1??MainWndProc@@9@9
  00438	a3 00 00 00 00	 mov	 DWORD PTR _nav_mode, eax

; 4509 :             if (GetCursor() != arrow_cursor) // Only if space released in client area (kluge)

  0043d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursor@0
  00443	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _arrow_cursor
  00449	74 0c		 je	 SHORT $LN19@MainWndPro

; 4510 :                SetCursor(mag_zoom_cursor);

  0044b	a1 00 00 00 00	 mov	 eax, DWORD PTR _mag_zoom_cursor
  00450	50		 push	 eax
  00451	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
$LN19@MainWndPro:

; 4511 :             zoom_mode_pending = 0;

  00457	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?zoom_mode_pending@?1??MainWndProc@@9@9, 0
$LN18@MainWndPro:

; 4512 :          }
; 4513 :          // allow dragging during zooming. Possibly some bug here, but I think I fixed it
; 4514 :          if (nav_mode != MODE_PAN)           // this implements zoom lock

  00461	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _nav_mode, 3
  00468	74 14		 je	 SHORT $LN20@MainWndPro

; 4515 :             do_rtzoom = prev_do_rtzoom = 0;  // clear realtime zoom flag for do_zooming()

  0046a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _prev_do_rtzoom, 0
  00474	a1 00 00 00 00	 mov	 eax, DWORD PTR _prev_do_rtzoom
  00479	a3 00 00 00 00	 mov	 DWORD PTR _do_rtzoom, eax
$LN20@MainWndPro:

; 4516 : 
; 4517 :          ClipCursor(NULL); // release mouse cursor and capture

  0047e	6a 00		 push	 0
  00480	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClipCursor@4

; 4518 :          ReleaseCapture();

  00486	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseCapture@0

; 4519 : 
; 4520 :          return FALSE;

  0048c	33 c0		 xor	 eax, eax
  0048e	e9 7c 09 00 00	 jmp	 $LN1@MainWndPro
$LN21@MainWndPro:

; 4521 : 
; 4522 :       case WM_MOUSEMOVE:
; 4523 : 
; 4524 :          mouse_x[1] = LOWORD(lParam);

  00493	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00496	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0049b	b9 04 00 00 00	 mov	 ecx, 4
  004a0	c1 e1 00	 shl	 ecx, 0
  004a3	0f b7 d0	 movzx	 edx, ax
  004a6	89 91 00 00 00
	00		 mov	 DWORD PTR _mouse_x[ecx], edx

; 4525 :          mouse_y[1] = HIWORD(lParam);

  004ac	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  004af	c1 e8 10	 shr	 eax, 16			; 00000010H
  004b2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  004b7	b9 04 00 00 00	 mov	 ecx, 4
  004bc	c1 e1 00	 shl	 ecx, 0
  004bf	0f b7 d0	 movzx	 edx, ax
  004c2	89 91 00 00 00
	00		 mov	 DWORD PTR _mouse_y[ecx], edx

; 4526 :          get_mouse_re_im(mouse_x[1], mouse_y[1]);  // Get re/im coords at the mouse position, for realtime zoom

  004c8	b8 04 00 00 00	 mov	 eax, 4
  004cd	c1 e0 00	 shl	 eax, 0
  004d0	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _mouse_y[eax]
  004d6	51		 push	 ecx
  004d7	ba 04 00 00 00	 mov	 edx, 4
  004dc	c1 e2 00	 shl	 edx, 0
  004df	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_x[edx]
  004e5	50		 push	 eax
  004e6	e8 00 00 00 00	 call	 _get_mouse_re_im
  004eb	83 c4 08	 add	 esp, 8

; 4527 : 
; 4528 :          // If user is dragging, draw the zoom rectangle (zoom mode) or pan the image (pan mode)
; 4529 :          if (nav_mode == MODE_PAN) // panning mode- move the image

  004ee	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _nav_mode, 3
  004f5	0f 85 a3 00 00
	00		 jne	 $LN22@MainWndPro

; 4530 :          {
; 4531 :             if (wParam & (MK_LBUTTON | MK_RBUTTON)) // allow panning using right button drag also

  004fb	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  004fe	83 e0 03	 and	 eax, 3
  00501	0f 84 92 00 00
	00		 je	 $LN24@MainWndPro

; 4532 :             {
; 4533 :                int offs_x, offs_y;
; 4534 : 
; 4535 :                // Get difference from previous mouse location; use as pan offset
; 4536 :                offs_x = mouse_x[1] - mouse_x[0];

  00507	b8 04 00 00 00	 mov	 eax, 4
  0050c	c1 e0 00	 shl	 eax, 0
  0050f	b9 04 00 00 00	 mov	 ecx, 4
  00514	6b d1 00	 imul	 edx, ecx, 0
  00517	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_x[eax]
  0051d	2b 82 00 00 00
	00		 sub	 eax, DWORD PTR _mouse_x[edx]
  00523	89 85 74 ff ff
	ff		 mov	 DWORD PTR _offs_x$2[ebp], eax

; 4537 :                offs_y = mouse_y[1] - mouse_y[0];

  00529	b8 04 00 00 00	 mov	 eax, 4
  0052e	c1 e0 00	 shl	 eax, 0
  00531	b9 04 00 00 00	 mov	 ecx, 4
  00536	6b d1 00	 imul	 edx, ecx, 0
  00539	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_y[eax]
  0053f	2b 82 00 00 00
	00		 sub	 eax, DWORD PTR _mouse_y[edx]
  00545	89 85 70 ff ff
	ff		 mov	 DWORD PTR _offs_y$1[ebp], eax

; 4538 : 
; 4539 :                mouse_x[0] = mouse_x[1];    // update previous mouse location

  0054b	b8 04 00 00 00	 mov	 eax, 4
  00550	c1 e0 00	 shl	 eax, 0
  00553	b9 04 00 00 00	 mov	 ecx, 4
  00558	6b d1 00	 imul	 edx, ecx, 0
  0055b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_x[eax]
  00561	89 82 00 00 00
	00		 mov	 DWORD PTR _mouse_x[edx], eax

; 4540 :                mouse_y[0] = mouse_y[1];

  00567	b8 04 00 00 00	 mov	 eax, 4
  0056c	c1 e0 00	 shl	 eax, 0
  0056f	b9 04 00 00 00	 mov	 ecx, 4
  00574	6b d1 00	 imul	 edx, ecx, 0
  00577	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_y[eax]
  0057d	89 82 00 00 00
	00		 mov	 DWORD PTR _mouse_y[edx], eax

; 4541 : 
; 4542 :                pan_image(offs_x, offs_y);  // do the pan

  00583	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _offs_y$1[ebp]
  00589	50		 push	 eax
  0058a	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _offs_x$2[ebp]
  00590	51		 push	 ecx
  00591	e8 00 00 00 00	 call	 _pan_image
  00596	83 c4 08	 add	 esp, 8
$LN24@MainWndPro:

; 4543 :             }
; 4544 :          }

  00599	e9 18 01 00 00	 jmp	 $LN23@MainWndPro
$LN22@MainWndPro:

; 4545 :          else if (nav_mode == MODE_ZOOM)

  0059e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _nav_mode, 1
  005a5	0f 85 0b 01 00
	00		 jne	 $LN23@MainWndPro

; 4546 :          {
; 4547 :             if ((wParam & MK_LBUTTON) && dragging) // zoom rectangle

  005ab	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  005ae	83 e0 01	 and	 eax, 1
  005b1	0f 84 ff 00 00
	00		 je	 $LN23@MainWndPro
  005b7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?dragging@?1??MainWndProc@@9@9, 0
  005be	0f 84 f2 00 00
	00		 je	 $LN23@MainWndPro

; 4548 :             {
; 4549 :                hdc = GetDC(hwnd);

  005c4	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  005c7	50		 push	 eax
  005c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  005ce	89 45 ec	 mov	 DWORD PTR _hdc$[ebp], eax

; 4550 :                SelectObject(hdc, hpen);

  005d1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hpen@?1??MainWndProc@@9@9
  005d6	50		 push	 eax
  005d7	8b 4d ec	 mov	 ecx, DWORD PTR _hdc$[ebp]
  005da	51		 push	 ecx
  005db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 4551 : 
; 4552 :                SetROP2(hdc, R2_NOTXORPEN); // not ideal- can be tough to see at times

  005e1	6a 0a		 push	 10			; 0000000aH
  005e3	8b 45 ec	 mov	 eax, DWORD PTR _hdc$[ebp]
  005e6	50		 push	 eax
  005e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetROP2@8

; 4553 : 
; 4554 :                // erase previous rectangle, if it exists
; 4555 :                if (prev_mouse_x >= 0 && prev_mouse_x != mouse_x[0])

  005ed	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?prev_mouse_x@?1??MainWndProc@@9@9, 0
  005f4	7c 55		 jl	 SHORT $LN27@MainWndPro
  005f6	b8 04 00 00 00	 mov	 eax, 4
  005fb	6b c8 00	 imul	 ecx, eax, 0
  005fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?prev_mouse_x@?1??MainWndProc@@9@9
  00604	3b 91 00 00 00
	00		 cmp	 edx, DWORD PTR _mouse_x[ecx]
  0060a	74 3f		 je	 SHORT $LN27@MainWndPro

; 4556 :                {
; 4557 :                   Rectangle(hdc, mouse_x[0], mouse_y[0], prev_mouse_x, prev_mouse_y);

  0060c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?prev_mouse_y@?1??MainWndProc@@9@9
  00611	50		 push	 eax
  00612	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?prev_mouse_x@?1??MainWndProc@@9@9
  00618	51		 push	 ecx
  00619	ba 04 00 00 00	 mov	 edx, 4
  0061e	6b c2 00	 imul	 eax, edx, 0
  00621	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _mouse_y[eax]
  00627	51		 push	 ecx
  00628	ba 04 00 00 00	 mov	 edx, 4
  0062d	6b c2 00	 imul	 eax, edx, 0
  00630	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _mouse_x[eax]
  00636	51		 push	 ecx
  00637	8b 55 ec	 mov	 edx, DWORD PTR _hdc$[ebp]
  0063a	52		 push	 edx
  0063b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Rectangle@20

; 4558 :                   have_box = 1;

  00641	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?have_box@?1??MainWndProc@@9@9, 1
$LN27@MainWndPro:

; 4559 :                }
; 4560 : 
; 4561 :                // draw new rectangle
; 4562 :                Rectangle(hdc, mouse_x[0], mouse_y[0],

  0064b	b8 04 00 00 00	 mov	 eax, 4
  00650	c1 e0 00	 shl	 eax, 0
  00653	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _mouse_y[eax]
  00659	89 0d 00 00 00
	00		 mov	 DWORD PTR ?prev_mouse_y@?1??MainWndProc@@9@9, ecx
  0065f	ba 04 00 00 00	 mov	 edx, 4
  00664	c1 e2 00	 shl	 edx, 0
  00667	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_x[edx]
  0066d	a3 00 00 00 00	 mov	 DWORD PTR ?prev_mouse_x@?1??MainWndProc@@9@9, eax
  00672	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?prev_mouse_y@?1??MainWndProc@@9@9
  00678	51		 push	 ecx
  00679	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?prev_mouse_x@?1??MainWndProc@@9@9
  0067f	52		 push	 edx
  00680	b8 04 00 00 00	 mov	 eax, 4
  00685	6b c8 00	 imul	 ecx, eax, 0
  00688	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _mouse_y[ecx]
  0068e	52		 push	 edx
  0068f	b8 04 00 00 00	 mov	 eax, 4
  00694	6b c8 00	 imul	 ecx, eax, 0
  00697	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _mouse_x[ecx]
  0069d	52		 push	 edx
  0069e	8b 45 ec	 mov	 eax, DWORD PTR _hdc$[ebp]
  006a1	50		 push	 eax
  006a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Rectangle@20

; 4563 :                          prev_mouse_x = mouse_x[1], prev_mouse_y = mouse_y[1]);
; 4564 :                ReleaseDC(hwnd, hdc);

  006a8	8b 45 ec	 mov	 eax, DWORD PTR _hdc$[ebp]
  006ab	50		 push	 eax
  006ac	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  006af	51		 push	 ecx
  006b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
$LN23@MainWndPro:

; 4565 :             }
; 4566 :          }
; 4567 :          return FALSE;

  006b6	33 c0		 xor	 eax, eax
  006b8	e9 52 07 00 00	 jmp	 $LN1@MainWndPro
$LN28@MainWndPro:

; 4568 : 
; 4569 :       case WM_RBUTTONDOWN: // Zoom out
; 4570 : 
; 4571 :          mouse_x[0] = LOWORD(lParam);

  006bd	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  006c0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  006c5	b9 04 00 00 00	 mov	 ecx, 4
  006ca	6b d1 00	 imul	 edx, ecx, 0
  006cd	0f b7 c0	 movzx	 eax, ax
  006d0	89 82 00 00 00
	00		 mov	 DWORD PTR _mouse_x[edx], eax

; 4572 :          mouse_y[0] = HIWORD(lParam);

  006d6	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  006d9	c1 e8 10	 shr	 eax, 16			; 00000010H
  006dc	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  006e1	b9 04 00 00 00	 mov	 ecx, 4
  006e6	6b d1 00	 imul	 edx, ecx, 0
  006e9	0f b7 c0	 movzx	 eax, ax
  006ec	89 82 00 00 00
	00		 mov	 DWORD PTR _mouse_y[edx], eax

; 4573 :          mouse_x[1] = LOWORD(lParam); // Init this for switch from zoom to pan also

  006f2	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  006f5	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  006fa	b9 04 00 00 00	 mov	 ecx, 4
  006ff	c1 e1 00	 shl	 ecx, 0
  00702	0f b7 d0	 movzx	 edx, ax
  00705	89 91 00 00 00
	00		 mov	 DWORD PTR _mouse_x[ecx], edx

; 4574 :          mouse_y[1] = HIWORD(lParam);

  0070b	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0070e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00711	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00716	b9 04 00 00 00	 mov	 ecx, 4
  0071b	c1 e1 00	 shl	 ecx, 0
  0071e	0f b7 d0	 movzx	 edx, ax
  00721	89 91 00 00 00
	00		 mov	 DWORD PTR _mouse_y[ecx], edx

; 4575 : 
; 4576 :          update_re_im(m, m->pan_xoffs, m->pan_yoffs);  // update re/im from any pan offsets and reset offsets

  00727	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  0072d	8b 88 a4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36260]
  00733	51		 push	 ecx
  00734	8b 90 a0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36256]
  0073a	52		 push	 edx
  0073b	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00741	8b 88 9c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36252]
  00747	51		 push	 ecx
  00748	8b 90 98 8d 00
	00		 mov	 edx, DWORD PTR [eax+36248]
  0074e	52		 push	 edx
  0074f	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00755	50		 push	 eax
  00756	e8 00 00 00 00	 call	 _update_re_im
  0075b	83 c4 14	 add	 esp, 20			; 00000014H

; 4577 :          get_mouse_re_im(mouse_x[0], mouse_y[0]);  // get re/im coords at the mouse position, for realtime zoom

  0075e	b8 04 00 00 00	 mov	 eax, 4
  00763	6b c8 00	 imul	 ecx, eax, 0
  00766	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _mouse_y[ecx]
  0076c	52		 push	 edx
  0076d	b8 04 00 00 00	 mov	 eax, 4
  00772	6b c8 00	 imul	 ecx, eax, 0
  00775	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _mouse_x[ecx]
  0077b	52		 push	 edx
  0077c	e8 00 00 00 00	 call	 _get_mouse_re_im
  00781	83 c4 08	 add	 esp, 8

; 4578 : 
; 4579 :          if (nav_mode == MODE_RTZOOM)  // if in realtime zoom mode,

  00784	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _nav_mode, 2
  0078b	75 0c		 jne	 SHORT $LN29@MainWndPro

; 4580 :             do_rtzoom = RTZOOM_OUT;    // set global flag for do_zooming()

  0078d	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _do_rtzoom, 2
  00797	eb 0a		 jmp	 SHORT $LN30@MainWndPro
$LN29@MainWndPro:

; 4581 :          else
; 4582 :             allow_mode_change = 0;     // else don't allow mode change while button is down

  00799	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?allow_mode_change@?1??MainWndProc@@9@9, 0
$LN30@MainWndPro:

; 4583 : 
; 4584 :          if (nav_mode == MODE_PAN)

  007a3	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _nav_mode, 3
  007aa	75 0c		 jne	 SHORT $LN31@MainWndPro

; 4585 :             SetCursor(hclosed_cursor); // set closed hand

  007ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _hclosed_cursor
  007b1	50		 push	 eax
  007b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
$LN31@MainWndPro:

; 4586 : 
; 4587 :          confine_mouse_cursor();       // also need to confine here, for realtime zoom

  007b8	e8 00 00 00 00	 call	 _confine_mouse_cursor

; 4588 :          return FALSE;

  007bd	33 c0		 xor	 eax, eax
  007bf	e9 4b 06 00 00	 jmp	 $LN1@MainWndPro
$LN32@MainWndPro:

; 4589 : 
; 4590 :       case WM_RBUTTONUP: // Zoom out
; 4591 : 
; 4592 :          mouse_x[1] = LOWORD(lParam);

  007c4	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  007c7	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  007cc	b9 04 00 00 00	 mov	 ecx, 4
  007d1	c1 e1 00	 shl	 ecx, 0
  007d4	0f b7 d0	 movzx	 edx, ax
  007d7	89 91 00 00 00
	00		 mov	 DWORD PTR _mouse_x[ecx], edx

; 4593 :          mouse_y[1] = HIWORD(lParam);

  007dd	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  007e0	c1 e8 10	 shr	 eax, 16			; 00000010H
  007e3	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  007e8	b9 04 00 00 00	 mov	 ecx, 4
  007ed	c1 e1 00	 shl	 ecx, 0
  007f0	0f b7 d0	 movzx	 edx, ax
  007f3	89 91 00 00 00
	00		 mov	 DWORD PTR _mouse_y[ecx], edx

; 4594 :          allow_mode_change = 1;  // allow mode change again after button released

  007f9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?allow_mode_change@?1??MainWndProc@@9@9, 1

; 4595 : 
; 4596 :          // Zoom out from current point, and recenter
; 4597 :          if (nav_mode == MODE_ZOOM)

  00803	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _nav_mode, 1
  0080a	75 52		 jne	 SHORT $LN33@MainWndPro

; 4598 :          {
; 4599 :             update_re_im_mag(0, 0, mouse_x[0], mouse_y[0], mouse_x[1], mouse_y[1]);

  0080c	b8 04 00 00 00	 mov	 eax, 4
  00811	c1 e0 00	 shl	 eax, 0
  00814	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _mouse_y[eax]
  0081a	51		 push	 ecx
  0081b	ba 04 00 00 00	 mov	 edx, 4
  00820	c1 e2 00	 shl	 edx, 0
  00823	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_x[edx]
  00829	50		 push	 eax
  0082a	b9 04 00 00 00	 mov	 ecx, 4
  0082f	6b d1 00	 imul	 edx, ecx, 0
  00832	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_y[edx]
  00838	50		 push	 eax
  00839	b9 04 00 00 00	 mov	 ecx, 4
  0083e	6b d1 00	 imul	 edx, ecx, 0
  00841	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_x[edx]
  00847	50		 push	 eax
  00848	6a 00		 push	 0
  0084a	6a 00		 push	 0
  0084c	e8 00 00 00 00	 call	 _update_re_im_mag
  00851	83 c4 18	 add	 esp, 24			; 00000018H

; 4600 :             do_man_calculate(1);

  00854	6a 01		 push	 1
  00856	e8 00 00 00 00	 call	 _do_man_calculate
  0085b	83 c4 04	 add	 esp, 4
$LN33@MainWndPro:

; 4601 :          }
; 4602 :          if (nav_mode != MODE_PAN)           // this implements zoom lock

  0085e	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _nav_mode, 3
  00865	74 14		 je	 SHORT $LN34@MainWndPro

; 4603 :             do_rtzoom = prev_do_rtzoom = 0;  // clear realtime zoom flag for do_zooming()

  00867	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _prev_do_rtzoom, 0
  00871	a1 00 00 00 00	 mov	 eax, DWORD PTR _prev_do_rtzoom
  00876	a3 00 00 00 00	 mov	 DWORD PTR _do_rtzoom, eax
$LN34@MainWndPro:

; 4604 : 
; 4605 :          ClipCursor(NULL);                // release mouse cursor and capture

  0087b	6a 00		 push	 0
  0087d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClipCursor@4

; 4606 :          ReleaseCapture();

  00883	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseCapture@0

; 4607 :          return FALSE;

  00889	33 c0		 xor	 eax, eax
  0088b	e9 7f 05 00 00	 jmp	 $LN1@MainWndPro
$LN35@MainWndPro:

; 4608 : 
; 4609 :       case WM_MOUSEWHEEL: // Use mousewheel to adjust iterations. (Maybe palette too, if button down?)
; 4610 : 
; 4611 :          if (GET_WHEEL_DELTA_WPARAM(wParam) > 0)

  00890	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00893	c1 e8 10	 shr	 eax, 16			; 00000010H
  00896	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0089b	0f bf c8	 movsx	 ecx, ax
  0089e	85 c9		 test	 ecx, ecx
  008a0	7e 0e		 jle	 SHORT $LN36@MainWndPro

; 4612 :             update_iters(1, 0);

  008a2	6a 00		 push	 0
  008a4	6a 01		 push	 1
  008a6	e8 00 00 00 00	 call	 _update_iters
  008ab	83 c4 08	 add	 esp, 8
  008ae	eb 0c		 jmp	 SHORT $LN37@MainWndPro
$LN36@MainWndPro:

; 4613 :          else
; 4614 :             update_iters(0, 1);

  008b0	6a 01		 push	 1
  008b2	6a 00		 push	 0
  008b4	e8 00 00 00 00	 call	 _update_iters
  008b9	83 c4 08	 add	 esp, 8
$LN37@MainWndPro:

; 4615 :          SetDlgItemInt(hwnd_dialog, IDC_ITERS, m->max_iters, FALSE);

  008bc	6a 00		 push	 0
  008be	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  008c4	8b 88 c0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36288]
  008ca	51		 push	 ecx
  008cb	68 fb 03 00 00	 push	 1019			; 000003fbH
  008d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hwnd_dialog
  008d6	52		 push	 edx
  008d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemInt@16

; 4616 :          return FALSE;

  008dd	33 c0		 xor	 eax, eax
  008df	e9 2b 05 00 00	 jmp	 $LN1@MainWndPro
$LN38@MainWndPro:

; 4617 : 
; 4618 :       case WM_KEYDOWN:  // Go to pan mode while space is held down (if allowed)
; 4619 : 
; 4620 :          #define PREV_KEYDOWN (1 << 30)
; 4621 : 
; 4622 :          if (lParam & PREV_KEYDOWN) // aargh... ignore key autorepeats. Were wiping out prev_do_rtzoom.

  008e4	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  008e7	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  008ec	74 0a		 je	 SHORT $LN39@MainWndPro

; 4623 :             return TRUE;

  008ee	b8 01 00 00 00	 mov	 eax, 1
  008f3	e9 17 05 00 00	 jmp	 $LN1@MainWndPro
$LN39@MainWndPro:

; 4624 : 
; 4625 :          if (allow_mode_change)

  008f8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?allow_mode_change@?1??MainWndProc@@9@9, 0
  008ff	0f 84 50 01 00
	00		 je	 $LN40@MainWndPro

; 4626 :          {
; 4627 :             if (wParam == 'Z') // toggle zoom mode

  00905	83 7d 10 5a	 cmp	 DWORD PTR _wParam$[ebp], 90 ; 0000005aH
  00909	0f 85 87 00 00
	00		 jne	 $LN41@MainWndPro

; 4628 :             {
; 4629 :                mag_zoom_cursor = (mag_zoom_cursor == mag_cursor) ? rtzoom_cursor : mag_cursor;

  0090f	a1 00 00 00 00	 mov	 eax, DWORD PTR _mag_zoom_cursor
  00914	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _mag_cursor
  0091a	75 0e		 jne	 SHORT $LN75@MainWndPro
  0091c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rtzoom_cursor
  00922	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv388[ebp], ecx
  00928	eb 0c		 jmp	 SHORT $LN76@MainWndPro
$LN75@MainWndPro:
  0092a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _mag_cursor
  00930	89 95 2c ff ff
	ff		 mov	 DWORD PTR tv388[ebp], edx
$LN76@MainWndPro:
  00936	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv388[ebp]
  0093c	a3 00 00 00 00	 mov	 DWORD PTR _mag_zoom_cursor, eax

; 4630 :                nav_mode = prev_nav_mode = (mag_zoom_cursor == mag_cursor) ? MODE_ZOOM : MODE_RTZOOM;

  00941	a1 00 00 00 00	 mov	 eax, DWORD PTR _mag_zoom_cursor
  00946	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _mag_cursor
  0094c	75 0c		 jne	 SHORT $LN77@MainWndPro
  0094e	c7 85 2c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv390[ebp], 1
  00958	eb 0a		 jmp	 SHORT $LN78@MainWndPro
$LN77@MainWndPro:
  0095a	c7 85 2c ff ff
	ff 02 00 00 00	 mov	 DWORD PTR tv390[ebp], 2
$LN78@MainWndPro:
  00964	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv390[ebp]
  0096a	89 0d 00 00 00
	00		 mov	 DWORD PTR ?prev_nav_mode@?1??MainWndProc@@9@9, ecx
  00970	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?prev_nav_mode@?1??MainWndProc@@9@9
  00976	89 15 00 00 00
	00		 mov	 DWORD PTR _nav_mode, edx

; 4631 :                if (GetCursor() != arrow_cursor) // Change cursor only if released in client area (kluge)

  0097c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursor@0
  00982	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _arrow_cursor
  00988	74 0c		 je	 SHORT $LN41@MainWndPro

; 4632 :                   SetCursor(mag_zoom_cursor);

  0098a	a1 00 00 00 00	 mov	 eax, DWORD PTR _mag_zoom_cursor
  0098f	50		 push	 eax
  00990	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
$LN41@MainWndPro:

; 4633 :             }
; 4634 :             nav_mode = (wParam == VK_SPACE) ? MODE_PAN : prev_nav_mode;

  00996	83 7d 10 20	 cmp	 DWORD PTR _wParam$[ebp], 32 ; 00000020H
  0099a	75 0c		 jne	 SHORT $LN79@MainWndPro
  0099c	c7 85 2c ff ff
	ff 03 00 00 00	 mov	 DWORD PTR tv395[ebp], 3
  009a6	eb 0b		 jmp	 SHORT $LN80@MainWndPro
$LN79@MainWndPro:
  009a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?prev_nav_mode@?1??MainWndProc@@9@9
  009ad	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv395[ebp], eax
$LN80@MainWndPro:
  009b3	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv395[ebp]
  009b9	89 0d 00 00 00
	00		 mov	 DWORD PTR _nav_mode, ecx

; 4635 :             if (nav_mode == MODE_PAN)

  009bf	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _nav_mode, 3
  009c6	0f 85 89 00 00
	00		 jne	 $LN40@MainWndPro

; 4636 :             {
; 4637 :                mouse_x[0] = mouse_x[1];            // Reset mouse position for pan

  009cc	b8 04 00 00 00	 mov	 eax, 4
  009d1	c1 e0 00	 shl	 eax, 0
  009d4	b9 04 00 00 00	 mov	 ecx, 4
  009d9	6b d1 00	 imul	 edx, ecx, 0
  009dc	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_x[eax]
  009e2	89 82 00 00 00
	00		 mov	 DWORD PTR _mouse_x[edx], eax

; 4638 :                mouse_y[0] = mouse_y[1];

  009e8	b8 04 00 00 00	 mov	 eax, 4
  009ed	c1 e0 00	 shl	 eax, 0
  009f0	b9 04 00 00 00	 mov	 ecx, 4
  009f5	6b d1 00	 imul	 edx, ecx, 0
  009f8	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_y[eax]
  009fe	89 82 00 00 00
	00		 mov	 DWORD PTR _mouse_y[edx], eax

; 4639 :                prev_do_rtzoom = do_rtzoom;         // save realtime zoom state

  00a04	a1 00 00 00 00	 mov	 eax, DWORD PTR _do_rtzoom
  00a09	a3 00 00 00 00	 mov	 DWORD PTR _prev_do_rtzoom, eax

; 4640 :                do_rtzoom = 0;                      // stop any realtime zoom

  00a0e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _do_rtzoom, 0

; 4641 :                if (GetCursor() == mag_zoom_cursor) // Fix toggling between hand and arrow in non-client area (kluge)

  00a18	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursor@0
  00a1e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _mag_zoom_cursor
  00a24	75 2f		 jne	 SHORT $LN40@MainWndPro

; 4642 :                   SetCursor(prev_do_rtzoom ? hclosed_cursor : hopen_cursor);

  00a26	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _prev_do_rtzoom, 0
  00a2d	74 0d		 je	 SHORT $LN81@MainWndPro
  00a2f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hclosed_cursor
  00a34	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv409[ebp], eax
  00a3a	eb 0c		 jmp	 SHORT $LN82@MainWndPro
$LN81@MainWndPro:
  00a3c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hopen_cursor
  00a42	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv409[ebp], ecx
$LN82@MainWndPro:
  00a48	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv409[ebp]
  00a4e	52		 push	 edx
  00a4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
$LN40@MainWndPro:

; 4643 :             }
; 4644 :          }
; 4645 : 
; 4646 :          // Handle the various hotkeys
; 4647 :          switch (wParam)

  00a55	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00a58	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv407[ebp], eax
  00a5e	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv407[ebp]
  00a64	83 e9 1b	 sub	 ecx, 27			; 0000001bH
  00a67	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv407[ebp], ecx
  00a6d	83 bd 2c ff ff
	ff 35		 cmp	 DWORD PTR tv407[ebp], 53 ; 00000035H
  00a74	0f 87 f7 00 00
	00		 ja	 $LN4@MainWndPro
  00a7a	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv407[ebp]
  00a80	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN89@MainWndPro[edx]
  00a87	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN92@MainWndPro[eax*4]
$LN45@MainWndPro:

; 4648 :          {
; 4649 :             case 'C': // 'C' toggles the control dialog on and off. Allow to work in non-fullscreen mode too.
; 4650 :                update_dialog((status ^= STAT_DIALOG_HIDDEN) & STAT_DIALOG_HIDDEN, 0); // 0 = don't move

  00a8e	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00a93	83 f0 10	 xor	 eax, 16			; 00000010H
  00a96	a3 00 00 00 00	 mov	 DWORD PTR _status, eax
  00a9b	6a 00		 push	 0
  00a9d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _status
  00aa3	83 e1 10	 and	 ecx, 16			; 00000010H
  00aa6	51		 push	 ecx
  00aa7	e8 00 00 00 00	 call	 _update_dialog
  00aac	83 c4 08	 add	 esp, 8

; 4651 :                break;

  00aaf	e9 bd 00 00 00	 jmp	 $LN4@MainWndPro
$LN46@MainWndPro:

; 4652 :             case VK_ESCAPE: // ESC exits out of fullscreen mode but does not enter it.
; 4653 :                if (!(status & STAT_FULLSCREEN)) // deliberate fallthrough if fullscreen

  00ab4	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00ab9	83 e0 04	 and	 eax, 4
  00abc	75 05		 jne	 SHORT $LN48@MainWndPro

; 4654 :                   break;

  00abe	e9 ae 00 00 00	 jmp	 $LN4@MainWndPro
$LN48@MainWndPro:

; 4655 :             case 'F': // 'F' both exits and enters fullscreen mode.
; 4656 :                SendMessage(hwnd_dialog, WM_COMMAND, ID_FULLSCREEN, 0);

  00ac3	6a 00		 push	 0
  00ac5	6a 0d		 push	 13			; 0000000dH
  00ac7	68 11 01 00 00	 push	 273			; 00000111H
  00acc	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  00ad1	50		 push	 eax
  00ad2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4657 :                break;

  00ad8	e9 94 00 00 00	 jmp	 $LN4@MainWndPro
$LN49@MainWndPro:

; 4658 :             case 'N': // 'N', 'P', and 'H' do log next/previous and home buttons.
; 4659 :                SendMessage(hwnd_dialog, WM_COMMAND, ID_LOG_NEXT, 0);

  00add	6a 00		 push	 0
  00adf	6a 08		 push	 8
  00ae1	68 11 01 00 00	 push	 273			; 00000111H
  00ae6	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  00aeb	50		 push	 eax
  00aec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4660 :                break;

  00af2	eb 7d		 jmp	 SHORT $LN4@MainWndPro
$LN50@MainWndPro:

; 4661 :             case 'P':
; 4662 :                SendMessage(hwnd_dialog, WM_COMMAND, ID_LOG_PREV, 0);

  00af4	6a 00		 push	 0
  00af6	6a 09		 push	 9
  00af8	68 11 01 00 00	 push	 273			; 00000111H
  00afd	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  00b02	50		 push	 eax
  00b03	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4663 :                break;

  00b09	eb 66		 jmp	 SHORT $LN4@MainWndPro
$LN51@MainWndPro:

; 4664 :             case 'H':
; 4665 :                SendMessage(hwnd_dialog, WM_COMMAND, ID_HOME, 0);

  00b0b	6a 00		 push	 0
  00b0d	6a 10		 push	 16			; 00000010H
  00b0f	68 11 01 00 00	 push	 273			; 00000111H
  00b14	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  00b19	50		 push	 eax
  00b1a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4666 :                break;

  00b20	eb 4f		 jmp	 SHORT $LN4@MainWndPro
$LN52@MainWndPro:

; 4667 :             case 'L': // 'L' toggles palette lock. If locked, palettes in logfiles are ignored.
; 4668 :                status ^= STAT_PALETTE_LOCKED;

  00b22	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00b27	83 f0 20	 xor	 eax, 32			; 00000020H
  00b2a	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 4669 :                print_palette_status();

  00b2f	e8 00 00 00 00	 call	 _print_palette_status

; 4670 :                break;

  00b34	eb 3b		 jmp	 SHORT $LN4@MainWndPro
$LN53@MainWndPro:

; 4671 :             case 'I': // 'I' toggles palette inversion.
; 4672 :                m->pal_xor ^= 0xFFFFFF;

  00b36	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00b3c	8b 88 fc 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36348]
  00b42	81 f1 ff ff ff
	00		 xor	 ecx, 16777215		; 00ffffffH
  00b48	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _m$[ebp]
  00b4e	89 8a fc 8d 00
	00		 mov	 DWORD PTR [edx+36348], ecx

; 4673 :                SendMessage(hwnd_dialog, WM_COMMAND, MAKELONG(IDC_PALETTE, CBN_SELCHANGE), 0);

  00b54	6a 00		 push	 0
  00b56	68 03 04 01 00	 push	 66563			; 00010403H
  00b5b	68 11 01 00 00	 push	 273			; 00000111H
  00b60	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  00b65	50		 push	 eax
  00b66	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4674 :                print_palette_status();

  00b6c	e8 00 00 00 00	 call	 _print_palette_status
$LN4@MainWndPro:

; 4675 :                break;
; 4676 :          }
; 4677 :          return TRUE;

  00b71	b8 01 00 00 00	 mov	 eax, 1
  00b76	e9 94 02 00 00	 jmp	 $LN1@MainWndPro
$LN54@MainWndPro:

; 4678 : 
; 4679 :       case WM_HELP: // F1 shows help
; 4680 :          SendMessage(hwnd_dialog, WM_COMMAND, ID_HELP_BUTTON, 0);

  00b7b	6a 00		 push	 0
  00b7d	68 1c 04 00 00	 push	 1052			; 0000041cH
  00b82	68 11 01 00 00	 push	 273			; 00000111H
  00b87	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  00b8c	50		 push	 eax
  00b8d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4681 :          return TRUE;

  00b93	b8 01 00 00 00	 mov	 eax, 1
  00b98	e9 72 02 00 00	 jmp	 $LN1@MainWndPro
$LN55@MainWndPro:

; 4682 : 
; 4683 :       case WM_KEYUP: // Go back to zoom mode if space released, if allowed.
; 4684 : 
; 4685 :          if (nav_mode == MODE_PAN)

  00b9d	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _nav_mode, 3
  00ba4	75 43		 jne	 SHORT $LN56@MainWndPro

; 4686 :             if (allow_mode_change)

  00ba6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?allow_mode_change@?1??MainWndProc@@9@9, 0
  00bad	74 30		 je	 SHORT $LN57@MainWndPro

; 4687 :             {
; 4688 :                if (GetCursor() != arrow_cursor) // Change cursor only if space released in client area (kluge)

  00baf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursor@0
  00bb5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _arrow_cursor
  00bbb	74 0c		 je	 SHORT $LN59@MainWndPro

; 4689 :                   SetCursor(mag_zoom_cursor);

  00bbd	a1 00 00 00 00	 mov	 eax, DWORD PTR _mag_zoom_cursor
  00bc2	50		 push	 eax
  00bc3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
$LN59@MainWndPro:

; 4690 :                nav_mode = prev_nav_mode;        // Restore old nav mode and

  00bc9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?prev_nav_mode@?1??MainWndProc@@9@9
  00bce	a3 00 00 00 00	 mov	 DWORD PTR _nav_mode, eax

; 4691 :                do_rtzoom = prev_do_rtzoom;      // zooming status

  00bd3	a1 00 00 00 00	 mov	 eax, DWORD PTR _prev_do_rtzoom
  00bd8	a3 00 00 00 00	 mov	 DWORD PTR _do_rtzoom, eax

; 4692 :             }

  00bdd	eb 0a		 jmp	 SHORT $LN56@MainWndPro
$LN57@MainWndPro:

; 4693 :             else
; 4694 :                zoom_mode_pending = 1;  // Else pending: do as soon as mouse released

  00bdf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?zoom_mode_pending@?1??MainWndProc@@9@9, 1
$LN56@MainWndPro:

; 4695 :          return TRUE;

  00be9	b8 01 00 00 00	 mov	 eax, 1
  00bee	e9 1c 02 00 00	 jmp	 $LN1@MainWndPro
$LN60@MainWndPro:

; 4696 : 
; 4697 :       case WM_SETCURSOR: // We get this message whenever the cursor moves in this window.
; 4698 : 
; 4699 :          // Set cursor (hand or zoom) based on nav mode. Also set keyboard focus to this
; 4700 :          // window for key detection. Eliminates need to click window first to set focus
; 4701 :          SetFocus(hwnd);

  00bf3	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00bf6	50		 push	 eax
  00bf7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 4702 :          if (LOWORD(lParam) == HTCLIENT) // only set zoom/hand cursor in client area

  00bfd	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00c00	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00c05	0f b7 c8	 movzx	 ecx, ax
  00c08	83 f9 01	 cmp	 ecx, 1
  00c0b	75 39		 jne	 SHORT $LN61@MainWndPro

; 4703 :          {
; 4704 :             SetCursor(nav_mode == MODE_PAN ? hopen_cursor : mag_zoom_cursor);

  00c0d	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _nav_mode, 3
  00c14	75 0d		 jne	 SHORT $LN83@MainWndPro
  00c16	a1 00 00 00 00	 mov	 eax, DWORD PTR _hopen_cursor
  00c1b	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv459[ebp], eax
  00c21	eb 0c		 jmp	 SHORT $LN84@MainWndPro
$LN83@MainWndPro:
  00c23	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _mag_zoom_cursor
  00c29	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv459[ebp], ecx
$LN84@MainWndPro:
  00c2f	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv459[ebp]
  00c35	52		 push	 edx
  00c36	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4

; 4705 :             return TRUE;

  00c3c	b8 01 00 00 00	 mov	 eax, 1
  00c41	e9 c9 01 00 00	 jmp	 $LN1@MainWndPro
$LN61@MainWndPro:

; 4706 :          }
; 4707 :          break; // let system set cursor outside client area (resize, arrow, etc)

  00c46	e9 ae 01 00 00	 jmp	 $LN2@MainWndPro
$LN62@MainWndPro:

; 4708 : 
; 4709 :       // This message comes after the user finishes a drag or movement, but, annoyingly, not
; 4710 :       // after a maximize or restore. There's some extra code to handle those in WM_WINDOWPOSCHANGED
; 4711 : 
; 4712 :       case WM_EXITSIZEMOVE:
; 4713 : 
; 4714 :          if (prev_sizing)                                         // if previous resize/move was a resize,

  00c4b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?prev_sizing@?1??MainWndProc@@9@9, 0
  00c52	74 17		 je	 SHORT $LN63@MainWndPro

; 4715 :             if (cfg_settings.options.val & OPT_RECALC_ON_RESIZE)  // recalculate image if enabled

  00c54	a1 a4 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+164
  00c59	83 e0 01	 and	 eax, 1
  00c5c	74 0d		 je	 SHORT $LN63@MainWndPro

; 4716 :             {
; 4717 :                // If we recalculate here, a partial bad-state window appears while
; 4718 :                // the calculation is going on. Recalculate in main loop instead.
; 4719 :                status |= STAT_RECALC_IMMEDIATELY;

  00c5e	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00c63	83 c8 08	 or	 eax, 8
  00c66	a3 00 00 00 00	 mov	 DWORD PTR _status, eax
$LN63@MainWndPro:

; 4720 :             }
; 4721 :          return FALSE;

  00c6b	33 c0		 xor	 eax, eax
  00c6d	e9 9d 01 00 00	 jmp	 $LN1@MainWndPro
$LN65@MainWndPro:

; 4722 : 
; 4723 :       // Called on window sizing or changing position. Pretty wasteful to call create_bitmap
; 4724 :       // (which frees and reallocates all arrays with every pixel of movement) here.
; 4725 :       // Memory fragmentation? Changing this currently causes some issues. Maybe fix later.
; 4726 : 
; 4727 :       // Seems like we always get this at startup before the paint message.
; 4728 : 
; 4729 :       case WM_WINDOWPOSCHANGED:
; 4730 :          GetWindowPlacement(hwnd, &wp);

  00c72	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _wp$[ebp]
  00c78	50		 push	 eax
  00c79	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00c7c	51		 push	 ecx
  00c7d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowPlacement@8

; 4731 :          if (wp.showCmd != SW_SHOWMINIMIZED) // only do this if not minimizing window

  00c83	83 7d 84 02	 cmp	 DWORD PTR _wp$[ebp+8], 2
  00c87	0f 84 55 01 00
	00		 je	 $LN66@MainWndPro

; 4732 :          {
; 4733 :             // Move dialog box along with main window
; 4734 :             update_dialog(status & STAT_DIALOG_HIDDEN, 1); // 1 = move

  00c8d	6a 01		 push	 1
  00c8f	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00c94	83 e0 10	 and	 eax, 16			; 00000010H
  00c97	50		 push	 eax
  00c98	e8 00 00 00 00	 call	 _update_dialog
  00c9d	83 c4 08	 add	 esp, 8

; 4735 : 
; 4736 :             GetClientRect(hwnd, &rc);        // calculate new mandelbrot image size

  00ca0	8d 45 f0	 lea	 eax, DWORD PTR _rc$[ebp]
  00ca3	50		 push	 eax
  00ca4	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00ca7	51		 push	 ecx
  00ca8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 4737 :             m->xsize = rc.right - rc.left;

  00cae	8b 45 f8	 mov	 eax, DWORD PTR _rc$[ebp+8]
  00cb1	2b 45 f0	 sub	 eax, DWORD PTR _rc$[ebp]
  00cb4	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00cba	89 81 88 8d 00
	00		 mov	 DWORD PTR [ecx+36232], eax

; 4738 :             m->ysize = rc.bottom - rc.top;

  00cc0	8b 45 fc	 mov	 eax, DWORD PTR _rc$[ebp+12]
  00cc3	2b 45 f4	 sub	 eax, DWORD PTR _rc$[ebp+4]
  00cc6	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00ccc	89 81 8c 8d 00
	00		 mov	 DWORD PTR [ecx+36236], eax

; 4739 : 
; 4740 :             if (m->xsize < MIN_SIZE)        // clip min size

  00cd2	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00cd8	83 b8 88 8d 00
	00 04		 cmp	 DWORD PTR [eax+36232], 4
  00cdf	7d 10		 jge	 SHORT $LN67@MainWndPro

; 4741 :                m->xsize = MIN_SIZE;

  00ce1	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00ce7	c7 80 88 8d 00
	00 04 00 00 00	 mov	 DWORD PTR [eax+36232], 4
$LN67@MainWndPro:

; 4742 :             if (m->ysize < MIN_SIZE)

  00cf1	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00cf7	83 b8 8c 8d 00
	00 04		 cmp	 DWORD PTR [eax+36236], 4
  00cfe	7d 10		 jge	 SHORT $LN68@MainWndPro

; 4743 :                m->ysize = MIN_SIZE;

  00d00	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00d06	c7 80 8c 8d 00
	00 04 00 00 00	 mov	 DWORD PTR [eax+36236], 4
$LN68@MainWndPro:

; 4744 : 
; 4745 :             // Create arrays and bitmaps used in calculations (will deallocate/resize as needed-
; 4746 :             // returns > 0 if resized). Doesn't do anything if size didn't change.
; 4747 :             // Set prev_sizing so WM_EXITSIZEMOVE can know whether previous op was a resize.
; 4748 : 
; 4749 :             if (prev_sizing = create_bitmap(m->xsize, m->ysize))   // rename this- now does a lot more than create a bitmap

  00d10	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00d16	8b 88 8c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36236]
  00d1c	51		 push	 ecx
  00d1d	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _m$[ebp]
  00d23	8b 82 88 8d 00
	00		 mov	 eax, DWORD PTR [edx+36232]
  00d29	50		 push	 eax
  00d2a	e8 00 00 00 00	 call	 _create_bitmap
  00d2f	83 c4 08	 add	 esp, 8
  00d32	a3 00 00 00 00	 mov	 DWORD PTR ?prev_sizing@?1??MainWndProc@@9@9, eax
  00d37	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?prev_sizing@?1??MainWndProc@@9@9, 0
  00d3e	74 59		 je	 SHORT $LN69@MainWndPro

; 4750 :             {
; 4751 :                SetWindowText(hwnd_info, get_image_info(0));          // update size info if resized

  00d40	6a 00		 push	 0
  00d42	e8 00 00 00 00	 call	 _get_image_info
  00d47	83 c4 04	 add	 esp, 4
  00d4a	50		 push	 eax
  00d4b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_info
  00d50	50		 push	 eax
  00d51	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 4752 :                SetDlgItemInt(hwnd_dialog, IDC_SAVE_XSIZE, m->xsize, FALSE); // update sizes for image save

  00d57	6a 00		 push	 0
  00d59	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00d5f	8b 88 88 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36232]
  00d65	51		 push	 ecx
  00d66	68 2c 04 00 00	 push	 1068			; 0000042cH
  00d6b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hwnd_dialog
  00d71	52		 push	 edx
  00d72	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemInt@16

; 4753 :                SetDlgItemInt(hwnd_dialog, IDC_SAVE_YSIZE, m->ysize, FALSE);

  00d78	6a 00		 push	 0
  00d7a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00d80	8b 88 8c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36236]
  00d86	51		 push	 ecx
  00d87	68 2d 04 00 00	 push	 1069			; 0000042dH
  00d8c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hwnd_dialog
  00d92	52		 push	 edx
  00d93	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemInt@16
$LN69@MainWndPro:

; 4754 :             }
; 4755 : 
; 4756 :             // Send a WM_EXITSIZEMOVE message if window was maximized/restored
; 4757 :             if (wp.showCmd != prev_max_restore)

  00d99	8b 45 84	 mov	 eax, DWORD PTR _wp$[ebp+8]
  00d9c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?prev_max_restore@?1??MainWndProc@@9@9
  00da2	74 1b		 je	 SHORT $LN70@MainWndPro

; 4758 :             {
; 4759 :                SendMessage(hwnd, WM_EXITSIZEMOVE, 0, 0);

  00da4	6a 00		 push	 0
  00da6	6a 00		 push	 0
  00da8	68 32 02 00 00	 push	 562			; 00000232H
  00dad	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00db0	50		 push	 eax
  00db1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4760 :                prev_max_restore = wp.showCmd;

  00db7	8b 45 84	 mov	 eax, DWORD PTR _wp$[ebp+8]
  00dba	a3 00 00 00 00	 mov	 DWORD PTR ?prev_max_restore@?1??MainWndProc@@9@9, eax
$LN70@MainWndPro:

; 4761 :             }
; 4762 :             // Save main window rect for fullscreen mode if not maximized and not already in fullscreen
; 4763 :             if (wp.showCmd != SW_SHOWMAXIMIZED && !(status & STAT_FULLSCREEN))

  00dbf	83 7d 84 03	 cmp	 DWORD PTR _wp$[ebp+8], 3
  00dc3	74 19		 je	 SHORT $LN71@MainWndPro
  00dc5	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00dca	83 e0 04	 and	 eax, 4
  00dcd	75 0f		 jne	 SHORT $LN71@MainWndPro

; 4764 :                GetWindowRect(hwnd, &main_rect);

  00dcf	68 00 00 00 00	 push	 OFFSET _main_rect
  00dd4	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00dd7	50		 push	 eax
  00dd8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
$LN71@MainWndPro:

; 4765 :             return FALSE;

  00dde	33 c0		 xor	 eax, eax
  00de0	eb 2d		 jmp	 SHORT $LN1@MainWndPro
$LN66@MainWndPro:

; 4766 :          }
; 4767 :          return TRUE;

  00de2	b8 01 00 00 00	 mov	 eax, 1
  00de7	eb 26		 jmp	 SHORT $LN1@MainWndPro
$LN72@MainWndPro:

; 4768 : 
; 4769 :       case WM_COMMAND:
; 4770 :          return FALSE;

  00de9	33 c0		 xor	 eax, eax
  00deb	eb 22		 jmp	 SHORT $LN1@MainWndPro
$LN73@MainWndPro:

; 4771 : 
; 4772 :       case WM_DESTROY:  // The window is being destroyed, close the application
; 4773 :          PostQuitMessage(0);

  00ded	6a 00		 push	 0
  00def	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 4774 :          return FALSE;

  00df5	33 c0		 xor	 eax, eax
  00df7	eb 16		 jmp	 SHORT $LN1@MainWndPro
$LN2@MainWndPro:

; 4775 :    }
; 4776 :    // If we don't handle a message completely we hand it to the system-provided default window function.
; 4777 :    return DefWindowProc(hwnd, nMsg, wParam, lParam);

  00df9	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00dfc	50		 push	 eax
  00dfd	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00e00	51		 push	 ecx
  00e01	8b 55 0c	 mov	 edx, DWORD PTR _nMsg$[ebp]
  00e04	52		 push	 edx
  00e05	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00e08	50		 push	 eax
  00e09	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
$LN1@MainWndPro:

; 4778 : }

  00e0f	5f		 pop	 edi
  00e10	5e		 pop	 esi
  00e11	5b		 pop	 ebx
  00e12	8b e5		 mov	 esp, ebp
  00e14	5d		 pop	 ebp
  00e15	c2 10 00	 ret	 16			; 00000010H
$LN90@MainWndPro:
  00e18	00 00 00 00	 DD	 $LN6@MainWndPro
  00e1c	00 00 00 00	 DD	 $LN73@MainWndPro
  00e20	00 00 00 00	 DD	 $LN7@MainWndPro
  00e24	00 00 00 00	 DD	 $LN60@MainWndPro
  00e28	00 00 00 00	 DD	 $LN2@MainWndPro
$LN87@MainWndPro:
  00e2c	00		 DB	 0
  00e2d	01		 DB	 1
  00e2e	04		 DB	 4
  00e2f	04		 DB	 4
  00e30	04		 DB	 4
  00e31	04		 DB	 4
  00e32	04		 DB	 4
  00e33	04		 DB	 4
  00e34	04		 DB	 4
  00e35	04		 DB	 4
  00e36	04		 DB	 4
  00e37	04		 DB	 4
  00e38	04		 DB	 4
  00e39	04		 DB	 4
  00e3a	02		 DB	 2
  00e3b	04		 DB	 4
  00e3c	04		 DB	 4
  00e3d	04		 DB	 4
  00e3e	04		 DB	 4
  00e3f	04		 DB	 4
  00e40	04		 DB	 4
  00e41	04		 DB	 4
  00e42	04		 DB	 4
  00e43	04		 DB	 4
  00e44	04		 DB	 4
  00e45	04		 DB	 4
  00e46	04		 DB	 4
  00e47	04		 DB	 4
  00e48	04		 DB	 4
  00e49	04		 DB	 4
  00e4a	04		 DB	 4
  00e4b	03		 DB	 3
$LN91@MainWndPro:
  00e4c	00 00 00 00	 DD	 $LN21@MainWndPro
  00e50	00 00 00 00	 DD	 $LN10@MainWndPro
  00e54	00 00 00 00	 DD	 $LN14@MainWndPro
  00e58	00 00 00 00	 DD	 $LN28@MainWndPro
  00e5c	00 00 00 00	 DD	 $LN32@MainWndPro
  00e60	00 00 00 00	 DD	 $LN35@MainWndPro
  00e64	00 00 00 00	 DD	 $LN62@MainWndPro
  00e68	00 00 00 00	 DD	 $LN2@MainWndPro
$LN88@MainWndPro:
  00e6c	00		 DB	 0
  00e6d	01		 DB	 1
  00e6e	02		 DB	 2
  00e6f	07		 DB	 7
  00e70	03		 DB	 3
  00e71	04		 DB	 4
  00e72	07		 DB	 7
  00e73	07		 DB	 7
  00e74	07		 DB	 7
  00e75	07		 DB	 7
  00e76	05		 DB	 5
  00e77	07		 DB	 7
  00e78	07		 DB	 7
  00e79	07		 DB	 7
  00e7a	07		 DB	 7
  00e7b	07		 DB	 7
  00e7c	07		 DB	 7
  00e7d	07		 DB	 7
  00e7e	07		 DB	 7
  00e7f	07		 DB	 7
  00e80	07		 DB	 7
  00e81	07		 DB	 7
  00e82	07		 DB	 7
  00e83	07		 DB	 7
  00e84	07		 DB	 7
  00e85	07		 DB	 7
  00e86	07		 DB	 7
  00e87	07		 DB	 7
  00e88	07		 DB	 7
  00e89	07		 DB	 7
  00e8a	07		 DB	 7
  00e8b	07		 DB	 7
  00e8c	07		 DB	 7
  00e8d	07		 DB	 7
  00e8e	07		 DB	 7
  00e8f	07		 DB	 7
  00e90	07		 DB	 7
  00e91	07		 DB	 7
  00e92	07		 DB	 7
  00e93	07		 DB	 7
  00e94	07		 DB	 7
  00e95	07		 DB	 7
  00e96	07		 DB	 7
  00e97	07		 DB	 7
  00e98	07		 DB	 7
  00e99	07		 DB	 7
  00e9a	07		 DB	 7
  00e9b	07		 DB	 7
  00e9c	07		 DB	 7
  00e9d	07		 DB	 7
  00e9e	06		 DB	 6
  00e9f	90		 npad	 1
$LN92@MainWndPro:
  00ea0	00 00 00 00	 DD	 $LN46@MainWndPro
  00ea4	00 00 00 00	 DD	 $LN45@MainWndPro
  00ea8	00 00 00 00	 DD	 $LN48@MainWndPro
  00eac	00 00 00 00	 DD	 $LN51@MainWndPro
  00eb0	00 00 00 00	 DD	 $LN53@MainWndPro
  00eb4	00 00 00 00	 DD	 $LN52@MainWndPro
  00eb8	00 00 00 00	 DD	 $LN49@MainWndPro
  00ebc	00 00 00 00	 DD	 $LN50@MainWndPro
  00ec0	00 00 00 00	 DD	 $LN4@MainWndPro
$LN89@MainWndPro:
  00ec4	00		 DB	 0
  00ec5	08		 DB	 8
  00ec6	08		 DB	 8
  00ec7	08		 DB	 8
  00ec8	08		 DB	 8
  00ec9	08		 DB	 8
  00eca	08		 DB	 8
  00ecb	08		 DB	 8
  00ecc	08		 DB	 8
  00ecd	08		 DB	 8
  00ece	08		 DB	 8
  00ecf	08		 DB	 8
  00ed0	08		 DB	 8
  00ed1	08		 DB	 8
  00ed2	08		 DB	 8
  00ed3	08		 DB	 8
  00ed4	08		 DB	 8
  00ed5	08		 DB	 8
  00ed6	08		 DB	 8
  00ed7	08		 DB	 8
  00ed8	08		 DB	 8
  00ed9	08		 DB	 8
  00eda	08		 DB	 8
  00edb	08		 DB	 8
  00edc	08		 DB	 8
  00edd	08		 DB	 8
  00ede	08		 DB	 8
  00edf	08		 DB	 8
  00ee0	08		 DB	 8
  00ee1	08		 DB	 8
  00ee2	08		 DB	 8
  00ee3	08		 DB	 8
  00ee4	08		 DB	 8
  00ee5	08		 DB	 8
  00ee6	08		 DB	 8
  00ee7	08		 DB	 8
  00ee8	08		 DB	 8
  00ee9	08		 DB	 8
  00eea	08		 DB	 8
  00eeb	08		 DB	 8
  00eec	01		 DB	 1
  00eed	08		 DB	 8
  00eee	08		 DB	 8
  00eef	02		 DB	 2
  00ef0	08		 DB	 8
  00ef1	03		 DB	 3
  00ef2	04		 DB	 4
  00ef3	08		 DB	 8
  00ef4	08		 DB	 8
  00ef5	05		 DB	 5
  00ef6	08		 DB	 8
  00ef7	06		 DB	 6
  00ef8	08		 DB	 8
  00ef9	07		 DB	 7
_MainWndProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _confine_mouse_cursor
_TEXT	SEGMENT
_ptClientLR$ = -32					; size = 8
_ptClientUL$ = -24					; size = 8
_rc$ = -16						; size = 16
_confine_mouse_cursor PROC				; COMDAT

; 4384 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4385 :    RECT rc;             // working rectangle
; 4386 :    POINT ptClientUL;    // client upper left corner
; 4387 :    POINT ptClientLR;    // client lower right corner
; 4388 : 
; 4389 :    GetClientRect(hwnd_main, &rc);  // Retrieve the screen coordinates of the client area,

  00009	8d 45 f0	 lea	 eax, DWORD PTR _rc$[ebp]
  0000c	50		 push	 eax
  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_main
  00013	51		 push	 ecx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 4390 :    ptClientUL.x = rc.left;         // and convert them into client coordinates.

  0001a	8b 45 f0	 mov	 eax, DWORD PTR _rc$[ebp]
  0001d	89 45 e8	 mov	 DWORD PTR _ptClientUL$[ebp], eax

; 4391 :    ptClientUL.y = rc.top;

  00020	8b 45 f4	 mov	 eax, DWORD PTR _rc$[ebp+4]
  00023	89 45 ec	 mov	 DWORD PTR _ptClientUL$[ebp+4], eax

; 4392 :    ptClientLR.x = rc.right + 1;             // Add one to the right and bottom sides, because the

  00026	8b 45 f8	 mov	 eax, DWORD PTR _rc$[ebp+8]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 e0	 mov	 DWORD PTR _ptClientLR$[ebp], eax

; 4393 :    ptClientLR.y = rc.bottom + 1;            // coordinates retrieved by GetClientRect do not

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _rc$[ebp+12]
  00032	83 c0 01	 add	 eax, 1
  00035	89 45 e4	 mov	 DWORD PTR _ptClientLR$[ebp+4], eax

; 4394 :    ClientToScreen(hwnd_main, &ptClientUL);  // include the far left and lowermost pixels.

  00038	8d 45 e8	 lea	 eax, DWORD PTR _ptClientUL$[ebp]
  0003b	50		 push	 eax
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_main
  00042	51		 push	 ecx
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClientToScreen@8

; 4395 :    ClientToScreen(hwnd_main, &ptClientLR);

  00049	8d 45 e0	 lea	 eax, DWORD PTR _ptClientLR$[ebp]
  0004c	50		 push	 eax
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_main
  00053	51		 push	 ecx
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClientToScreen@8

; 4396 : 
; 4397 :    SetRect(&rc, ptClientUL.x, ptClientUL.y, // Copy the client coordinates of the client area

  0005a	8b 45 e4	 mov	 eax, DWORD PTR _ptClientLR$[ebp+4]
  0005d	50		 push	 eax
  0005e	8b 4d e0	 mov	 ecx, DWORD PTR _ptClientLR$[ebp]
  00061	51		 push	 ecx
  00062	8b 55 ec	 mov	 edx, DWORD PTR _ptClientUL$[ebp+4]
  00065	52		 push	 edx
  00066	8b 45 e8	 mov	 eax, DWORD PTR _ptClientUL$[ebp]
  00069	50		 push	 eax
  0006a	8d 4d f0	 lea	 ecx, DWORD PTR _rc$[ebp]
  0006d	51		 push	 ecx
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 4398 :            ptClientLR.x, ptClientLR.y);     // to the rcClient structure.
; 4399 : 
; 4400 :    SetCapture(hwnd_main);  // capture mouse input

  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  00079	50		 push	 eax
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCapture@4

; 4401 :    ClipCursor(&rc);        // confine the mouse cursor to the client area

  00080	8d 45 f0	 lea	 eax, DWORD PTR _rc$[ebp]
  00083	50		 push	 eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClipCursor@4

; 4402 : }

  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
_confine_mouse_cursor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _striped_blit
_TEXT	SEGMENT
_y_done$ = -20						; size = 4
_this_y$ = -16						; size = 4
_ysize$ = -12						; size = 4
_dest_yoffs$ = -8					; size = 4
_src_yoffs$ = -4					; size = 4
_ql$ = 8						; size = 4
_qr$ = 12						; size = 4
_hdc$ = 16						; size = 4
_hscreen_dc$ = 20					; size = 4
_striped_blit PROC					; COMDAT

; 4320 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4321 :    int src_yoffs, dest_yoffs, ysize, this_y, y_done;
; 4322 : 
; 4323 :    // Thickness of the stripes: the thinner the better, but thinner
; 4324 :    // stripes cause more overhead. 8 gives no measureable overhead on
; 4325 :    // the Athlon 4000+ system, but significant overhead on the Pentium
; 4326 :    // D 820 system. Probably hugely dependent on the video driver.
; 4327 : 
; 4328 :    // No artifacts visible with either 8 or 16 (except those that are present
; 4329 :    // with a full bitmap also- tearing, CPU cycle stealing by other applications,
; 4330 :    // and frame rate aliasing with the screen refresh rate).
; 4331 : 
; 4332 :    //#define STRIPE_THICKNESS 16 // this now comes from global config setting
; 4333 : 
; 4334 :    // Return if no data in these quadrants
; 4335 :    if (!(ql->status & QSTAT_DO_BLIT) && !(qr->status & QSTAT_DO_BLIT))

  00009	8b 45 08	 mov	 eax, DWORD PTR _ql$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	83 e1 01	 and	 ecx, 1
  00011	75 0f		 jne	 SHORT $LN5@striped_bl
  00013	8b 45 0c	 mov	 eax, DWORD PTR _qr$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	83 e1 01	 and	 ecx, 1
  0001b	75 05		 jne	 SHORT $LN5@striped_bl

; 4336 :       return;

  0001d	e9 2a 01 00 00	 jmp	 $LN1@striped_bl
$LN5@striped_bl:

; 4337 : 
; 4338 :    // The src_yoffs, dest_yoffs, and blit_ysize fields of the left and right
; 4339 :    // quadrants will always be the same.
; 4340 : 
; 4341 :    // Get from left quad if it has a blit rectangle, else get from right
; 4342 :    if (ql->status & QSTAT_DO_BLIT)

  00022	8b 45 08	 mov	 eax, DWORD PTR _ql$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	83 e1 01	 and	 ecx, 1
  0002a	74 1d		 je	 SHORT $LN6@striped_bl

; 4343 :    {
; 4344 :       src_yoffs = ql->src_yoffs;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _ql$[ebp]
  0002f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00032	89 4d fc	 mov	 DWORD PTR _src_yoffs$[ebp], ecx

; 4345 :       dest_yoffs = ql->dest_yoffs;

  00035	8b 45 08	 mov	 eax, DWORD PTR _ql$[ebp]
  00038	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0003b	89 4d f8	 mov	 DWORD PTR _dest_yoffs$[ebp], ecx

; 4346 :       ysize = ql->blit_ysize;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _ql$[ebp]
  00041	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00044	89 4d f4	 mov	 DWORD PTR _ysize$[ebp], ecx

; 4347 :    }

  00047	eb 1b		 jmp	 SHORT $LN7@striped_bl
$LN6@striped_bl:

; 4348 :    else
; 4349 :    {
; 4350 :       src_yoffs = qr->src_yoffs;

  00049	8b 45 0c	 mov	 eax, DWORD PTR _qr$[ebp]
  0004c	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0004f	89 4d fc	 mov	 DWORD PTR _src_yoffs$[ebp], ecx

; 4351 :       dest_yoffs = qr->dest_yoffs;

  00052	8b 45 0c	 mov	 eax, DWORD PTR _qr$[ebp]
  00055	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00058	89 4d f8	 mov	 DWORD PTR _dest_yoffs$[ebp], ecx

; 4352 :       ysize = qr->blit_ysize;

  0005b	8b 45 0c	 mov	 eax, DWORD PTR _qr$[ebp]
  0005e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00061	89 4d f4	 mov	 DWORD PTR _ysize$[ebp], ecx
$LN7@striped_bl:

; 4353 :    }
; 4354 : 
; 4355 :    this_y = cfg_settings.blit_stripe_thickness.val; // STRIPE_THICKNESS;

  00064	a1 cc 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+204
  00069	89 45 f0	 mov	 DWORD PTR _this_y$[ebp], eax

; 4356 :    y_done = 0;

  0006c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _y_done$[ebp], 0
$LN4@striped_bl:

; 4357 :    do
; 4358 :    {
; 4359 :       if (y_done + this_y > ysize)

  00073	8b 45 ec	 mov	 eax, DWORD PTR _y_done$[ebp]
  00076	03 45 f0	 add	 eax, DWORD PTR _this_y$[ebp]
  00079	3b 45 f4	 cmp	 eax, DWORD PTR _ysize$[ebp]
  0007c	7e 09		 jle	 SHORT $LN8@striped_bl

; 4360 :          this_y = ysize - y_done;

  0007e	8b 45 f4	 mov	 eax, DWORD PTR _ysize$[ebp]
  00081	2b 45 ec	 sub	 eax, DWORD PTR _y_done$[ebp]
  00084	89 45 f0	 mov	 DWORD PTR _this_y$[ebp], eax
$LN8@striped_bl:

; 4361 : 
; 4362 :       if (ql->status & QSTAT_DO_BLIT) // Blit stripe left half from left quadrant

  00087	8b 45 08	 mov	 eax, DWORD PTR _ql$[ebp]
  0008a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008c	83 e1 01	 and	 ecx, 1
  0008f	74 45		 je	 SHORT $LN9@striped_bl

; 4363 :       {
; 4364 :          SelectObject(hscreen_dc, ql->handle);

  00091	8b 45 08	 mov	 eax, DWORD PTR _ql$[ebp]
  00094	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00097	51		 push	 ecx
  00098	8b 55 14	 mov	 edx, DWORD PTR _hscreen_dc$[ebp]
  0009b	52		 push	 edx
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 4365 :          BitBlt(hdc, ql->dest_xoffs, dest_yoffs, ql->blit_xsize, this_y,

  000a2	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  000a7	8b 45 fc	 mov	 eax, DWORD PTR _src_yoffs$[ebp]
  000aa	50		 push	 eax
  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _ql$[ebp]
  000ae	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000b1	52		 push	 edx
  000b2	8b 45 14	 mov	 eax, DWORD PTR _hscreen_dc$[ebp]
  000b5	50		 push	 eax
  000b6	8b 4d f0	 mov	 ecx, DWORD PTR _this_y$[ebp]
  000b9	51		 push	 ecx
  000ba	8b 55 08	 mov	 edx, DWORD PTR _ql$[ebp]
  000bd	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000c0	50		 push	 eax
  000c1	8b 4d f8	 mov	 ecx, DWORD PTR _dest_yoffs$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 55 08	 mov	 edx, DWORD PTR _ql$[ebp]
  000c8	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000cb	50		 push	 eax
  000cc	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  000cf	51		 push	 ecx
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
$LN9@striped_bl:

; 4366 :                 hscreen_dc, ql->src_xoffs, src_yoffs, SRCCOPY);
; 4367 :       }
; 4368 :       if (qr->status & QSTAT_DO_BLIT)  // Blit stripe right half from right quadrant

  000d6	8b 45 0c	 mov	 eax, DWORD PTR _qr$[ebp]
  000d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000db	83 e1 01	 and	 ecx, 1
  000de	74 45		 je	 SHORT $LN10@striped_bl

; 4369 :       {
; 4370 :          SelectObject(hscreen_dc, qr->handle);

  000e0	8b 45 0c	 mov	 eax, DWORD PTR _qr$[ebp]
  000e3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e6	51		 push	 ecx
  000e7	8b 55 14	 mov	 edx, DWORD PTR _hscreen_dc$[ebp]
  000ea	52		 push	 edx
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 4371 :          BitBlt(hdc, qr->dest_xoffs, dest_yoffs, qr->blit_xsize, this_y,

  000f1	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  000f6	8b 45 fc	 mov	 eax, DWORD PTR _src_yoffs$[ebp]
  000f9	50		 push	 eax
  000fa	8b 4d 0c	 mov	 ecx, DWORD PTR _qr$[ebp]
  000fd	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00100	52		 push	 edx
  00101	8b 45 14	 mov	 eax, DWORD PTR _hscreen_dc$[ebp]
  00104	50		 push	 eax
  00105	8b 4d f0	 mov	 ecx, DWORD PTR _this_y$[ebp]
  00108	51		 push	 ecx
  00109	8b 55 0c	 mov	 edx, DWORD PTR _qr$[ebp]
  0010c	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0010f	50		 push	 eax
  00110	8b 4d f8	 mov	 ecx, DWORD PTR _dest_yoffs$[ebp]
  00113	51		 push	 ecx
  00114	8b 55 0c	 mov	 edx, DWORD PTR _qr$[ebp]
  00117	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0011a	50		 push	 eax
  0011b	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0011e	51		 push	 ecx
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
$LN10@striped_bl:

; 4372 :                 hscreen_dc, qr->src_xoffs, src_yoffs, SRCCOPY);
; 4373 :       }
; 4374 : 
; 4375 :       src_yoffs += this_y;

  00125	8b 45 fc	 mov	 eax, DWORD PTR _src_yoffs$[ebp]
  00128	03 45 f0	 add	 eax, DWORD PTR _this_y$[ebp]
  0012b	89 45 fc	 mov	 DWORD PTR _src_yoffs$[ebp], eax

; 4376 :       dest_yoffs += this_y;

  0012e	8b 45 f8	 mov	 eax, DWORD PTR _dest_yoffs$[ebp]
  00131	03 45 f0	 add	 eax, DWORD PTR _this_y$[ebp]
  00134	89 45 f8	 mov	 DWORD PTR _dest_yoffs$[ebp], eax

; 4377 :       y_done += this_y;

  00137	8b 45 ec	 mov	 eax, DWORD PTR _y_done$[ebp]
  0013a	03 45 f0	 add	 eax, DWORD PTR _this_y$[ebp]
  0013d	89 45 ec	 mov	 DWORD PTR _y_done$[ebp], eax

; 4378 :    }
; 4379 :    while (y_done != ysize);

  00140	8b 45 ec	 mov	 eax, DWORD PTR _y_done$[ebp]
  00143	3b 45 f4	 cmp	 eax, DWORD PTR _ysize$[ebp]
  00146	0f 85 27 ff ff
	ff		 jne	 $LN4@striped_bl
$LN1@striped_bl:

; 4380 : }

  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c3		 ret	 0
_striped_blit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _man_dialog_proc@16
_TEXT	SEGMENT
tv758 = -172						; size = 4
tv750 = -172						; size = 4
tv537 = -172						; size = 4
tv523 = -172						; size = 4
tv333 = -172						; size = 4
tv295 = -172						; size = 4
tv64 = -172						; size = 4
_aspect$1 = -104					; size = 8
_m$ = -96						; size = 4
_e$ = -92						; size = 4
_rc_dialog$ = -88					; size = 16
_rc_status$ = -72					; size = 16
_rc_tframe$ = -56					; size = 16
_tab_spacing$ = -40					; size = 4
_max_tries$ = -36					; size = 4
_done$ = -32						; size = 4
_last_ypixel$ = -28					; size = 4
_frame_h$ = -24						; size = 4
_frame_w$ = -20						; size = 4
_text_h$ = -16						; size = 4
_text_w$ = -12						; size = 4
_dialog_h$ = -8						; size = 4
_dialog_w$ = -4						; size = 4
_hwnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_man_dialog_proc@16 PROC				; COMDAT

; 3918 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3919 :    static int adj_iters_prev = 0, ignore_next_change = 0;
; 3920 :    static int new_file_entered = 0, new_file_selected = 0;
; 3921 :    int dialog_w, dialog_h, text_w, text_h, frame_w, frame_h, last_ypixel, done, max_tries;
; 3922 :    int tab_spacing = 26; // dialog box units

  0000c	c7 45 d8 1a 00
	00 00		 mov	 DWORD PTR _tab_spacing$[ebp], 26 ; 0000001aH

; 3923 :    RECT rc_tframe, rc_status, rc_dialog;
; 3924 :    log_entry *e;
; 3925 :    man_calc_struct *m;
; 3926 : 
; 3927 :    m = &main_man_calc_struct;

  00013	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3928 : 
; 3929 :    // Original dialog box coords and sizes, for adjustment
; 3930 :    #define ORIG_YBORDER         34
; 3931 :    #define ORIG_DIALOG_HEIGHT   (700 + ORIG_YBORDER)
; 3932 :    #define ORIG_DIALOG_WIDTH    173
; 3933 :    #define ORIG_STATUS_X        8
; 3934 :    #define YBORDER_ADJUSTMENT   (y_border - ORIG_YBORDER)
; 3935 :    #define ORIG_LPIX            96  // original logical pixels per inch
; 3936 :    #define TFRAME_MIN_HEIGHT    1   // thumbnail frame is now an invisible dummy item used for sizing
; 3937 : 
; 3938 :    switch (uMsg)

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _uMsg$[ebp]
  0001d	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00023	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  00029	81 e9 10 01 00
	00		 sub	 ecx, 272		; 00000110H
  0002f	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv64[ebp], ecx
  00035	83 bd 54 ff ff
	ff 05		 cmp	 DWORD PTR tv64[ebp], 5
  0003c	0f 87 7b 0c 00
	00		 ja	 $LN2@man_dialog
  00042	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv64[ebp]
  00048	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN79@man_dialog[edx*4]
$LN11@man_dialog:

; 3939 :    {
; 3940 :       case WM_INITDIALOG:
; 3941 : 
; 3942 :          // Initialize all dialog box fields
; 3943 :          SetDlgItemInt(hwnd, IDC_ITERS, m->max_iters, FALSE);

  0004f	6a 00		 push	 0
  00051	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00054	8b 88 c0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36288]
  0005a	51		 push	 ecx
  0005b	68 fb 03 00 00	 push	 1019			; 000003fbH
  00060	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00063	52		 push	 edx
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemInt@16

; 3944 :          SendDlgItemMessage(hwnd, IDC_PAN_RATE, TBM_SETRANGE, TRUE, MAKELONG(0, MAX_PAN_RATE));

  0006a	68 00 00 14 00	 push	 1310720			; 00140000H
  0006f	6a 01		 push	 1
  00071	68 06 04 00 00	 push	 1030			; 00000406H
  00076	68 17 04 00 00	 push	 1047			; 00000417H
  0007b	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0007e	50		 push	 eax
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 3945 :          SendDlgItemMessage(hwnd, IDC_ZOOM_RATE, TBM_SETRANGE, TRUE, MAKELONG(0, MAX_ZOOM_RATE));

  00085	68 00 00 14 00	 push	 1310720			; 00140000H
  0008a	6a 01		 push	 1
  0008c	68 06 04 00 00	 push	 1030			; 00000406H
  00091	68 18 04 00 00	 push	 1048			; 00000418H
  00096	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00099	50		 push	 eax
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 3946 :          init_combo_box(hwnd, IDC_PRECISION, precision_strs, NUM_ELEM(precision_strs), m->precision);

  000a0	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  000a3	8b 88 d0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36304]
  000a9	51		 push	 ecx
  000aa	6a 04		 push	 4
  000ac	68 00 00 00 00	 push	 OFFSET _precision_strs
  000b1	68 f2 03 00 00	 push	 1010			; 000003f2H
  000b6	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  000b9	52		 push	 edx
  000ba	e8 00 00 00 00	 call	 _init_combo_box
  000bf	83 c4 14	 add	 esp, 20			; 00000014H

; 3947 :          init_combo_box(hwnd, IDC_PALETTE, palette_strs, NUM_ELEM(palette_strs), m->palette);

  000c2	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  000c5	8b 88 f4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36340]
  000cb	51		 push	 ecx
  000cc	6a 0e		 push	 14			; 0000000eH
  000ce	68 00 00 00 00	 push	 OFFSET _palette_strs
  000d3	68 03 04 00 00	 push	 1027			; 00000403H
  000d8	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 _init_combo_box
  000e1	83 c4 14	 add	 esp, 20			; 00000014H

; 3948 :          init_combo_box(hwnd, IDC_RENDERING, rendering_strs, NUM_ELEM(rendering_strs), m->rendering_alg);

  000e4	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  000e7	8b 88 04 8e 00
	00		 mov	 ecx, DWORD PTR [eax+36356]
  000ed	51		 push	 ecx
  000ee	6a 02		 push	 2
  000f0	68 00 00 00 00	 push	 OFFSET _rendering_strs
  000f5	68 04 04 00 00	 push	 1028			; 00000404H
  000fa	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  000fd	52		 push	 edx
  000fe	e8 00 00 00 00	 call	 _init_combo_box
  00103	83 c4 14	 add	 esp, 20			; 00000014H

; 3949 :          init_combo_box(hwnd, IDC_ALGORITHM, alg_strs, NUM_ELEM(alg_strs), m->alg);

  00106	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00109	8b 88 c8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36296]
  0010f	51		 push	 ecx
  00110	6a 06		 push	 6
  00112	68 00 00 00 00	 push	 OFFSET _alg_strs
  00117	68 05 04 00 00	 push	 1029			; 00000405H
  0011c	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 _init_combo_box
  00125	83 c4 14	 add	 esp, 20			; 00000014H

; 3950 :          init_combo_box(hwnd, IDC_THREADS, num_threads_strs, MAX_THREADS_IND + 1, num_threads_ind);

  00128	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_threads_ind
  0012d	50		 push	 eax
  0012e	6a 06		 push	 6
  00130	68 00 00 00 00	 push	 OFFSET _num_threads_strs
  00135	68 06 04 00 00	 push	 1030			; 00000406H
  0013a	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0013d	51		 push	 ecx
  0013e	e8 00 00 00 00	 call	 _init_combo_box
  00143	83 c4 14	 add	 esp, 20			; 00000014H

; 3951 :          init_combo_box(hwnd, IDC_LOGFILE, file_strs, NUM_ELEM(file_strs), 0);

  00146	6a 00		 push	 0
  00148	6a 02		 push	 2
  0014a	68 00 00 00 00	 push	 OFFSET _file_strs
  0014f	68 07 04 00 00	 push	 1031			; 00000407H
  00154	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 _init_combo_box
  0015d	83 c4 14	 add	 esp, 20			; 00000014H

; 3952 : 
; 3953 :          // default save filename- later have this scan for next available
; 3954 :          SetWindowText(GetDlgItem(hwnd, IDC_SAVEFILE), savefile);

  00160	68 00 00 00 00	 push	 OFFSET _savefile
  00165	68 2e 04 00 00	 push	 1070			; 0000042eH
  0016a	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0016d	50		 push	 eax
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00174	50		 push	 eax
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 3955 : 
; 3956 :          // Set tab stops for the INFO window
; 3957 :          SendDlgItemMessage(hwnd, IDC_INFO, EM_SETTABSTOPS, 1, (LPARAM) &tab_spacing);

  0017b	8d 45 d8	 lea	 eax, DWORD PTR _tab_spacing$[ebp]
  0017e	50		 push	 eax
  0017f	6a 01		 push	 1
  00181	68 cb 00 00 00	 push	 203			; 000000cbH
  00186	68 ea 03 00 00	 push	 1002			; 000003eaH
  0018b	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0018e	51		 push	 ecx
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 3958 : 
; 3959 :          // If any of these are null, the system has major problems
; 3960 :          hwnd_iters = GetDlgItem(hwnd, IDC_ITERS);

  00195	68 fb 03 00 00	 push	 1019			; 000003fbH
  0019a	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0019d	50		 push	 eax
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001a4	a3 00 00 00 00	 mov	 DWORD PTR _hwnd_iters, eax

; 3961 :          hwnd_info = GetDlgItem(hwnd, IDC_INFO);

  001a9	68 ea 03 00 00	 push	 1002			; 000003eaH
  001ae	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  001b1	50		 push	 eax
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001b8	a3 00 00 00 00	 mov	 DWORD PTR _hwnd_info, eax

; 3962 :          hwnd_status = GetDlgItem(hwnd, IDC_STATUS);

  001bd	68 e9 03 00 00	 push	 1001			; 000003e9H
  001c2	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  001c5	50		 push	 eax
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001cc	a3 00 00 00 00	 mov	 DWORD PTR _hwnd_status, eax

; 3963 :          hwnd_status2 = GetDlgItem(hwnd, IDC_STATUS2);

  001d1	68 ef 03 00 00	 push	 1007			; 000003efH
  001d6	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  001d9	50		 push	 eax
  001da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001e0	a3 00 00 00 00	 mov	 DWORD PTR _hwnd_status2, eax

; 3964 :          hwnd_thumbnail_frame = GetDlgItem(hwnd, IDC_THUMBNAIL_FRAME); // v1.10: now an invisible dummy item

  001e5	68 19 04 00 00	 push	 1049			; 00000419H
  001ea	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  001ed	50		 push	 eax
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001f4	a3 00 00 00 00	 mov	 DWORD PTR _hwnd_thumbnail_frame, eax

; 3965 : 
; 3966 :          // PNG save and Preserve aspect ratio buttons checked by default
; 3967 :          SendDlgItemMessage(hwnd, IDC_PNG, BM_SETCHECK, BST_CHECKED, 0);

  001f9	6a 00		 push	 0
  001fb	6a 01		 push	 1
  001fd	68 f1 00 00 00	 push	 241			; 000000f1H
  00202	68 27 04 00 00	 push	 1063			; 00000427H
  00207	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0020a	50		 push	 eax
  0020b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 3968 :          SendDlgItemMessage(hwnd, IDC_ASPECT, BM_SETCHECK, BST_CHECKED, 0);

  00211	6a 00		 push	 0
  00213	6a 01		 push	 1
  00215	68 f1 00 00 00	 push	 241			; 000000f1H
  0021a	68 22 04 00 00	 push	 1058			; 00000422H
  0021f	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00222	50		 push	 eax
  00223	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 3969 : 
; 3970 :          // Adjust dialog box to compensate for different border and font sizes. What a pain...
; 3971 : 
; 3972 :          // To simulate Vista large fonts on XP: set font size to large, set lpix_per_inch to
; 3973 :          // 120, and change "MS Shell Dlg" font size to 10 in quickman.rc. Seems almost exact.
; 3974 :          // lpix_per_inch = 120;
; 3975 : 
; 3976 :          // The seems to be no documented function to help figure out how a dialog box width
; 3977 :          // should scale with font size. The calc. below usually turns out too wide. Will be
; 3978 :          // corrected in an iterative process below...
; 3979 : 
; 3980 :          dialog_w = (lpix_per_inch * (ORIG_DIALOG_WIDTH - x_dialog_border)) / ORIG_LPIX + x_dialog_border;

  00229	b8 ad 00 00 00	 mov	 eax, 173		; 000000adH
  0022e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _x_dialog_border
  00234	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _lpix_per_inch
  0023b	99		 cdq
  0023c	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00241	f7 f9		 idiv	 ecx
  00243	03 05 00 00 00
	00		 add	 eax, DWORD PTR _x_dialog_border
  00249	89 45 fc	 mov	 DWORD PTR _dialog_w$[ebp], eax

; 3981 : 
; 3982 :          // Initially, see if things fit in a dialog that's the same height as the main window
; 3983 :          dialog_h = ORIG_DIALOG_HEIGHT + YBORDER_ADJUSTMENT;

  0024c	a1 00 00 00 00	 mov	 eax, DWORD PTR _y_border
  00251	05 bc 02 00 00	 add	 eax, 700		; 000002bcH
  00256	89 45 f8	 mov	 DWORD PTR _dialog_h$[ebp], eax

; 3984 : 
; 3985 :          // With pathologically large fonts, could fail to make a decent box- just give up
; 3986 :          // after a certain number of tries
; 3987 :          max_tries = 3;

  00259	c7 45 dc 03 00
	00 00		 mov	 DWORD PTR _max_tries$[ebp], 3
$LN6@man_dialog:

; 3988 : 
; 3989 :          do
; 3990 :          {
; 3991 :             SetWindowPos(hwnd, HWND_TOP, 0, 0, dialog_w, dialog_h, SWP_NOMOVE | SWP_HIDEWINDOW);

  00260	68 82 00 00 00	 push	 130			; 00000082H
  00265	8b 45 f8	 mov	 eax, DWORD PTR _dialog_h$[ebp]
  00268	50		 push	 eax
  00269	8b 4d fc	 mov	 ecx, DWORD PTR _dialog_w$[ebp]
  0026c	51		 push	 ecx
  0026d	6a 00		 push	 0
  0026f	6a 00		 push	 0
  00271	6a 00		 push	 0
  00273	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00276	52		 push	 edx
  00277	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 3992 :             GetWindowRect(hwnd, &rc_dialog); // get adjusted dialog rect

  0027d	8d 45 a8	 lea	 eax, DWORD PTR _rc_dialog$[ebp]
  00280	50		 push	 eax
  00281	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00284	51		 push	 ecx
  00285	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 3993 : 
; 3994 :             // Dialog item positions are relative to dialog box coords. y = 0 is the topmost pixel in the
; 3995 :             // dialog (inside the border). Last_ypixel is the bottommost pixel in the dialog. These seem
; 3996 :             // to be the right calculations...
; 3997 : 
; 3998 :             last_ypixel = rc_dialog.bottom - rc_dialog.top - y_dialog_border - 1;

  0028b	8b 45 b4	 mov	 eax, DWORD PTR _rc_dialog$[ebp+12]
  0028e	2b 45 ac	 sub	 eax, DWORD PTR _rc_dialog$[ebp+4]
  00291	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _y_dialog_border
  00297	83 e8 01	 sub	 eax, 1
  0029a	89 45 e4	 mov	 DWORD PTR _last_ypixel$[ebp], eax

; 3999 : 
; 4000 :             GetWindowRect(hwnd_status, &rc_status);      // get status line rect

  0029d	8d 45 b8	 lea	 eax, DWORD PTR _rc_status$[ebp]
  002a0	50		 push	 eax
  002a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_status
  002a7	51		 push	 ecx
  002a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 4001 :             text_h = rc_status.bottom - rc_status.top;   // height of status line text

  002ae	8b 45 c4	 mov	 eax, DWORD PTR _rc_status$[ebp+12]
  002b1	2b 45 bc	 sub	 eax, DWORD PTR _rc_status$[ebp+4]
  002b4	89 45 f0	 mov	 DWORD PTR _text_h$[ebp], eax

; 4002 : 
; 4003 :             #define TEXT_TO_BOTTOM_SPACE  3 // some fine-tuning constants
; 4004 :             #define TEXT_TO_FRAME_SPACE   6
; 4005 :             #define FRAME_TO_DIALOG_SPACE 6 // distance to dialog edges from each vertical side of frame
; 4006 : 
; 4007 :             text_h += TEXT_TO_BOTTOM_SPACE;

  002b7	8b 45 f0	 mov	 eax, DWORD PTR _text_h$[ebp]
  002ba	83 c0 03	 add	 eax, 3
  002bd	89 45 f0	 mov	 DWORD PTR _text_h$[ebp], eax

; 4008 : 
; 4009 :             // Adjust status1/status2 ypos so they're just above the bottom of the dialog
; 4010 :             SetWindowPos(hwnd_status, HWND_TOP, ORIG_STATUS_X, last_ypixel - text_h, 0, 0, SWP_NOSIZE);

  002c0	6a 01		 push	 1
  002c2	6a 00		 push	 0
  002c4	6a 00		 push	 0
  002c6	8b 45 e4	 mov	 eax, DWORD PTR _last_ypixel$[ebp]
  002c9	2b 45 f0	 sub	 eax, DWORD PTR _text_h$[ebp]
  002cc	50		 push	 eax
  002cd	6a 08		 push	 8
  002cf	6a 00		 push	 0
  002d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_status
  002d7	51		 push	 ecx
  002d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 4011 : 
; 4012 :             GetWindowRect(hwnd_status2, &rc_status);        // get status2 line rect

  002de	8d 45 b8	 lea	 eax, DWORD PTR _rc_status$[ebp]
  002e1	50		 push	 eax
  002e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_status2
  002e8	51		 push	 ecx
  002e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 4013 :             text_w = rc_status.right - rc_status.left + 4;  // not sure why this width is off by a few pixels

  002ef	8b 45 c0	 mov	 eax, DWORD PTR _rc_status$[ebp+8]
  002f2	2b 45 b8	 sub	 eax, DWORD PTR _rc_status$[ebp]
  002f5	83 c0 04	 add	 eax, 4
  002f8	89 45 f4	 mov	 DWORD PTR _text_w$[ebp], eax

; 4014 : 
; 4015 :             // Get thumbnail frame rectangle
; 4016 :             GetWindowRect(hwnd_thumbnail_frame, &rc_tframe);

  002fb	8d 45 c8	 lea	 eax, DWORD PTR _rc_tframe$[ebp]
  002fe	50		 push	 eax
  002ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_thumbnail_frame
  00305	51		 push	 ecx
  00306	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 4017 : 
; 4018 :             // Adjust status2 xpos so its right lines up with the thumbnail frame right
; 4019 :             SetWindowPos(hwnd_status2, HWND_TOP, rc_tframe.right - rc_dialog.left - text_w,

  0030c	6a 01		 push	 1
  0030e	6a 00		 push	 0
  00310	6a 00		 push	 0
  00312	8b 45 e4	 mov	 eax, DWORD PTR _last_ypixel$[ebp]
  00315	2b 45 f0	 sub	 eax, DWORD PTR _text_h$[ebp]
  00318	50		 push	 eax
  00319	8b 4d d0	 mov	 ecx, DWORD PTR _rc_tframe$[ebp+8]
  0031c	2b 4d a8	 sub	 ecx, DWORD PTR _rc_dialog$[ebp]
  0031f	2b 4d f4	 sub	 ecx, DWORD PTR _text_w$[ebp]
  00322	51		 push	 ecx
  00323	6a 00		 push	 0
  00325	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hwnd_status2
  0032b	52		 push	 edx
  0032c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 4020 :                          last_ypixel - text_h, 0, 0, SWP_NOSIZE);
; 4021 : 
; 4022 :             // Adjust height of thumbnail frame so its bottom is just above the status line top
; 4023 :             SetWindowPos(hwnd_thumbnail_frame, HWND_TOP, 0, 0, frame_w = rc_tframe.right - rc_tframe.left,

  00332	8b 45 b4	 mov	 eax, DWORD PTR _rc_dialog$[ebp+12]
  00335	2b 45 cc	 sub	 eax, DWORD PTR _rc_tframe$[ebp+4]
  00338	2b 45 f0	 sub	 eax, DWORD PTR _text_h$[ebp]
  0033b	83 e8 06	 sub	 eax, 6
  0033e	89 45 e8	 mov	 DWORD PTR _frame_h$[ebp], eax
  00341	8b 4d d0	 mov	 ecx, DWORD PTR _rc_tframe$[ebp+8]
  00344	2b 4d c8	 sub	 ecx, DWORD PTR _rc_tframe$[ebp]
  00347	89 4d ec	 mov	 DWORD PTR _frame_w$[ebp], ecx
  0034a	6a 02		 push	 2
  0034c	8b 55 e8	 mov	 edx, DWORD PTR _frame_h$[ebp]
  0034f	52		 push	 edx
  00350	8b 45 ec	 mov	 eax, DWORD PTR _frame_w$[ebp]
  00353	50		 push	 eax
  00354	6a 00		 push	 0
  00356	6a 00		 push	 0
  00358	6a 00		 push	 0
  0035a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_thumbnail_frame
  00360	51		 push	 ecx
  00361	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 4024 :                          frame_h = rc_dialog.bottom - rc_tframe.top - text_h - TEXT_TO_FRAME_SPACE,
; 4025 :                          SWP_NOMOVE);
; 4026 : 
; 4027 :             done = 1;

  00367	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _done$[ebp], 1

; 4028 : 
; 4029 :             // If dialog is too wide or too narrow, adjust to frame width and start over
; 4030 :             if (dialog_w != (frame_w += 2 * (lpix_per_inch * FRAME_TO_DIALOG_SPACE) / ORIG_LPIX + x_dialog_border))

  0036e	6b 05 00 00 00
	00 06		 imul	 eax, DWORD PTR _lpix_per_inch, 6
  00375	d1 e0		 shl	 eax, 1
  00377	99		 cdq
  00378	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  0037d	f7 f9		 idiv	 ecx
  0037f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _x_dialog_border
  00385	03 45 ec	 add	 eax, DWORD PTR _frame_w$[ebp]
  00388	89 45 ec	 mov	 DWORD PTR _frame_w$[ebp], eax
  0038b	8b 55 fc	 mov	 edx, DWORD PTR _dialog_w$[ebp]
  0038e	3b 55 ec	 cmp	 edx, DWORD PTR _frame_w$[ebp]
  00391	74 0d		 je	 SHORT $LN12@man_dialog

; 4031 :             {
; 4032 :                dialog_w = frame_w;

  00393	8b 45 ec	 mov	 eax, DWORD PTR _frame_w$[ebp]
  00396	89 45 fc	 mov	 DWORD PTR _dialog_w$[ebp], eax

; 4033 :                done = 0;

  00399	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _done$[ebp], 0
$LN12@man_dialog:

; 4034 :             }
; 4035 : 
; 4036 :             // If frame height is too small, increase dialog height and start over
; 4037 :             if (frame_h < TFRAME_MIN_HEIGHT)

  003a0	83 7d e8 01	 cmp	 DWORD PTR _frame_h$[ebp], 1
  003a4	7d 15		 jge	 SHORT $LN13@man_dialog

; 4038 :             {
; 4039 :                dialog_h += TFRAME_MIN_HEIGHT - frame_h;

  003a6	b8 01 00 00 00	 mov	 eax, 1
  003ab	2b 45 e8	 sub	 eax, DWORD PTR _frame_h$[ebp]
  003ae	03 45 f8	 add	 eax, DWORD PTR _dialog_h$[ebp]
  003b1	89 45 f8	 mov	 DWORD PTR _dialog_h$[ebp], eax

; 4040 :                done = 0;

  003b4	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _done$[ebp], 0
$LN13@man_dialog:

; 4041 :             }
; 4042 :          }
; 4043 :          while (!done && --max_tries);

  003bb	83 7d e0 00	 cmp	 DWORD PTR _done$[ebp], 0
  003bf	75 0f		 jne	 SHORT $LN14@man_dialog
  003c1	8b 45 dc	 mov	 eax, DWORD PTR _max_tries$[ebp]
  003c4	83 e8 01	 sub	 eax, 1
  003c7	89 45 dc	 mov	 DWORD PTR _max_tries$[ebp], eax
  003ca	0f 85 90 fe ff
	ff		 jne	 $LN6@man_dialog
$LN14@man_dialog:

; 4044 :          return FALSE;

  003d0	33 c0		 xor	 eax, eax
  003d2	e9 e8 08 00 00	 jmp	 $LN1@man_dialog
$LN15@man_dialog:

; 4045 : 
; 4046 :       case WM_VSCROLL: // Update iterations from spin control
; 4047 :          if ((HWND) lParam == GetDlgItem(hwnd, IDC_ADJUST_ITERS))

  003d7	68 fc 03 00 00	 push	 1020			; 000003fcH
  003dc	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  003df	50		 push	 eax
  003e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  003e6	39 45 14	 cmp	 DWORD PTR _lParam$[ebp], eax
  003e9	75 7c		 jne	 SHORT $LN7@man_dialog

; 4048 :          {
; 4049 :             m->max_iters = GetDlgItemInt(hwnd, IDC_ITERS, NULL, FALSE); // Get value user may have edited

  003eb	6a 00		 push	 0
  003ed	6a 00		 push	 0
  003ef	68 fb 03 00 00	 push	 1019			; 000003fbH
  003f4	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  003f7	50		 push	 eax
  003f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemInt@16
  003fe	8b 4d a0	 mov	 ecx, DWORD PTR _m$[ebp]
  00401	89 81 c0 8d 00
	00		 mov	 DWORD PTR [ecx+36288], eax

; 4050 :             switch (LOWORD(wParam))

  00407	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0040a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0040f	0f b7 c8	 movzx	 ecx, ax
  00412	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv295[ebp], ecx
  00418	83 bd 54 ff ff
	ff 04		 cmp	 DWORD PTR tv295[ebp], 4
  0041f	74 02		 je	 SHORT $LN17@man_dialog
  00421	eb 44		 jmp	 SHORT $LN7@man_dialog
$LN17@man_dialog:

; 4051 :             {
; 4052 :                case SB_THUMBPOSITION:
; 4053 :                   // No change (0) or decreasing value means up, increasing value means down
; 4054 :                   if (HIWORD(wParam) > adj_iters_prev)

  00423	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00426	c1 e8 10	 shr	 eax, 16			; 00000010H
  00429	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0042e	0f b7 c8	 movzx	 ecx, ax
  00431	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?adj_iters_prev@?1??man_dialog_proc@@9@9
  00437	7e 0e		 jle	 SHORT $LN18@man_dialog

; 4055 :                      update_iters(0, 1);

  00439	6a 01		 push	 1
  0043b	6a 00		 push	 0
  0043d	e8 00 00 00 00	 call	 _update_iters
  00442	83 c4 08	 add	 esp, 8
  00445	eb 0c		 jmp	 SHORT $LN19@man_dialog
$LN18@man_dialog:

; 4056 :                   else
; 4057 :                      update_iters(1, 0);

  00447	6a 00		 push	 0
  00449	6a 01		 push	 1
  0044b	e8 00 00 00 00	 call	 _update_iters
  00450	83 c4 08	 add	 esp, 8
$LN19@man_dialog:

; 4058 :                   adj_iters_prev = HIWORD(wParam);

  00453	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00456	c1 e8 10	 shr	 eax, 16			; 00000010H
  00459	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0045e	0f b7 c8	 movzx	 ecx, ax
  00461	89 0d 00 00 00
	00		 mov	 DWORD PTR ?adj_iters_prev@?1??man_dialog_proc@@9@9, ecx
$LN7@man_dialog:

; 4059 :                   break;
; 4060 :              }
; 4061 :          }
; 4062 :          return TRUE;

  00467	b8 01 00 00 00	 mov	 eax, 1
  0046c	e9 4e 08 00 00	 jmp	 $LN1@man_dialog
$LN20@man_dialog:

; 4063 : 
; 4064 :       case WM_HSCROLL: // Slider values are being updated. Moving these around during zooming
; 4065 :                        // annoyingly creates about a 1% slowdown, even with no processing.
; 4066 :          if ((HWND) lParam == GetDlgItem(hwnd, IDC_PAN_RATE))

  00471	68 17 04 00 00	 push	 1047			; 00000417H
  00476	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00479	50		 push	 eax
  0047a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00480	39 45 14	 cmp	 DWORD PTR _lParam$[ebp], eax
  00483	75 1d		 jne	 SHORT $LN21@man_dialog

; 4067 :             cfg_settings.pan_rate.val = (int) SendDlgItemMessage(hwnd, IDC_PAN_RATE, TBM_GETPOS, 0, 0);

  00485	6a 00		 push	 0
  00487	6a 00		 push	 0
  00489	68 00 04 00 00	 push	 1024			; 00000400H
  0048e	68 17 04 00 00	 push	 1047			; 00000417H
  00493	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00496	50		 push	 eax
  00497	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
  0049d	a3 04 00 00 00	 mov	 DWORD PTR _cfg_settings+4, eax
$LN21@man_dialog:

; 4068 :          if ((HWND) lParam == GetDlgItem(hwnd, IDC_ZOOM_RATE))

  004a2	68 18 04 00 00	 push	 1048			; 00000418H
  004a7	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  004aa	50		 push	 eax
  004ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  004b1	39 45 14	 cmp	 DWORD PTR _lParam$[ebp], eax
  004b4	75 1d		 jne	 SHORT $LN22@man_dialog

; 4069 :             cfg_settings.zoom_rate.val = (int) SendDlgItemMessage(hwnd, IDC_ZOOM_RATE, TBM_GETPOS, 0, 0);

  004b6	6a 00		 push	 0
  004b8	6a 00		 push	 0
  004ba	68 00 04 00 00	 push	 1024			; 00000400H
  004bf	68 18 04 00 00	 push	 1048			; 00000418H
  004c4	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  004c7	50		 push	 eax
  004c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
  004ce	a3 2c 00 00 00	 mov	 DWORD PTR _cfg_settings+44, eax
$LN22@man_dialog:

; 4070 :          reset_fps_values(); // reset frames/sec timing values when pan or zoom rate changes

  004d3	e8 00 00 00 00	 call	 _reset_fps_values

; 4071 :          return TRUE;

  004d8	b8 01 00 00 00	 mov	 eax, 1
  004dd	e9 dd 07 00 00	 jmp	 $LN1@man_dialog
$LN23@man_dialog:

; 4072 : 
; 4073 :       case WM_COMMAND:
; 4074 : 
; 4075 :          switch (LOWORD(wParam))

  004e2	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  004e5	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  004ea	0f b7 c8	 movzx	 ecx, ax
  004ed	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv333[ebp], ecx
  004f3	81 bd 54 ff ff
	ff f2 03 00 00	 cmp	 DWORD PTR tv333[ebp], 1010 ; 000003f2H
  004fd	7f 40		 jg	 SHORT $LN76@man_dialog
  004ff	81 bd 54 ff ff
	ff f2 03 00 00	 cmp	 DWORD PTR tv333[ebp], 1010 ; 000003f2H
  00509	0f 84 b4 01 00
	00		 je	 $LN33@man_dialog
  0050f	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv333[ebp]
  00515	83 ea 08	 sub	 edx, 8
  00518	89 95 54 ff ff
	ff		 mov	 DWORD PTR tv333[ebp], edx
  0051e	83 bd 54 ff ff
	ff 0c		 cmp	 DWORD PTR tv333[ebp], 12 ; 0000000cH
  00525	0f 87 8e 07 00
	00		 ja	 $LN68@man_dialog
  0052b	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv333[ebp]
  00531	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN77@man_dialog[eax]
  00538	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN80@man_dialog[ecx*4]
$LN76@man_dialog:
  0053f	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv333[ebp]
  00545	81 ea 03 04 00
	00		 sub	 edx, 1027		; 00000403H
  0054b	89 95 54 ff ff
	ff		 mov	 DWORD PTR tv333[ebp], edx
  00551	83 bd 54 ff ff
	ff 2a		 cmp	 DWORD PTR tv333[ebp], 42 ; 0000002aH
  00558	0f 87 5b 07 00
	00		 ja	 $LN68@man_dialog
  0055e	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv333[ebp]
  00564	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN78@man_dialog[eax]
  0056b	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN81@man_dialog[ecx*4]
$LN24@man_dialog:

; 4076 :          {
; 4077 :             case IDC_LOGFILE:
; 4078 :                if (HIWORD(wParam) == CBN_EDITCHANGE)

  00572	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00575	c1 e8 10	 shr	 eax, 16			; 00000010H
  00578	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0057d	0f b7 c8	 movzx	 ecx, ax
  00580	83 f9 05	 cmp	 ecx, 5
  00583	75 14		 jne	 SHORT $LN25@man_dialog

; 4079 :                {
; 4080 :                   new_file_entered = 1;             // Mark that user entered a new filename: will be

  00585	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?new_file_entered@?1??man_dialog_proc@@9@9, 1

; 4081 :                   new_file_selected = 0;            // added to box when a log func is used.

  0058f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?new_file_selected@?1??man_dialog_proc@@9@9, 0
$LN25@man_dialog:

; 4082 :                }
; 4083 :                if (HIWORD(wParam) == CBN_SELCHANGE) // No longer really need to read logfile immediately

  00599	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0059c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0059f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  005a4	0f b7 c8	 movzx	 ecx, ax
  005a7	83 f9 01	 cmp	 ecx, 1
  005aa	75 14		 jne	 SHORT $LN26@man_dialog

; 4084 :                {                                    // on selection change, with quickman.cfg now
; 4085 :                   new_file_entered = 0;             // available for default settings. Old Microsoft

  005ac	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?new_file_entered@?1??man_dialog_proc@@9@9, 0

; 4086 :                   new_file_selected = 1;            // code was dangerous (no limit to string copy size).

  005b6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?new_file_selected@?1??man_dialog_proc@@9@9, 1
$LN26@man_dialog:

; 4087 :                }
; 4088 :                return TRUE;

  005c0	b8 01 00 00 00	 mov	 eax, 1
  005c5	e9 f5 06 00 00	 jmp	 $LN1@man_dialog
$LN27@man_dialog:

; 4089 : 
; 4090 :             case IDC_PALETTE:
; 4091 :             case IDC_RENDERING:
; 4092 :                if (HIWORD(wParam) == CBN_SELCHANGE)

  005ca	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  005cd	c1 e8 10	 shr	 eax, 16			; 00000010H
  005d0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  005d5	0f b7 c8	 movzx	 ecx, ax
  005d8	83 f9 01	 cmp	 ecx, 1
  005db	0f 85 d8 00 00
	00		 jne	 $LN28@man_dialog

; 4093 :                {
; 4094 :                   // If palette is not one of the builtins, try loading from file
; 4095 :                   if (!get_builtin_palette())

  005e1	e8 00 00 00 00	 call	 _get_builtin_palette
  005e6	85 c0		 test	 eax, eax
  005e8	75 05		 jne	 SHORT $LN29@man_dialog

; 4096 :                      get_user_palette();

  005ea	e8 00 00 00 00	 call	 _get_user_palette
$LN29@man_dialog:

; 4097 : 
; 4098 :                   // Give warning if fast alg and normalized rendering; allow user to switch to exact first
; 4099 :                   if (LOWORD(wParam) == IDC_RENDERING)

  005ef	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  005f2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  005f7	0f b7 c8	 movzx	 ecx, ax
  005fa	81 f9 04 04 00
	00		 cmp	 ecx, 1028		; 00000404H
  00600	75 0c		 jne	 SHORT $LN30@man_dialog

; 4100 :                      check_alg(hwnd);

  00602	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00605	50		 push	 eax
  00606	e8 00 00 00 00	 call	 _check_alg
  0060b	83 c4 04	 add	 esp, 4
$LN30@man_dialog:

; 4101 : 
; 4102 :                   // Recalculate all first if we need to
; 4103 :                   if ((status & STAT_RECALC_FOR_PALETTE) || (m->max_iters != m->max_iters_last))

  0060e	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00613	83 e0 02	 and	 eax, 2
  00616	75 14		 jne	 SHORT $LN32@man_dialog
  00618	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  0061b	8b 4d a0	 mov	 ecx, DWORD PTR _m$[ebp]
  0061e	8b 90 c0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36288]
  00624	3b 91 c4 8d 00
	00		 cmp	 edx, DWORD PTR [ecx+36292]
  0062a	74 38		 je	 SHORT $LN31@man_dialog
$LN32@man_dialog:

; 4104 :                   {
; 4105 :                      update_re_im(m, m->pan_xoffs, m->pan_yoffs); // update re/im from any pan offsets and reset offsets

  0062c	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  0062f	8b 88 a4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36260]
  00635	51		 push	 ecx
  00636	8b 90 a0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36256]
  0063c	52		 push	 edx
  0063d	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00640	8b 88 9c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36252]
  00646	51		 push	 ecx
  00647	8b 90 98 8d 00
	00		 mov	 edx, DWORD PTR [eax+36248]
  0064d	52		 push	 edx
  0064e	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00651	50		 push	 eax
  00652	e8 00 00 00 00	 call	 _update_re_im
  00657	83 c4 14	 add	 esp, 20			; 00000014H

; 4106 :                      do_man_calculate(1);

  0065a	6a 01		 push	 1
  0065c	e8 00 00 00 00	 call	 _do_man_calculate
  00661	83 c4 04	 add	 esp, 4
$LN31@man_dialog:

; 4107 :                   }
; 4108 : 
; 4109 :                   // Apply palette to the whole image (in UL quadrant here)
; 4110 :                   apply_palette(m, quad[UL].bitmap_data, m->iter_data, m->xsize, m->ysize);

  00664	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00667	8b 88 8c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36236]
  0066d	51		 push	 ecx
  0066e	8b 55 a0	 mov	 edx, DWORD PTR _m$[ebp]
  00671	8b 82 88 8d 00
	00		 mov	 eax, DWORD PTR [edx+36232]
  00677	50		 push	 eax
  00678	8b 4d a0	 mov	 ecx, DWORD PTR _m$[ebp]
  0067b	8b 91 e0 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36320]
  00681	52		 push	 edx
  00682	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  00687	6b c8 00	 imul	 ecx, eax, 0
  0068a	8b 91 1c 00 00
	00		 mov	 edx, DWORD PTR _quad[ecx+28]
  00690	52		 push	 edx
  00691	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00694	50		 push	 eax
  00695	e8 00 00 00 00	 call	 _apply_palette
  0069a	83 c4 14	 add	 esp, 20			; 00000014H

; 4111 :                   InvalidateRect(hwnd_main, NULL, 0); // cause repaint

  0069d	6a 00		 push	 0
  0069f	6a 00		 push	 0
  006a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  006a6	50		 push	 eax
  006a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 4112 :                   UpdateWindow(hwnd_main);

  006ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  006b2	50		 push	 eax
  006b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UpdateWindow@4
$LN28@man_dialog:

; 4113 :                }
; 4114 :                return TRUE;

  006b9	b8 01 00 00 00	 mov	 eax, 1
  006be	e9 fc 05 00 00	 jmp	 $LN1@man_dialog
$LN33@man_dialog:

; 4115 : 
; 4116 :             case IDC_ALGORITHM:
; 4117 :             case IDC_PRECISION:
; 4118 :                if (HIWORD(wParam) == CBN_SELCHANGE)

  006c3	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  006c6	c1 e8 10	 shr	 eax, 16			; 00000010H
  006c9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  006ce	0f b7 c8	 movzx	 ecx, ax
  006d1	83 f9 01	 cmp	 ecx, 1
  006d4	75 0c		 jne	 SHORT $LN34@man_dialog

; 4119 :                   check_alg(hwnd); // make sure CPU supports alg/precision combination

  006d6	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  006d9	50		 push	 eax
  006da	e8 00 00 00 00	 call	 _check_alg
  006df	83 c4 04	 add	 esp, 4
$LN34@man_dialog:

; 4120 :                return TRUE;

  006e2	b8 01 00 00 00	 mov	 eax, 1
  006e7	e9 d3 05 00 00	 jmp	 $LN1@man_dialog
$LN35@man_dialog:

; 4121 : 
; 4122 :             case IDC_THREADS:
; 4123 :                if (HIWORD(wParam) == CBN_SELCHANGE)

  006ec	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  006ef	c1 e8 10	 shr	 eax, 16			; 00000010H
  006f2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  006f7	0f b7 c8	 movzx	 ecx, ax
  006fa	83 f9 01	 cmp	 ecx, 1
  006fd	75 05		 jne	 SHORT $LN36@man_dialog

; 4124 :                   get_num_threads();

  006ff	e8 00 00 00 00	 call	 _get_num_threads
$LN36@man_dialog:

; 4125 :                return TRUE;

  00704	b8 01 00 00 00	 mov	 eax, 1
  00709	e9 b1 05 00 00	 jmp	 $LN1@man_dialog
$LN37@man_dialog:

; 4126 : 
; 4127 :             case IDC_SAVE_XSIZE:
; 4128 :             case IDC_SAVE_YSIZE:
; 4129 : 
; 4130 :                // Set save xsize or ysize automatically from the other if preserve aspect box is checked
; 4131 :                if (HIWORD(wParam) == EN_UPDATE)

  0070e	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00711	c1 e8 10	 shr	 eax, 16			; 00000010H
  00714	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00719	0f b7 c8	 movzx	 ecx, ax
  0071c	81 f9 00 04 00
	00		 cmp	 ecx, 1024		; 00000400H
  00722	0f 85 35 01 00
	00		 jne	 $LN45@man_dialog

; 4132 :                {
; 4133 :                   if (IsDlgButtonChecked(hwnd, IDC_ASPECT))

  00728	68 22 04 00 00	 push	 1058			; 00000422H
  0072d	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00730	50		 push	 eax
  00731	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDlgButtonChecked@8
  00737	85 c0		 test	 eax, eax
  00739	0f 84 1e 01 00
	00		 je	 $LN45@man_dialog

; 4134 :                   {
; 4135 :                      double aspect;
; 4136 :                      aspect = (double) m->xsize / (double) m->ysize;

  0073f	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00742	f2 0f 2a 80 88
	8d 00 00	 cvtsi2sd xmm0, DWORD PTR [eax+36232]
  0074a	8b 4d a0	 mov	 ecx, DWORD PTR _m$[ebp]
  0074d	f2 0f 2a 89 8c
	8d 00 00	 cvtsi2sd xmm1, DWORD PTR [ecx+36236]
  00755	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00759	f2 0f 11 45 98	 movsd	 QWORD PTR _aspect$1[ebp], xmm0

; 4137 : 
; 4138 :                      // Need the ignore_ logic to prevent infinite message loops
; 4139 :                      if (LOWORD(wParam) == IDC_SAVE_XSIZE)

  0075e	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00761	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00766	0f b7 c8	 movzx	 ecx, ax
  00769	81 f9 2c 04 00
	00		 cmp	 ecx, 1068		; 0000042cH
  0076f	75 77		 jne	 SHORT $LN40@man_dialog

; 4140 :                         if (ignore_next_change != 1)

  00771	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?ignore_next_change@?1??man_dialog_proc@@9@9, 1
  00778	74 62		 je	 SHORT $LN42@man_dialog

; 4141 :                         {
; 4142 :                            ignore_next_change = 2;

  0077a	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?ignore_next_change@?1??man_dialog_proc@@9@9, 2

; 4143 :                            SetDlgItemInt(hwnd, IDC_SAVE_YSIZE, (int)(0.5 + (double)

  00784	6a 00		 push	 0
  00786	6a 00		 push	 0
  00788	6a 00		 push	 0
  0078a	68 2c 04 00 00	 push	 1068			; 0000042cH
  0078f	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00792	50		 push	 eax
  00793	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemInt@16
  00799	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv750[ebp], eax
  0079f	f2 0f 2a 85 54
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv750[ebp]
  007a7	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv750[ebp]
  007ad	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  007b0	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  007b9	f2 0f 5e 45 98	 divsd	 xmm0, QWORD PTR _aspect$1[ebp]
  007be	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  007c6	f2 0f 2c d0	 cvttsd2si edx, xmm0
  007ca	52		 push	 edx
  007cb	68 2d 04 00 00	 push	 1069			; 0000042dH
  007d0	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  007d3	50		 push	 eax
  007d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemInt@16

; 4144 :                                          GetDlgItemInt(hwnd, IDC_SAVE_XSIZE, NULL, FALSE) / aspect), FALSE);
; 4145 :                         }

  007da	eb 0a		 jmp	 SHORT $LN43@man_dialog
$LN42@man_dialog:

; 4146 :                         else
; 4147 :                            ignore_next_change = 0;

  007dc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ignore_next_change@?1??man_dialog_proc@@9@9, 0
$LN43@man_dialog:
  007e6	eb 75		 jmp	 SHORT $LN45@man_dialog
$LN40@man_dialog:

; 4148 :                      else
; 4149 :                         if (ignore_next_change != 2)

  007e8	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?ignore_next_change@?1??man_dialog_proc@@9@9, 2
  007ef	74 62		 je	 SHORT $LN44@man_dialog

; 4150 :                         {
; 4151 :                            ignore_next_change = 1;

  007f1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ignore_next_change@?1??man_dialog_proc@@9@9, 1

; 4152 :                            SetDlgItemInt(hwnd, IDC_SAVE_XSIZE, (int)(0.5 + (double)

  007fb	6a 00		 push	 0
  007fd	6a 00		 push	 0
  007ff	6a 00		 push	 0
  00801	68 2d 04 00 00	 push	 1069			; 0000042dH
  00806	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00809	50		 push	 eax
  0080a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemInt@16
  00810	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv758[ebp], eax
  00816	f2 0f 2a 85 54
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv758[ebp]
  0081e	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv758[ebp]
  00824	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00827	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00830	f2 0f 59 45 98	 mulsd	 xmm0, QWORD PTR _aspect$1[ebp]
  00835	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0083d	f2 0f 2c d0	 cvttsd2si edx, xmm0
  00841	52		 push	 edx
  00842	68 2c 04 00 00	 push	 1068			; 0000042cH
  00847	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0084a	50		 push	 eax
  0084b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemInt@16

; 4153 :                                          GetDlgItemInt(hwnd, IDC_SAVE_YSIZE, NULL, FALSE) * aspect), FALSE);
; 4154 :                         }

  00851	eb 0a		 jmp	 SHORT $LN45@man_dialog
$LN44@man_dialog:

; 4155 :                         else
; 4156 :                            ignore_next_change = 0;

  00853	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ignore_next_change@?1??man_dialog_proc@@9@9, 0
$LN45@man_dialog:

; 4157 :                   }
; 4158 :                }
; 4159 :                return TRUE;

  0085d	b8 01 00 00 00	 mov	 eax, 1
  00862	e9 58 04 00 00	 jmp	 $LN1@man_dialog
$LN46@man_dialog:

; 4160 : 
; 4161 :             case ID_HOME:
; 4162 :                set_home_image();   // Reset to base image coordinates; deliberate fallthru

  00867	e8 00 00 00 00	 call	 _set_home_image

; 4163 :                autoreset_settings(&cfg_settings);  // only do this on home or log next/prev, not recalculation

  0086c	68 00 00 00 00	 push	 OFFSET _cfg_settings
  00871	e8 00 00 00 00	 call	 _autoreset_settings
  00876	83 c4 04	 add	 esp, 4

; 4164 :                resize_window();

  00879	e8 00 00 00 00	 call	 _resize_window
$LN47@man_dialog:

; 4165 : 
; 4166 :             case ID_CALCULATE:
; 4167 : 
; 4168 :                do_rtzoom = prev_do_rtzoom = 0;     // stop any rt zoom in progress

  0087e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _prev_do_rtzoom, 0
  00888	a1 00 00 00 00	 mov	 eax, DWORD PTR _prev_do_rtzoom
  0088d	a3 00 00 00 00	 mov	 DWORD PTR _do_rtzoom, eax

; 4169 :                update_re_im(m, m->pan_xoffs, m->pan_yoffs); // update re/im from any pan offsets and reset offsets

  00892	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00895	8b 88 a4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36260]
  0089b	51		 push	 ecx
  0089c	8b 90 a0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36256]
  008a2	52		 push	 edx
  008a3	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  008a6	8b 88 9c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36252]
  008ac	51		 push	 ecx
  008ad	8b 90 98 8d 00
	00		 mov	 edx, DWORD PTR [eax+36248]
  008b3	52		 push	 edx
  008b4	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  008b7	50		 push	 eax
  008b8	e8 00 00 00 00	 call	 _update_re_im
  008bd	83 c4 14	 add	 esp, 20			; 00000014H

; 4170 :                reset_pan_state();                  // reset pan filters and movement state

  008c0	e8 00 00 00 00	 call	 _reset_pan_state

; 4171 :                get_pan_steps(NULL, NULL, 0);       // reset any pan lock

  008c5	6a 00		 push	 0
  008c7	6a 00		 push	 0
  008c9	6a 00		 push	 0
  008cb	e8 00 00 00 00	 call	 _get_pan_steps
  008d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4172 :                print_palette_status();

  008d3	e8 00 00 00 00	 call	 _print_palette_status

; 4173 :                do_man_calculate(1);  // calculate all pixels, update image info

  008d8	6a 01		 push	 1
  008da	e8 00 00 00 00	 call	 _do_man_calculate
  008df	83 c4 04	 add	 esp, 4

; 4174 :                SetFocus(hwnd_main);  // allow arrow keys to work immediately for panning

  008e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  008e7	50		 push	 eax
  008e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 4175 :                return TRUE;          // set focus AFTER calculating, or you get an annoying blink

  008ee	b8 01 00 00 00	 mov	 eax, 1
  008f3	e9 c7 03 00 00	 jmp	 $LN1@man_dialog
$LN48@man_dialog:

; 4176 : 
; 4177 :             case ID_LOG_IMAGE:
; 4178 :             case ID_LOG_PREV:
; 4179 :             case ID_LOG_NEXT:
; 4180 : 
; 4181 :                // Get the current filename
; 4182 :                GetDlgItemText(hwnd, IDC_LOGFILE, logfile, sizeof(logfile));

  008f8	68 00 01 00 00	 push	 256			; 00000100H
  008fd	68 00 00 00 00	 push	 OFFSET _logfile
  00902	68 07 04 00 00	 push	 1031			; 00000407H
  00907	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0090a	50		 push	 eax
  0090b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemTextA@16

; 4183 : 
; 4184 :                // If it's new, read it. If it was a newly entered filename, add it to the list.
; 4185 :                if (new_file_entered || new_file_selected)

  00911	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?new_file_entered@?1??man_dialog_proc@@9@9, 0
  00918	75 09		 jne	 SHORT $LN50@man_dialog
  0091a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?new_file_selected@?1??man_dialog_proc@@9@9, 0
  00921	74 4d		 je	 SHORT $LN52@man_dialog
$LN50@man_dialog:

; 4186 :                {
; 4187 :                   if (LOWORD(wParam) != ID_LOG_IMAGE)

  00923	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00926	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0092b	0f b7 c8	 movzx	 ecx, ax
  0092e	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  00931	74 19		 je	 SHORT $LN51@man_dialog

; 4188 :                   {
; 4189 :                      log_read(logfile, "", 1);     // read logfile into array

  00933	6a 01		 push	 1
  00935	68 00 00 00 00	 push	 OFFSET $SG42031
  0093a	68 00 00 00 00	 push	 OFFSET _logfile
  0093f	e8 00 00 00 00	 call	 _log_read
  00944	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4190 :                      reset_thread_load_counters(); // for testing load-balancing alg

  00947	e8 00 00 00 00	 call	 _reset_thread_load_counters
$LN51@man_dialog:

; 4191 :                   }
; 4192 :                   if (new_file_entered)

  0094c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?new_file_entered@?1??man_dialog_proc@@9@9, 0
  00953	74 1b		 je	 SHORT $LN52@man_dialog

; 4193 :                      SendDlgItemMessage(hwnd, IDC_LOGFILE, CB_ADDSTRING, 0, (LPARAM) logfile);

  00955	68 00 00 00 00	 push	 OFFSET _logfile
  0095a	6a 00		 push	 0
  0095c	68 43 01 00 00	 push	 323			; 00000143H
  00961	68 07 04 00 00	 push	 1031			; 00000407H
  00966	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00969	50		 push	 eax
  0096a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
$LN52@man_dialog:

; 4194 :                }
; 4195 :                if (LOWORD(wParam) == ID_LOG_IMAGE)

  00970	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00973	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00978	0f b7 c8	 movzx	 ecx, ax
  0097b	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  0097e	75 62		 jne	 SHORT $LN53@man_dialog

; 4196 :                {
; 4197 :                   // Need to update re/im with panning offsets, or logged coordinates will be wrong!
; 4198 :                   // Added this line for v1.03 bug fix
; 4199 :                   update_re_im(m, m->pan_xoffs, m->pan_yoffs);

  00980	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00983	8b 88 a4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36260]
  00989	51		 push	 ecx
  0098a	8b 90 a0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36256]
  00990	52		 push	 edx
  00991	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00994	8b 88 9c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36252]
  0099a	51		 push	 ecx
  0099b	8b 90 98 8d 00
	00		 mov	 edx, DWORD PTR [eax+36248]
  009a1	52		 push	 edx
  009a2	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  009a5	50		 push	 eax
  009a6	e8 00 00 00 00	 call	 _update_re_im
  009ab	83 c4 14	 add	 esp, 20			; 00000014H

; 4200 :                   log_update(logfile, new_file_entered | new_file_selected); // reset pos if new file

  009ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?new_file_entered@?1??man_dialog_proc@@9@9
  009b3	0b 05 00 00 00
	00		 or	 eax, DWORD PTR ?new_file_selected@?1??man_dialog_proc@@9@9
  009b9	50		 push	 eax
  009ba	68 00 00 00 00	 push	 OFFSET _logfile
  009bf	e8 00 00 00 00	 call	 _log_update
  009c4	83 c4 08	 add	 esp, 8

; 4201 :                   print_status_line(0);                 // update current/total number of log images

  009c7	6a 00		 push	 0
  009c9	e8 00 00 00 00	 call	 _print_status_line
  009ce	83 c4 04	 add	 esp, 4

; 4202 :                   SetWindowText(hwnd_status, "Logged"); // Ok if this stays till next calculation

  009d1	68 00 00 00 00	 push	 OFFSET $SG42034
  009d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_status
  009db	50		 push	 eax
  009dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
$LN53@man_dialog:

; 4203 :                }
; 4204 :                new_file_entered = 0;

  009e2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?new_file_entered@?1??man_dialog_proc@@9@9, 0

; 4205 :                new_file_selected = 0;

  009ec	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?new_file_selected@?1??man_dialog_proc@@9@9, 0

; 4206 : 
; 4207 :                // If user wants a new log image...
; 4208 :                if ( (LOWORD(wParam) == ID_LOG_NEXT || LOWORD(wParam == ID_LOG_PREV)) && log_count)

  009f6	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  009f9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  009fe	0f b7 c8	 movzx	 ecx, ax
  00a01	83 f9 08	 cmp	 ecx, 8
  00a04	74 32		 je	 SHORT $LN56@man_dialog
  00a06	83 7d 10 09	 cmp	 DWORD PTR _wParam$[ebp], 9
  00a0a	75 0c		 jne	 SHORT $LN72@man_dialog
  00a0c	c7 85 54 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv523[ebp], 1
  00a16	eb 0a		 jmp	 SHORT $LN73@man_dialog
$LN72@man_dialog:
  00a18	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv523[ebp], 0
$LN73@man_dialog:
  00a22	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv523[ebp]
  00a28	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00a2d	0f b7 c8	 movzx	 ecx, ax
  00a30	85 c9		 test	 ecx, ecx
  00a32	0f 84 8e 01 00
	00		 je	 $LN54@man_dialog
$LN56@man_dialog:
  00a38	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _log_count, 0
  00a3f	0f 84 81 01 00
	00		 je	 $LN54@man_dialog

; 4209 :                {
; 4210 :                   autoreset_settings(&cfg_settings);           // Autoreset any previous settings that need it

  00a45	68 00 00 00 00	 push	 OFFSET _cfg_settings
  00a4a	e8 00 00 00 00	 call	 _autoreset_settings
  00a4f	83 c4 04	 add	 esp, 4

; 4211 :                   m->pan_xoffs = 0;                            // Clear any pan offsets (no need to update

  00a52	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00a55	c7 80 98 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36248], 0
  00a5f	c7 80 9c 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36252], 0

; 4212 :                   m->pan_yoffs = 0;                            // re/im as they are reset from logfile)

  00a69	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00a6c	c7 80 a0 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36256], 0
  00a76	c7 80 a4 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36260], 0

; 4213 :                   if ((e = log_get(LOWORD(wParam) == ID_LOG_NEXT)) == NULL)  // get next/prev image from logfile array

  00a80	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00a83	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00a88	0f b7 c8	 movzx	 ecx, ax
  00a8b	83 f9 08	 cmp	 ecx, 8
  00a8e	75 0c		 jne	 SHORT $LN74@man_dialog
  00a90	c7 85 54 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv537[ebp], 1
  00a9a	eb 0a		 jmp	 SHORT $LN75@man_dialog
$LN74@man_dialog:
  00a9c	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv537[ebp], 0
$LN75@man_dialog:
  00aa6	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv537[ebp]
  00aac	52		 push	 edx
  00aad	e8 00 00 00 00	 call	 _log_get
  00ab2	83 c4 04	 add	 esp, 4
  00ab5	89 45 a4	 mov	 DWORD PTR _e$[ebp], eax
  00ab8	83 7d a4 00	 cmp	 DWORD PTR _e$[ebp], 0
  00abc	75 0a		 jne	 SHORT $LN57@man_dialog

; 4214 :                      return TRUE;

  00abe	b8 01 00 00 00	 mov	 eax, 1
  00ac3	e9 f7 01 00 00	 jmp	 $LN1@man_dialog
$LN57@man_dialog:

; 4215 : 
; 4216 :                   // Update any new settings
; 4217 :                   copy_changed_settings(&cfg_settings, &e->log_settings, 0); // 0 = don't copy to default_val

  00ac8	6a 00		 push	 0
  00aca	8b 45 a4	 mov	 eax, DWORD PTR _e$[ebp]
  00acd	83 c0 20	 add	 eax, 32			; 00000020H
  00ad0	50		 push	 eax
  00ad1	68 00 00 00 00	 push	 OFFSET _cfg_settings
  00ad6	e8 00 00 00 00	 call	 _copy_changed_settings
  00adb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4218 : 
; 4219 :                   // Update sliders, info box, iters, and palette
; 4220 :                   setup_sliders();

  00ade	e8 00 00 00 00	 call	 _setup_sliders

; 4221 :                   update_iters(0, 0);

  00ae3	6a 00		 push	 0
  00ae5	6a 00		 push	 0
  00ae7	e8 00 00 00 00	 call	 _update_iters
  00aec	83 c4 08	 add	 esp, 8

; 4222 :                   UpdateWindow(hwnd_iters);

  00aef	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_iters
  00af4	50		 push	 eax
  00af5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UpdateWindow@4

; 4223 : 
; 4224 :                   do_rtzoom = prev_do_rtzoom = 0; // stop any rt zoom in progress

  00afb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _prev_do_rtzoom, 0
  00b05	a1 00 00 00 00	 mov	 eax, DWORD PTR _prev_do_rtzoom
  00b0a	a3 00 00 00 00	 mov	 DWORD PTR _do_rtzoom, eax

; 4225 :                   reset_pan_state();              // reset pan filters and movement state

  00b0f	e8 00 00 00 00	 call	 _reset_pan_state

; 4226 :                   get_pan_steps(NULL, NULL, cfg_settings.pan_key.val); // set pan lock (or turn it off if pan_key is 0)

  00b14	a1 18 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+24
  00b19	50		 push	 eax
  00b1a	6a 00		 push	 0
  00b1c	6a 00		 push	 0
  00b1e	e8 00 00 00 00	 call	 _get_pan_steps
  00b23	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4227 : 
; 4228 :                   // Change palette, max iters color, and inversion status if not locked
; 4229 :                   if (!(status & STAT_PALETTE_LOCKED))

  00b26	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00b2b	83 e0 20	 and	 eax, 32			; 00000020H
  00b2e	75 54		 jne	 SHORT $LN59@man_dialog

; 4230 :                   {
; 4231 :                      m->pal_xor = cfg_settings.pal_xor.val;

  00b30	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00b33	8b 0d 90 00 00
	00		 mov	 ecx, DWORD PTR _cfg_settings+144
  00b39	89 88 fc 8d 00
	00		 mov	 DWORD PTR [eax+36348], ecx

; 4232 :                      m->max_iters_color = cfg_settings.max_iters_color.val;

  00b3f	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00b42	8b 0d 7c 00 00
	00		 mov	 ecx, DWORD PTR _cfg_settings+124
  00b48	89 88 00 8e 00
	00		 mov	 DWORD PTR [eax+36352], ecx

; 4233 : 
; 4234 :                      SendDlgItemMessage(hwnd, IDC_PALETTE, CB_SETCURSEL, m->palette, 0);

  00b4e	6a 00		 push	 0
  00b50	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00b53	8b 88 f4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36340]
  00b59	51		 push	 ecx
  00b5a	68 4e 01 00 00	 push	 334			; 0000014eH
  00b5f	68 03 04 00 00	 push	 1027			; 00000403H
  00b64	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00b67	52		 push	 edx
  00b68	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 4235 :                      if (m->palette >= num_builtin_palettes) // if user palette, read it in

  00b6e	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00b71	8b 88 f4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36340]
  00b77	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _num_builtin_palettes
  00b7d	72 05		 jb	 SHORT $LN59@man_dialog

; 4236 :                         get_user_palette();

  00b7f	e8 00 00 00 00	 call	 _get_user_palette
$LN59@man_dialog:

; 4237 :                   }
; 4238 : 
; 4239 :                   print_palette_status();

  00b84	e8 00 00 00 00	 call	 _print_palette_status

; 4240 :                   resize_window();

  00b89	e8 00 00 00 00	 call	 _resize_window

; 4241 : 
; 4242 :                   if (!cfg_settings.zoom_in_out.val) // If not zooming, just calculate

  00b8e	83 3d 40 00 00
	00 00		 cmp	 DWORD PTR _cfg_settings+64, 0
  00b95	75 2d		 jne	 SHORT $LN60@man_dialog

; 4243 :                   {
; 4244 :                      do_man_calculate(1);  // calculate all pixels, update image info

  00b97	6a 01		 push	 1
  00b99	e8 00 00 00 00	 call	 _do_man_calculate
  00b9e	83 c4 04	 add	 esp, 4

; 4245 :                      status &= ~STAT_RECALC_IMMEDIATELY; // already calculated: don't need to do again

  00ba1	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00ba6	83 e0 f7	 and	 eax, -9			; fffffff7H
  00ba9	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 4246 :                      SetFocus(hwnd_main);

  00bae	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  00bb3	50		 push	 eax
  00bb4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 4247 :                      return TRUE;

  00bba	b8 01 00 00 00	 mov	 eax, 1
  00bbf	e9 fb 00 00 00	 jmp	 $LN1@man_dialog
$LN60@man_dialog:

; 4248 :                   }
; 4249 :                   else
; 4250 :                   {
; 4251 :                      // Else fallthrough to do realtime zoom in (later need zoom out also)
; 4252 :                   }
; 4253 :                }

  00bc4	eb 0a		 jmp	 SHORT $LN55@man_dialog
$LN54@man_dialog:

; 4254 :                else
; 4255 :                   return TRUE;

  00bc6	b8 01 00 00 00	 mov	 eax, 1
  00bcb	e9 ef 00 00 00	 jmp	 $LN1@man_dialog
$LN55@man_dialog:

; 4256 : 
; 4257 :             case ID_ZOOM: // Do a realtime zoom in to the current image
; 4258 :                update_re_im(m, m->pan_xoffs, m->pan_yoffs); // update re/im from any pan offsets and reset offsets

  00bd0	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00bd3	8b 88 a4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36260]
  00bd9	51		 push	 ecx
  00bda	8b 90 a0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36256]
  00be0	52		 push	 edx
  00be1	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00be4	8b 88 9c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36252]
  00bea	51		 push	 ecx
  00beb	8b 90 98 8d 00
	00		 mov	 edx, DWORD PTR [eax+36248]
  00bf1	52		 push	 edx
  00bf2	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00bf5	50		 push	 eax
  00bf6	e8 00 00 00 00	 call	 _update_re_im
  00bfb	83 c4 14	 add	 esp, 20			; 00000014H

; 4259 :                reset_fps_values();

  00bfe	e8 00 00 00 00	 call	 _reset_fps_values

; 4260 :                reset_thread_load_counters();

  00c03	e8 00 00 00 00	 call	 _reset_thread_load_counters

; 4261 :                zoom_start_time = get_timer();

  00c08	e8 00 00 00 00	 call	 _get_timer
  00c0d	a3 00 00 00 00	 mov	 DWORD PTR _zoom_start_time, eax

; 4262 :                zoom_start_mag = m->mag;

  00c12	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00c15	f2 0f 10 80 b8
	8d 00 00	 movsd	 xmm0, QWORD PTR [eax+36280]
  00c1d	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _zoom_start_mag, xmm0

; 4263 :                m->mag = MAG_MIN;

  00c25	8b 45 a0	 mov	 eax, DWORD PTR _m$[ebp]
  00c28	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f947ae147ae147b
  00c30	f2 0f 11 80 b8
	8d 00 00	 movsd	 QWORD PTR [eax+36280], xmm0

; 4264 :                do_rtzoom = RTZOOM_IN | RTZOOM_WITH_BUTTON;

  00c38	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR _do_rtzoom, 5

; 4265 :                return TRUE;

  00c42	b8 01 00 00 00	 mov	 eax, 1
  00c47	eb 76		 jmp	 SHORT $LN1@man_dialog
$LN63@man_dialog:

; 4266 : 
; 4267 :             case ID_FULLSCREEN:
; 4268 :                toggle_fullscreen();

  00c49	e8 00 00 00 00	 call	 _toggle_fullscreen

; 4269 :                return TRUE;

  00c4e	b8 01 00 00 00	 mov	 eax, 1
  00c53	eb 6a		 jmp	 SHORT $LN1@man_dialog
$LN64@man_dialog:

; 4270 : 
; 4271 :             // case ID_SLIDESHOW:
; 4272 :             // case ID_OPTIONS:
; 4273 :                // not_implemented_yet();
; 4274 :                // return TRUE;
; 4275 : 
; 4276 :             case ID_SAVE_IMAGE:
; 4277 :                if (!(status & STAT_DOING_SAVE))

  00c55	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00c5a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00c5f	75 21		 jne	 SHORT $LN65@man_dialog

; 4278 :                {
; 4279 :                   status |= STAT_DOING_SAVE; // prevent re-entering function when already saving

  00c61	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00c66	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00c6b	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 4280 : 
; 4281 :                   // With just WT_EXECUTEDEFAULT here (by accident), got strange behavior- sometimes
; 4282 :                   // wouldn't save (created a 0K file with no error indication or status update).
; 4283 :                   // Hard to reproduce. With these two, seems ok. WT_EXECUTEINIOTHREAD necessary?
; 4284 :                   QueueUserWorkItem(do_save, NULL, WT_EXECUTELONGFUNCTION | WT_EXECUTEINIOTHREAD |

  00c70	68 11 00 43 00	 push	 4390929			; 00430011H
  00c75	6a 00		 push	 0
  00c77	68 00 00 00 00	 push	 OFFSET _do_save@4
  00c7c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueueUserWorkItem@12
$LN65@man_dialog:

; 4285 :                                             (MAX_QUEUE_THREADS << 16));
; 4286 :                }
; 4287 :                return TRUE;

  00c82	b8 01 00 00 00	 mov	 eax, 1
  00c87	eb 36		 jmp	 SHORT $LN1@man_dialog
$LN66@man_dialog:

; 4288 : 
; 4289 :             case ID_HELP_BUTTON: // MS won't generate ID_HELP
; 4290 : 
; 4291 :                // Have to do this in a separate thread just to keep the messagebox from
; 4292 :                // blocking my main window...
; 4293 : 
; 4294 :                if (!(status & STAT_HELP_SHOWING))  // don't show help box if it's already showing

  00c89	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00c8e	83 e0 40	 and	 eax, 64			; 00000040H
  00c91	75 1f		 jne	 SHORT $LN67@man_dialog

; 4295 :                {
; 4296 :                   status |= STAT_HELP_SHOWING;

  00c93	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00c98	83 c8 40	 or	 eax, 64			; 00000040H
  00c9b	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 4297 :                   QueueUserWorkItem(show_help, NULL, WT_EXECUTELONGFUNCTION | (MAX_QUEUE_THREADS << 16));

  00ca0	68 10 00 43 00	 push	 4390928			; 00430010H
  00ca5	6a 00		 push	 0
  00ca7	68 00 00 00 00	 push	 OFFSET _show_help@4
  00cac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueueUserWorkItem@12
$LN67@man_dialog:

; 4298 :                }
; 4299 :                return TRUE;

  00cb2	b8 01 00 00 00	 mov	 eax, 1
  00cb7	eb 06		 jmp	 SHORT $LN1@man_dialog
$LN68@man_dialog:

; 4300 : 
; 4301 :             default:
; 4302 :                return FALSE;

  00cb9	33 c0		 xor	 eax, eax
  00cbb	eb 02		 jmp	 SHORT $LN1@man_dialog
$LN2@man_dialog:

; 4303 :          }
; 4304 :          break;
; 4305 : 
; 4306 :       case WM_CLOSE:    // Never close or destroy this dialog
; 4307 :          break;
; 4308 :       case WM_DESTROY:
; 4309 :          break;
; 4310 :    }
; 4311 :    return FALSE; // return FALSE if we didn't process the message (exceptions for INITDIALOG) otherwise TRUE

  00cbd	33 c0		 xor	 eax, eax
$LN1@man_dialog:

; 4312 : }

  00cbf	5f		 pop	 edi
  00cc0	5e		 pop	 esi
  00cc1	5b		 pop	 ebx
  00cc2	8b e5		 mov	 esp, ebp
  00cc4	5d		 pop	 ebp
  00cc5	c2 10 00	 ret	 16			; 00000010H
$LN79@man_dialog:
  00cc8	00 00 00 00	 DD	 $LN11@man_dialog
  00ccc	00 00 00 00	 DD	 $LN23@man_dialog
  00cd0	00 00 00 00	 DD	 $LN2@man_dialog
  00cd4	00 00 00 00	 DD	 $LN2@man_dialog
  00cd8	00 00 00 00	 DD	 $LN20@man_dialog
  00cdc	00 00 00 00	 DD	 $LN15@man_dialog
$LN80@man_dialog:
  00ce0	00 00 00 00	 DD	 $LN48@man_dialog
  00ce4	00 00 00 00	 DD	 $LN55@man_dialog
  00ce8	00 00 00 00	 DD	 $LN47@man_dialog
  00cec	00 00 00 00	 DD	 $LN63@man_dialog
  00cf0	00 00 00 00	 DD	 $LN46@man_dialog
  00cf4	00 00 00 00	 DD	 $LN64@man_dialog
  00cf8	00 00 00 00	 DD	 $LN68@man_dialog
$LN77@man_dialog:
  00cfc	00		 DB	 0
  00cfd	00		 DB	 0
  00cfe	06		 DB	 6
  00cff	01		 DB	 1
  00d00	02		 DB	 2
  00d01	03		 DB	 3
  00d02	00		 DB	 0
  00d03	06		 DB	 6
  00d04	04		 DB	 4
  00d05	06		 DB	 6
  00d06	06		 DB	 6
  00d07	06		 DB	 6
  00d08	05		 DB	 5
  00d09	0f 1f 00	 npad	 3
$LN81@man_dialog:
  00d0c	00 00 00 00	 DD	 $LN27@man_dialog
  00d10	00 00 00 00	 DD	 $LN33@man_dialog
  00d14	00 00 00 00	 DD	 $LN35@man_dialog
  00d18	00 00 00 00	 DD	 $LN24@man_dialog
  00d1c	00 00 00 00	 DD	 $LN66@man_dialog
  00d20	00 00 00 00	 DD	 $LN37@man_dialog
  00d24	00 00 00 00	 DD	 $LN68@man_dialog
$LN78@man_dialog:
  00d28	00		 DB	 0
  00d29	00		 DB	 0
  00d2a	01		 DB	 1
  00d2b	02		 DB	 2
  00d2c	03		 DB	 3
  00d2d	06		 DB	 6
  00d2e	06		 DB	 6
  00d2f	06		 DB	 6
  00d30	06		 DB	 6
  00d31	06		 DB	 6
  00d32	06		 DB	 6
  00d33	06		 DB	 6
  00d34	06		 DB	 6
  00d35	06		 DB	 6
  00d36	06		 DB	 6
  00d37	06		 DB	 6
  00d38	06		 DB	 6
  00d39	06		 DB	 6
  00d3a	06		 DB	 6
  00d3b	06		 DB	 6
  00d3c	06		 DB	 6
  00d3d	06		 DB	 6
  00d3e	06		 DB	 6
  00d3f	06		 DB	 6
  00d40	06		 DB	 6
  00d41	04		 DB	 4
  00d42	06		 DB	 6
  00d43	06		 DB	 6
  00d44	06		 DB	 6
  00d45	06		 DB	 6
  00d46	06		 DB	 6
  00d47	06		 DB	 6
  00d48	06		 DB	 6
  00d49	06		 DB	 6
  00d4a	06		 DB	 6
  00d4b	06		 DB	 6
  00d4c	06		 DB	 6
  00d4d	06		 DB	 6
  00d4e	06		 DB	 6
  00d4f	06		 DB	 6
  00d50	06		 DB	 6
  00d51	05		 DB	 5
  00d52	05		 DB	 5
_man_dialog_proc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _do_save@4
_TEXT	SEGMENT
tv395 = -376						; size = 8
tv291 = -376						; size = 8
tv277 = -376						; size = 8
tv144 = -372						; size = 4
_s$ = -304						; size = 4
_m$ = -300						; size = 4
_t$ = -296						; size = 4
_start_time$ = -292					; size = 4
_fp$ = -288						; size = 4
_c$ = -284						; size = 256
_ptr4$ = -28						; size = 4
_ptr3$ = -24						; size = 4
_save_ysize$ = -20					; size = 4
_save_xsize$ = -16					; size = 4
_n$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_param$ = 8						; size = 4
_do_save@4 PROC						; COMDAT

; 3801 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 01 00
	00		 sub	 esp, 376		; 00000178H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3802 :    int i, j, n, save_xsize, save_ysize;
; 3803 :    unsigned char *ptr3, *ptr4, c[256];
; 3804 :    FILE *fp;
; 3805 : 
; 3806 :    TIME_UNIT start_time, t;
; 3807 :    man_calc_struct *m, *s;
; 3808 : 
; 3809 :    m = &main_man_calc_struct;

  0000c	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3810 :    s = &save_man_calc_struct;

  00016	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$[ebp], OFFSET _save_man_calc_struct

; 3811 : 
; 3812 :    // Get sizes for image save, and clip
; 3813 :    if ((save_xsize = GetDlgItemInt(hwnd_dialog, IDC_SAVE_XSIZE, NULL, FALSE)) < MIN_SIZE)

  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	68 2c 04 00 00	 push	 1068			; 0000042cH
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemInt@16
  00035	89 45 f0	 mov	 DWORD PTR _save_xsize$[ebp], eax
  00038	83 7d f0 04	 cmp	 DWORD PTR _save_xsize$[ebp], 4
  0003c	7d 07		 jge	 SHORT $LN8@do_save

; 3814 :       save_xsize = MIN_SIZE;

  0003e	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _save_xsize$[ebp], 4
$LN8@do_save:

; 3815 :    if ((save_ysize = GetDlgItemInt(hwnd_dialog, IDC_SAVE_YSIZE, NULL, FALSE)) < MIN_SIZE)

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	68 2d 04 00 00	 push	 1069			; 0000042dH
  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemInt@16
  0005a	89 45 ec	 mov	 DWORD PTR _save_ysize$[ebp], eax
  0005d	83 7d ec 04	 cmp	 DWORD PTR _save_ysize$[ebp], 4
  00061	7d 07		 jge	 SHORT $LN9@do_save

; 3816 :       save_ysize = MIN_SIZE;

  00063	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _save_ysize$[ebp], 4
$LN9@do_save:

; 3817 : 
; 3818 :    // Get filename and add .png extension if not already present
; 3819 :    GetDlgItemText(hwnd_dialog, IDC_SAVEFILE, savefile, sizeof(savefile));

  0006a	68 00 01 00 00	 push	 256			; 00000100H
  0006f	68 00 00 00 00	 push	 OFFSET _savefile
  00074	68 2e 04 00 00	 push	 1070			; 0000042eH
  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  0007e	50		 push	 eax
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemTextA@16

; 3820 :    n = (int) strlen(savefile);

  00085	68 00 00 00 00	 push	 OFFSET _savefile
  0008a	e8 00 00 00 00	 call	 _strlen
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax

; 3821 :    if (n < 4 || _strnicmp(&savefile[n - 4], ".png", 4))

  00095	83 7d f4 04	 cmp	 DWORD PTR _n$[ebp], 4
  00099	7c 1d		 jl	 SHORT $LN11@do_save
  0009b	6a 04		 push	 4
  0009d	68 00 00 00 00	 push	 OFFSET $SG41859
  000a2	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  000a5	8d 88 fc ff ff
	ff		 lea	 ecx, DWORD PTR _savefile[eax-4]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 __strnicmp
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	85 c0		 test	 eax, eax
  000b6	74 17		 je	 SHORT $LN10@do_save
$LN11@do_save:

; 3822 :       strcat_s(savefile, sizeof(savefile), ".png");

  000b8	68 00 00 00 00	 push	 OFFSET $SG41860
  000bd	68 00 01 00 00	 push	 256			; 00000100H
  000c2	68 00 00 00 00	 push	 OFFSET _savefile
  000c7	e8 00 00 00 00	 call	 _strcat_s
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@do_save:

; 3823 : 
; 3824 :    s->xsize = save_xsize;

  000cf	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  000d5	8b 4d f0	 mov	 ecx, DWORD PTR _save_xsize$[ebp]
  000d8	89 88 88 8d 00
	00		 mov	 DWORD PTR [eax+36232], ecx

; 3825 :    s->ysize = 1;

  000de	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  000e4	c7 80 8c 8d 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+36236], 1

; 3826 : 
; 3827 :    // Copy relevant image parameters to the save calculation structure from the main structure
; 3828 :    // (whose image is currently displayed).
; 3829 : 
; 3830 :    // Get saved image re/im from the main re/im + pan offsets
; 3831 :    s->re = m->re + get_re_im_offs(m, m->pan_xoffs);

  000ee	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  000f4	8b 88 9c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36252]
  000fa	51		 push	 ecx
  000fb	8b 90 98 8d 00
	00		 mov	 edx, DWORD PTR [eax+36248]
  00101	52		 push	 edx
  00102	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _get_re_im_offs
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00111	dd 9d 88 fe ff
	ff		 fstp	 QWORD PTR tv277[ebp]
  00117	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  0011d	f2 0f 10 85 88
	fe ff ff	 movsd	 xmm0, QWORD PTR tv277[ebp]
  00125	f2 0f 58 81 a8
	8d 00 00	 addsd	 xmm0, QWORD PTR [ecx+36264]
  0012d	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00133	f2 0f 11 82 a8
	8d 00 00	 movsd	 QWORD PTR [edx+36264], xmm0

; 3832 :    s->im = m->im - get_re_im_offs(m, m->pan_yoffs);

  0013b	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00141	8b 88 a4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36260]
  00147	51		 push	 ecx
  00148	8b 90 a0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36256]
  0014e	52		 push	 edx
  0014f	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 _get_re_im_offs
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015e	dd 9d 88 fe ff
	ff		 fstp	 QWORD PTR tv291[ebp]
  00164	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  0016a	f2 0f 10 81 b0
	8d 00 00	 movsd	 xmm0, QWORD PTR [ecx+36272]
  00172	f2 0f 5c 85 88
	fe ff ff	 subsd	 xmm0, QWORD PTR tv291[ebp]
  0017a	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00180	f2 0f 11 82 b0
	8d 00 00	 movsd	 QWORD PTR [edx+36272], xmm0

; 3833 : 
; 3834 :    // min_dimension is used to calc. coords- needs to reflect the actual ysize
; 3835 :    s->min_dimension = (save_xsize > save_ysize) ? save_ysize : save_xsize;

  00188	8b 45 f0	 mov	 eax, DWORD PTR _save_xsize$[ebp]
  0018b	3b 45 ec	 cmp	 eax, DWORD PTR _save_ysize$[ebp]
  0018e	7e 0b		 jle	 SHORT $LN18@do_save
  00190	8b 4d ec	 mov	 ecx, DWORD PTR _save_ysize$[ebp]
  00193	89 8d 8c fe ff
	ff		 mov	 DWORD PTR tv144[ebp], ecx
  00199	eb 09		 jmp	 SHORT $LN19@do_save
$LN18@do_save:
  0019b	8b 55 f0	 mov	 edx, DWORD PTR _save_xsize$[ebp]
  0019e	89 95 8c fe ff
	ff		 mov	 DWORD PTR tv144[ebp], edx
$LN19@do_save:
  001a4	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  001aa	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR tv144[ebp]
  001b0	89 88 90 8d 00
	00		 mov	 DWORD PTR [eax+36240], ecx

; 3836 :    s->mag = m->mag;

  001b6	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  001bc	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  001c2	f2 0f 10 81 b8
	8d 00 00	 movsd	 xmm0, QWORD PTR [ecx+36280]
  001ca	f2 0f 11 80 b8
	8d 00 00	 movsd	 QWORD PTR [eax+36280], xmm0

; 3837 :    s->max_iters = s->max_iters_last = m->max_iters;

  001d2	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  001d8	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  001de	8b 91 c0 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36288]
  001e4	89 90 c4 8d 00
	00		 mov	 DWORD PTR [eax+36292], edx
  001ea	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  001f0	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  001f6	8b 91 c4 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36292]
  001fc	89 90 c0 8d 00
	00		 mov	 DWORD PTR [eax+36288], edx

; 3838 : 
; 3839 :    // Can get unexpected precision loss when the saved image is larger than the on-screen image.
; 3840 :    // Always use best precision to minimize occurrences
; 3841 :    s->precision = PRECISION_DOUBLE; // m->precision

  00202	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00208	c7 80 d0 8d 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+36304], 2

; 3842 :    s->alg = m->alg | ALG_EXACT;     // exact will be faster for 1-pixel high rows. Want for best quality anyway.

  00212	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00218	8b 88 c8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36296]
  0021e	83 c9 01	 or	 ecx, 1
  00221	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00227	89 8a c8 8d 00
	00		 mov	 DWORD PTR [edx+36296], ecx

; 3843 :    s->palette = m->palette;

  0022d	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00233	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00239	8b 91 f4 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36340]
  0023f	89 90 f4 8d 00
	00		 mov	 DWORD PTR [eax+36340], edx

; 3844 :    s->prev_pal = 0xFFFFFFFF;        // always recalc. pal lookup table before starting

  00245	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0024b	c7 80 f8 8d 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+36344], -1

; 3845 :    s->pal_xor = m->pal_xor;

  00255	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0025b	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00261	8b 91 fc 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36348]
  00267	89 90 fc 8d 00
	00		 mov	 DWORD PTR [eax+36348], edx

; 3846 :    s->max_iters_color = m->max_iters_color;

  0026d	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00273	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00279	8b 91 00 8e 00
	00		 mov	 edx, DWORD PTR [ecx+36352]
  0027f	89 90 00 8e 00
	00		 mov	 DWORD PTR [eax+36352], edx

; 3847 :    s->rendering_alg = m->rendering_alg;

  00285	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0028b	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00291	8b 91 04 8e 00
	00		 mov	 edx, DWORD PTR [ecx+36356]
  00297	89 90 04 8e 00
	00		 mov	 DWORD PTR [eax+36356], edx

; 3848 :    s->flags |= FLAG_CALC_RE_ARRAY;  // tell man_calculate to calculate the real array initially

  0029d	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  002a3	8b 88 0c 93 02
	00		 mov	 ecx, DWORD PTR [eax+168716]
  002a9	83 c9 02	 or	 ecx, 2
  002ac	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  002b2	89 8a 0c 93 02
	00		 mov	 DWORD PTR [edx+168716], ecx

; 3849 : 
; 3850 :    // Make sure all image data above is already captured before possibly popping a message
; 3851 :    // box. Because this func is in a separate thread, the image can be modified (panned, etc)
; 3852 :    // while the box is open.
; 3853 : 
; 3854 :    // If file already exists, ask user to confirm overwite
; 3855 :    if (!fopen_s(&fp, savefile, "rb"))

  002b8	68 00 00 00 00	 push	 OFFSET $SG41862
  002bd	68 00 00 00 00	 push	 OFFSET _savefile
  002c2	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _fp$[ebp]
  002c8	50		 push	 eax
  002c9	e8 00 00 00 00	 call	 _fopen_s
  002ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d1	85 c0		 test	 eax, eax
  002d3	75 61		 jne	 SHORT $LN13@do_save

; 3856 :    {
; 3857 :       fclose(fp);

  002d5	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  002db	50		 push	 eax
  002dc	e8 00 00 00 00	 call	 _fclose
  002e1	83 c4 04	 add	 esp, 4

; 3858 :       sprintf_s(c, sizeof(c), "%s already exists. Overwrite?", savefile);

  002e4	68 00 00 00 00	 push	 OFFSET _savefile
  002e9	68 00 00 00 00	 push	 OFFSET $SG41863
  002ee	68 00 01 00 00	 push	 256			; 00000100H
  002f3	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _c$[ebp]
  002f9	50		 push	 eax
  002fa	e8 00 00 00 00	 call	 _sprintf_s
  002ff	83 c4 10	 add	 esp, 16			; 00000010H

; 3859 :       if (MessageBox(NULL, c, "Warning", MB_YESNO | MB_ICONWARNING | MB_TASKMODAL) != IDYES)

  00302	68 34 20 00 00	 push	 8244			; 00002034H
  00307	68 00 00 00 00	 push	 OFFSET $SG41865
  0030c	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _c$[ebp]
  00312	50		 push	 eax
  00313	6a 00		 push	 0
  00315	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  0031b	83 f8 06	 cmp	 eax, 6
  0031e	74 16		 je	 SHORT $LN13@do_save

; 3860 :       {
; 3861 :          status &= ~STAT_DOING_SAVE;

  00320	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00325	25 7f ff ff ff	 and	 eax, -129		; ffffff7fH
  0032a	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 3862 :          return 0;

  0032f	33 c0		 xor	 eax, eax
  00331	e9 7c 02 00 00	 jmp	 $LN1@do_save
$LN13@do_save:

; 3863 :       }
; 3864 :    }
; 3865 : 
; 3866 :    if (!png_save_start(savefile, save_xsize, save_ysize))

  00336	8b 45 ec	 mov	 eax, DWORD PTR _save_ysize$[ebp]
  00339	50		 push	 eax
  0033a	8b 4d f0	 mov	 ecx, DWORD PTR _save_xsize$[ebp]
  0033d	51		 push	 ecx
  0033e	68 00 00 00 00	 push	 OFFSET _savefile
  00343	e8 00 00 00 00	 call	 _png_save_start
  00348	83 c4 0c	 add	 esp, 12			; 0000000cH
  0034b	85 c0		 test	 eax, eax
  0034d	75 16		 jne	 SHORT $LN14@do_save

; 3867 :    {
; 3868 :       status &= ~STAT_DOING_SAVE;

  0034f	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00354	25 7f ff ff ff	 and	 eax, -129		; ffffff7fH
  00359	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 3869 :       return 0;

  0035e	33 c0		 xor	 eax, eax
  00360	e9 4d 02 00 00	 jmp	 $LN1@do_save
$LN14@do_save:

; 3870 :    }
; 3871 : 
; 3872 :    free_man_mem(s); // free any existing arrays and alloc new arrays

  00365	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0036b	50		 push	 eax
  0036c	e8 00 00 00 00	 call	 _free_man_mem
  00371	83 c4 04	 add	 esp, 4

; 3873 :    alloc_man_mem(s, save_xsize, 1);

  00374	6a 01		 push	 1
  00376	8b 45 f0	 mov	 eax, DWORD PTR _save_xsize$[ebp]
  00379	50		 push	 eax
  0037a	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00380	51		 push	 ecx
  00381	e8 00 00 00 00	 call	 _alloc_man_mem
  00386	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3874 : 
; 3875 :    start_time = t = get_timer();

  00389	e8 00 00 00 00	 call	 _get_timer
  0038e	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _t$[ebp], eax
  00394	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  0039a	89 85 dc fe ff
	ff		 mov	 DWORD PTR _start_time$[ebp], eax

; 3876 : 
; 3877 :    s->pan_yoffs = -((save_ysize - 1) >> 1); // pan_yoffs of image top

  003a0	8b 45 ec	 mov	 eax, DWORD PTR _save_ysize$[ebp]
  003a3	83 e8 01	 sub	 eax, 1
  003a6	d1 f8		 sar	 eax, 1
  003a8	f7 d8		 neg	 eax
  003aa	99		 cdq
  003ab	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  003b1	89 81 a0 8d 00
	00		 mov	 DWORD PTR [ecx+36256], eax
  003b7	89 91 a4 8d 00
	00		 mov	 DWORD PTR [ecx+36260], edx

; 3878 :    for (i = 0; i < save_ysize; i++)

  003bd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  003c4	eb 09		 jmp	 SHORT $LN4@do_save
$LN2@do_save:
  003c6	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003c9	83 c0 01	 add	 eax, 1
  003cc	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@do_save:
  003cf	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003d2	3b 45 ec	 cmp	 eax, DWORD PTR _save_ysize$[ebp]
  003d5	0f 8d 7f 01 00
	00		 jge	 $LN3@do_save

; 3879 :    {
; 3880 :       man_calculate(s, 0, save_xsize - 1, 0, 0); // iterate the row

  003db	6a 00		 push	 0
  003dd	6a 00		 push	 0
  003df	8b 45 f0	 mov	 eax, DWORD PTR _save_xsize$[ebp]
  003e2	83 e8 01	 sub	 eax, 1
  003e5	50		 push	 eax
  003e6	6a 00		 push	 0
  003e8	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  003ee	51		 push	 ecx
  003ef	e8 00 00 00 00	 call	 _man_calculate
  003f4	dd d8		 fstp	 ST(0)
  003f6	83 c4 14	 add	 esp, 20			; 00000014H

; 3881 :       s->flags &= ~FLAG_CALC_RE_ARRAY; // don't have to recalculate real array on subsequent rows

  003f9	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  003ff	8b 88 0c 93 02
	00		 mov	 ecx, DWORD PTR [eax+168716]
  00405	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00408	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  0040e	89 8a 0c 93 02
	00		 mov	 DWORD PTR [edx+168716], ecx

; 3882 : 
; 3883 :       // Palette-map the iteration counts to RGB data in png_buffer. Magnitudes are also available here.
; 3884 :       apply_palette(s, (unsigned *) s->png_buffer, s->iter_data, save_xsize, 1);

  00414	6a 01		 push	 1
  00416	8b 45 f0	 mov	 eax, DWORD PTR _save_xsize$[ebp]
  00419	50		 push	 eax
  0041a	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00420	8b 91 e0 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36320]
  00426	52		 push	 edx
  00427	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0042d	8b 88 f0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36336]
  00433	51		 push	 ecx
  00434	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  0043a	52		 push	 edx
  0043b	e8 00 00 00 00	 call	 _apply_palette
  00440	83 c4 14	 add	 esp, 20			; 00000014H

; 3885 : 
; 3886 :       // Convert the 4 bytes-per-pixel data in png_buffer to 3 bpp, as required by pnglib, and write rows
; 3887 :       ptr3 = ptr4 = s->png_buffer;

  00443	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00449	8b 88 f0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36336]
  0044f	89 4d e4	 mov	 DWORD PTR _ptr4$[ebp], ecx
  00452	8b 55 e4	 mov	 edx, DWORD PTR _ptr4$[ebp]
  00455	89 55 e8	 mov	 DWORD PTR _ptr3$[ebp], edx

; 3888 :       for (j = 0; j < save_xsize; j++)

  00458	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0045f	eb 09		 jmp	 SHORT $LN7@do_save
$LN5@do_save:
  00461	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00464	83 c0 01	 add	 eax, 1
  00467	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN7@do_save:
  0046a	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0046d	3b 45 f0	 cmp	 eax, DWORD PTR _save_xsize$[ebp]
  00470	7d 1e		 jge	 SHORT $LN6@do_save

; 3889 :       {
; 3890 :          *((unsigned *) ptr3) = *((unsigned *) ptr4);

  00472	8b 45 e8	 mov	 eax, DWORD PTR _ptr3$[ebp]
  00475	8b 4d e4	 mov	 ecx, DWORD PTR _ptr4$[ebp]
  00478	8b 11		 mov	 edx, DWORD PTR [ecx]
  0047a	89 10		 mov	 DWORD PTR [eax], edx

; 3891 :          ptr3 += 3;

  0047c	8b 45 e8	 mov	 eax, DWORD PTR _ptr3$[ebp]
  0047f	83 c0 03	 add	 eax, 3
  00482	89 45 e8	 mov	 DWORD PTR _ptr3$[ebp], eax

; 3892 :          ptr4 += 4;

  00485	8b 45 e4	 mov	 eax, DWORD PTR _ptr4$[ebp]
  00488	83 c0 04	 add	 eax, 4
  0048b	89 45 e4	 mov	 DWORD PTR _ptr4$[ebp], eax

; 3893 :       }

  0048e	eb d1		 jmp	 SHORT $LN5@do_save
$LN6@do_save:

; 3894 :       if (!png_save_write_row(s->png_buffer))  // write the row

  00490	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00496	8b 88 f0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36336]
  0049c	51		 push	 ecx
  0049d	e8 00 00 00 00	 call	 _png_save_write_row
  004a2	83 c4 04	 add	 esp, 4
  004a5	85 c0		 test	 eax, eax
  004a7	75 05		 jne	 SHORT $LN15@do_save

; 3895 :          break;

  004a9	e9 ac 00 00 00	 jmp	 $LN3@do_save
$LN15@do_save:

; 3896 : 
; 3897 :       s->pan_yoffs++;       // go to next row

  004ae	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  004b4	8b 88 a0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36256]
  004ba	83 c1 01	 add	 ecx, 1
  004bd	8b 90 a4 8d 00
	00		 mov	 edx, DWORD PTR [eax+36260]
  004c3	83 d2 00	 adc	 edx, 0
  004c6	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  004cc	89 88 a0 8d 00
	00		 mov	 DWORD PTR [eax+36256], ecx
  004d2	89 90 a4 8d 00
	00		 mov	 DWORD PTR [eax+36260], edx

; 3898 : 
; 3899 :       if (get_seconds_elapsed(t) > 0.5) // print progress indicator every 0.5s

  004d8	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  004de	50		 push	 eax
  004df	e8 00 00 00 00	 call	 _get_seconds_elapsed
  004e4	83 c4 04	 add	 esp, 4
  004e7	dd 9d 88 fe ff
	ff		 fstp	 QWORD PTR tv395[ebp]
  004ed	f2 0f 10 85 88
	fe ff ff	 movsd	 xmm0, QWORD PTR tv395[ebp]
  004f5	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3fe0000000000000
  004fd	76 56		 jbe	 SHORT $LN16@do_save

; 3900 :       {
; 3901 :          sprintf_s(c, sizeof(c), "Saving... (%3.1f%%)", 100.0 * (double) i / (double) save_ysize);

  004ff	f2 0f 2a 45 fc	 cvtsi2sd xmm0, DWORD PTR _i$[ebp]
  00504	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  0050c	f2 0f 2a 4d ec	 cvtsi2sd xmm1, DWORD PTR _save_ysize$[ebp]
  00511	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00515	83 ec 08	 sub	 esp, 8
  00518	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0051d	68 00 00 00 00	 push	 OFFSET $SG41869
  00522	68 00 01 00 00	 push	 256			; 00000100H
  00527	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _c$[ebp]
  0052d	50		 push	 eax
  0052e	e8 00 00 00 00	 call	 _sprintf_s
  00533	83 c4 14	 add	 esp, 20			; 00000014H

; 3902 :          SetWindowText(hwnd_status, c);

  00536	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _c$[ebp]
  0053c	50		 push	 eax
  0053d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_status
  00543	51		 push	 ecx
  00544	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 3903 :          t = get_timer();

  0054a	e8 00 00 00 00	 call	 _get_timer
  0054f	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _t$[ebp], eax
$LN16@do_save:

; 3904 :       }
; 3905 :    }

  00555	e9 6c fe ff ff	 jmp	 $LN2@do_save
$LN3@do_save:

; 3906 : 
; 3907 :    png_save_end();

  0055a	e8 00 00 00 00	 call	 _png_save_end

; 3908 :    sprintf_s(c, sizeof(c), "Saved in %.1fs", get_seconds_elapsed(start_time));

  0055f	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _start_time$[ebp]
  00565	50		 push	 eax
  00566	e8 00 00 00 00	 call	 _get_seconds_elapsed
  0056b	83 c4 fc	 add	 esp, -4			; fffffffcH
  0056e	dd 1c 24	 fstp	 QWORD PTR [esp]
  00571	68 00 00 00 00	 push	 OFFSET $SG41870
  00576	68 00 01 00 00	 push	 256			; 00000100H
  0057b	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _c$[ebp]
  00581	51		 push	 ecx
  00582	e8 00 00 00 00	 call	 _sprintf_s
  00587	83 c4 14	 add	 esp, 20			; 00000014H

; 3909 :    SetWindowText(hwnd_status, c);

  0058a	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _c$[ebp]
  00590	50		 push	 eax
  00591	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_status
  00597	51		 push	 ecx
  00598	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 3910 : 
; 3911 :    status &= ~STAT_DOING_SAVE;

  0059e	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  005a3	25 7f ff ff ff	 and	 eax, -129		; ffffff7fH
  005a8	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 3912 :    return 1;

  005ad	b8 01 00 00 00	 mov	 eax, 1
$LN1@do_save:

; 3913 : }

  005b2	5f		 pop	 edi
  005b3	5e		 pop	 esi
  005b4	5b		 pop	 ebx
  005b5	8b e5		 mov	 esp, ebp
  005b7	5d		 pop	 ebp
  005b8	c2 04 00	 ret	 4
_do_save@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _resize_window
_TEXT	SEGMENT
_resize_window PROC					; COMDAT

; 3766 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3767 :    if (!(status & STAT_FULLSCREEN))

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  0000e	83 e0 04	 and	 eax, 4
  00011	0f 85 97 00 00
	00		 jne	 $LN2@resize_win

; 3768 :    {
; 3769 :       // xsize 0: fullscreen (other values < MIN_SIZE can be used later)
; 3770 :       if (cfg_settings.xsize.val < MIN_SIZE)

  00017	83 3d 54 00 00
	00 04		 cmp	 DWORD PTR _cfg_settings+84, 4
  0001e	7d 0a		 jge	 SHORT $LN4@resize_win

; 3771 :          toggle_fullscreen();

  00020	e8 00 00 00 00	 call	 _toggle_fullscreen
  00025	e9 82 00 00 00	 jmp	 $LN5@resize_win
$LN4@resize_win:

; 3772 :       else if (cfg_settings.ysize.val >= MIN_SIZE && // ignore any restoring ysize = 0

  0002a	83 3d 68 00 00
	00 04		 cmp	 DWORD PTR _cfg_settings+104, 4
  00031	7c 79		 jl	 SHORT $LN5@resize_win
  00033	a1 54 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+84
  00038	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _prev_xsize
  0003e	75 0d		 jne	 SHORT $LN7@resize_win
  00040	a1 68 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+104
  00045	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _prev_ysize
  0004b	74 5f		 je	 SHORT $LN5@resize_win
$LN7@resize_win:

; 3773 :               (cfg_settings.xsize.val != prev_xsize || cfg_settings.ysize.val != prev_ysize))
; 3774 :       {
; 3775 :          // Without this, you can change the size of a maximized window, which puts
; 3776 :          // it into a bad state (can't resize)
; 3777 :          ShowWindow(hwnd_main, SW_RESTORE);

  0004d	6a 09		 push	 9
  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 3778 :          SetWindowPos(hwnd_main, HWND_TOP, 0, 0, cfg_settings.xsize.val + x_border,

  0005b	68 02 01 00 00	 push	 258			; 00000102H
  00060	a1 68 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+104
  00065	03 05 00 00 00
	00		 add	 eax, DWORD PTR _y_border
  0006b	50		 push	 eax
  0006c	8b 0d 54 00 00
	00		 mov	 ecx, DWORD PTR _cfg_settings+84
  00072	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _x_border
  00078	51		 push	 ecx
  00079	6a 00		 push	 0
  0007b	6a 00		 push	 0
  0007d	6a 00		 push	 0
  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hwnd_main
  00085	52		 push	 edx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 3779 :                       cfg_settings.ysize.val + y_border, SWP_NOMOVE | SWP_NOCOPYBITS);
; 3780 :          UpdateWindow(hwnd_main); // not sure why this is necessary. Sizes get out of sync?

  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UpdateWindow@4

; 3781 : 
; 3782 :          prev_xsize = cfg_settings.xsize.val; // Save previous size

  00098	a1 54 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+84
  0009d	a3 00 00 00 00	 mov	 DWORD PTR _prev_xsize, eax

; 3783 :          prev_ysize = cfg_settings.ysize.val; // Can't do this in create_bitmap

  000a2	a1 68 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+104
  000a7	a3 00 00 00 00	 mov	 DWORD PTR _prev_ysize, eax
$LN5@resize_win:

; 3784 :       }
; 3785 :    }

  000ac	eb 0e		 jmp	 SHORT $LN1@resize_win
$LN2@resize_win:

; 3786 :    else // If in fullscreen mode: only allow restore
; 3787 :       if (cfg_settings.ysize.val < MIN_SIZE)

  000ae	83 3d 68 00 00
	00 04		 cmp	 DWORD PTR _cfg_settings+104, 4
  000b5	7d 05		 jge	 SHORT $LN1@resize_win

; 3788 :          toggle_fullscreen();

  000b7	e8 00 00 00 00	 call	 _toggle_fullscreen
$LN1@resize_win:

; 3789 : }

  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_resize_window ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _show_help@4
_TEXT	SEGMENT
_param$ = 8						; size = 4
_show_help@4 PROC					; COMDAT

; 3754 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3755 :    // Using MB_TOPMOST gives an old window style... need to use SYSTEMMODAL, but then we get
; 3756 :    // an annoying icon on the title bar
; 3757 :    MessageBox(NULL, help_text, "QuickMAN Help", MB_OK | MB_ICONINFORMATION | MB_SYSTEMMODAL);

  00009	68 40 10 00 00	 push	 4160			; 00001040H
  0000e	68 00 00 00 00	 push	 OFFSET $SG41807
  00013	68 00 00 00 00	 push	 OFFSET _help_text
  00018	6a 00		 push	 0
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 3758 :    status &= ~STAT_HELP_SHOWING;

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00025	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00028	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 3759 :    return 0;

  0002d	33 c0		 xor	 eax, eax

; 3760 : }

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_show_help@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _toggle_fullscreen
_TEXT	SEGMENT
_toggle_fullscreen PROC					; COMDAT

; 3727 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3728 :    if ((status ^= STAT_FULLSCREEN) & STAT_FULLSCREEN)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  0000e	83 f0 04	 xor	 eax, 4
  00011	a3 00 00 00 00	 mov	 DWORD PTR _status, eax
  00016	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _status
  0001c	83 e1 04	 and	 ecx, 4
  0001f	74 52		 je	 SHORT $LN2@toggle_ful

; 3729 :    {
; 3730 :       // Hide dialog on entry to fullscreen mode, if so configured
; 3731 :       if (!(cfg_settings.options.val & OPT_DIALOG_IN_FULLSCREEN))

  00021	a1 a4 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+164
  00026	83 e0 02	 and	 eax, 2
  00029	75 0d		 jne	 SHORT $LN4@toggle_ful

; 3732 :          status |= STAT_DIALOG_HIDDEN;

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00030	83 c8 10	 or	 eax, 16			; 00000010H
  00033	a3 00 00 00 00	 mov	 DWORD PTR _status, eax
$LN4@toggle_ful:

; 3733 : 
; 3734 :       SetWindowLongPtr(hwnd_main, GWL_STYLE, WS_POPUP | WS_VISIBLE);

  00038	68 00 00 00 90	 push	 -1879048192		; 90000000H
  0003d	6a f0		 push	 -16			; fffffff0H
  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  00044	50		 push	 eax
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12

; 3735 :       SetWindowPos(hwnd_main, NULL, 0, 0, GetSystemMetrics(SM_CXSCREEN),

  0004b	6a 24		 push	 36			; 00000024H
  0004d	6a 01		 push	 1
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  00055	50		 push	 eax
  00056	6a 00		 push	 0
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  0005e	50		 push	 eax
  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	6a 00		 push	 0
  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  0006a	50		 push	 eax
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 3736 :                    GetSystemMetrics(SM_CYSCREEN), SWP_DRAWFRAME | SWP_NOZORDER);
; 3737 :    }

  00071	eb 57		 jmp	 SHORT $LN3@toggle_ful
$LN2@toggle_ful:

; 3738 :    else // exit
; 3739 :    {
; 3740 :       status &= ~STAT_DIALOG_HIDDEN; // always show dialog when coming out of fullscreen

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00078	83 e0 ef	 and	 eax, -17		; ffffffefH
  0007b	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 3741 : 
; 3742 :       SetWindowLongPtr(hwnd_main, GWL_STYLE, WS_OVERLAPPEDWINDOW | WS_VISIBLE);

  00080	68 00 00 cf 10	 push	 282001408		; 10cf0000H
  00085	6a f0		 push	 -16			; fffffff0H
  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  0008c	50		 push	 eax
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12

; 3743 :       SetWindowPos(hwnd_main, NULL, main_rect.left, main_rect.top,

  00093	6a 04		 push	 4
  00095	a1 0c 00 00 00	 mov	 eax, DWORD PTR _main_rect+12
  0009a	2b 05 04 00 00
	00		 sub	 eax, DWORD PTR _main_rect+4
  000a0	50		 push	 eax
  000a1	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _main_rect+8
  000a7	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _main_rect
  000ad	51		 push	 ecx
  000ae	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _main_rect+4
  000b4	52		 push	 edx
  000b5	a1 00 00 00 00	 mov	 eax, DWORD PTR _main_rect
  000ba	50		 push	 eax
  000bb	6a 00		 push	 0
  000bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_main
  000c3	51		 push	 ecx
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
$LN3@toggle_ful:

; 3744 :                    main_rect.right - main_rect.left, main_rect.bottom - main_rect.top,
; 3745 :                    SWP_NOZORDER);
; 3746 :    }
; 3747 :    UpdateWindow(hwnd_main);

  000ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  000cf	50		 push	 eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UpdateWindow@4

; 3748 : 
; 3749 :    if (cfg_settings.options.val & OPT_RECALC_ON_RESIZE)  // recalc after resize, if enabled

  000d6	a1 a4 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+164
  000db	83 e0 01	 and	 eax, 1
  000de	74 0d		 je	 SHORT $LN1@toggle_ful

; 3750 :       status |= STAT_RECALC_IMMEDIATELY;

  000e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  000e5	83 c8 08	 or	 eax, 8
  000e8	a3 00 00 00 00	 mov	 DWORD PTR _status, eax
$LN1@toggle_ful:

; 3751 : }

  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
_toggle_fullscreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _update_dialog
_TEXT	SEGMENT
tv82 = -132						; size = 4
_overhang$ = -64					; size = 4
_ypos$ = -60						; size = 4
_xpos$ = -56						; size = 4
_rc_desktop$ = -52					; size = 16
_rc_dialog$ = -36					; size = 16
_rc_owner$ = -20					; size = 16
_hwnd_desktop$ = -4					; size = 4
_hide$ = 8						; size = 4
_move$ = 12						; size = 4
_update_dialog PROC					; COMDAT

; 3687 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3688 :    HWND hwnd_desktop;
; 3689 :    RECT rc_owner, rc_dialog, rc_desktop;
; 3690 :    int xpos, ypos, overhang;
; 3691 : 
; 3692 :    if (hwnd_main == NULL) // this can be called before the main window gets created

  0000c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hwnd_main, 0
  00013	75 05		 jne	 SHORT $LN2@update_dia

; 3693 :       return;

  00015	e9 c8 00 00 00	 jmp	 $LN1@update_dia
$LN2@update_dia:

; 3694 : 
; 3695 :    GetWindowRect(hwnd_dialog, &rc_dialog);

  0001a	8d 45 dc	 lea	 eax, DWORD PTR _rc_dialog$[ebp]
  0001d	50		 push	 eax
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_dialog
  00024	51		 push	 ecx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 3696 : 
; 3697 :    if (move)

  0002b	83 7d 0c 00	 cmp	 DWORD PTR _move$[ebp], 0
  0002f	74 65		 je	 SHORT $LN3@update_dia

; 3698 :    {
; 3699 :       hwnd_desktop = GetDesktopWindow();

  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDesktopWindow@0
  00037	89 45 fc	 mov	 DWORD PTR _hwnd_desktop$[ebp], eax

; 3700 :       GetWindowRect(hwnd_main, &rc_owner);

  0003a	8d 45 ec	 lea	 eax, DWORD PTR _rc_owner$[ebp]
  0003d	50		 push	 eax
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_main
  00044	51		 push	 ecx
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 3701 :       GetWindowRect(hwnd_desktop, &rc_desktop);

  0004b	8d 45 cc	 lea	 eax, DWORD PTR _rc_desktop$[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _hwnd_desktop$[ebp]
  00052	51		 push	 ecx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 3702 : 
; 3703 :       xpos = rc_owner.right;

  00059	8b 45 f4	 mov	 eax, DWORD PTR _rc_owner$[ebp+8]
  0005c	89 45 c8	 mov	 DWORD PTR _xpos$[ebp], eax

; 3704 :       ypos = rc_owner.top;

  0005f	8b 45 f0	 mov	 eax, DWORD PTR _rc_owner$[ebp+4]
  00062	89 45 c4	 mov	 DWORD PTR _ypos$[ebp], eax

; 3705 : 
; 3706 :       // Clip so dialog doesn't go off the right end of the desktop. Also move down so
; 3707 :       // minimize/maximize buttons are still visible. Dialog right - left = width
; 3708 :       overhang = xpos + (rc_dialog.right - rc_dialog.left) - rc_desktop.right;

  00065	8b 45 e4	 mov	 eax, DWORD PTR _rc_dialog$[ebp+8]
  00068	2b 45 dc	 sub	 eax, DWORD PTR _rc_dialog$[ebp]
  0006b	03 45 c8	 add	 eax, DWORD PTR _xpos$[ebp]
  0006e	2b 45 d4	 sub	 eax, DWORD PTR _rc_desktop$[ebp+8]
  00071	89 45 c0	 mov	 DWORD PTR _overhang$[ebp], eax

; 3709 :       if (overhang > 0)

  00074	83 7d c0 00	 cmp	 DWORD PTR _overhang$[ebp], 0
  00078	7e 1a		 jle	 SHORT $LN5@update_dia

; 3710 :       {
; 3711 :          xpos -= overhang;

  0007a	8b 45 c8	 mov	 eax, DWORD PTR _xpos$[ebp]
  0007d	2b 45 c0	 sub	 eax, DWORD PTR _overhang$[ebp]
  00080	89 45 c8	 mov	 DWORD PTR _xpos$[ebp], eax

; 3712 :          ypos += y_border - y_thinborder;

  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR _y_border
  00088	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _y_thinborder
  0008e	03 45 c4	 add	 eax, DWORD PTR _ypos$[ebp]
  00091	89 45 c4	 mov	 DWORD PTR _ypos$[ebp], eax
$LN5@update_dia:

; 3713 :       }
; 3714 :    }

  00094	eb 0c		 jmp	 SHORT $LN4@update_dia
$LN3@update_dia:

; 3715 :    else // keep at current position
; 3716 :    {
; 3717 :       xpos = rc_dialog.left;

  00096	8b 45 dc	 mov	 eax, DWORD PTR _rc_dialog$[ebp]
  00099	89 45 c8	 mov	 DWORD PTR _xpos$[ebp], eax

; 3718 :       ypos = rc_dialog.top;

  0009c	8b 45 e0	 mov	 eax, DWORD PTR _rc_dialog$[ebp+4]
  0009f	89 45 c4	 mov	 DWORD PTR _ypos$[ebp], eax
$LN4@update_dia:

; 3719 :    }
; 3720 : 
; 3721 :    SetWindowPos(hwnd_dialog, HWND_TOP, xpos, ypos, 0, 0, SWP_NOSIZE |

  000a2	83 7d 08 00	 cmp	 DWORD PTR _hide$[ebp], 0
  000a6	74 0c		 je	 SHORT $LN7@update_dia
  000a8	c7 85 7c ff ff
	ff 80 00 00 00	 mov	 DWORD PTR tv82[ebp], 128 ; 00000080H
  000b2	eb 0a		 jmp	 SHORT $LN8@update_dia
$LN7@update_dia:
  000b4	c7 85 7c ff ff
	ff 40 00 00 00	 mov	 DWORD PTR tv82[ebp], 64	; 00000040H
$LN8@update_dia:
  000be	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv82[ebp]
  000c4	83 c8 01	 or	 eax, 1
  000c7	50		 push	 eax
  000c8	6a 00		 push	 0
  000ca	6a 00		 push	 0
  000cc	8b 4d c4	 mov	 ecx, DWORD PTR _ypos$[ebp]
  000cf	51		 push	 ecx
  000d0	8b 55 c8	 mov	 edx, DWORD PTR _xpos$[ebp]
  000d3	52		 push	 edx
  000d4	6a 00		 push	 0
  000d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  000db	50		 push	 eax
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
$LN1@update_dia:

; 3722 :                (hide ? SWP_HIDEWINDOW : SWP_SHOWWINDOW) );
; 3723 : }

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
_update_dialog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_system_metrics
_TEXT	SEGMENT
_get_system_metrics PROC				; COMDAT

; 3672 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3673 :    x_border = 2 * GetSystemMetrics(SM_CXSIZEFRAME);

  00009	6a 20		 push	 32			; 00000020H
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  00011	d1 e0		 shl	 eax, 1
  00013	a3 00 00 00 00	 mov	 DWORD PTR _x_border, eax

; 3674 :    y_border = 2 * (y_thinborder = GetSystemMetrics(SM_CYSIZEFRAME)) + GetSystemMetrics(SM_CYCAPTION);

  00018	6a 21		 push	 33			; 00000021H
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  00020	a3 00 00 00 00	 mov	 DWORD PTR _y_thinborder, eax
  00025	6a 04		 push	 4
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _y_thinborder
  00033	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00036	89 15 00 00 00
	00		 mov	 DWORD PTR _y_border, edx

; 3675 : 
; 3676 :    // X/Y reversed on these
; 3677 :    x_dialog_border = 2 * GetSystemMetrics(SM_CYFIXEDFRAME);

  0003c	6a 08		 push	 8
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  00044	d1 e0		 shl	 eax, 1
  00046	a3 00 00 00 00	 mov	 DWORD PTR _x_dialog_border, eax

; 3678 :    y_dialog_border = 2 * GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CYSMCAPTION);

  0004b	6a 07		 push	 7
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  00053	8b f0		 mov	 esi, eax
  00055	6a 33		 push	 51			; 00000033H
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  0005d	8d 04 70	 lea	 eax, DWORD PTR [eax+esi*2]
  00060	a3 00 00 00 00	 mov	 DWORD PTR _y_dialog_border, eax

; 3679 : 
; 3680 :    // Get font size. Assumes x/y pixels per inch are the same. Returns 96 for normal, 120 for large.
; 3681 :    lpix_per_inch = GetDeviceCaps(GetDC(NULL), LOGPIXELSX);

  00065	6a 58		 push	 88			; 00000058H
  00067	6a 00		 push	 0
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  0006f	50		 push	 eax
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8
  00076	a3 00 00 00 00	 mov	 DWORD PTR _lpix_per_inch, eax

; 3682 : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_get_system_metrics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _check_alg
_TEXT	SEGMENT
tv140 = -72						; size = 4
_m$ = -4						; size = 4
_hwnd$ = 8						; size = 4
_check_alg PROC						; COMDAT

; 3584 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3585 :    man_calc_struct *m;
; 3586 : 
; 3587 :    m = &main_man_calc_struct;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3588 :    m->precision = get_precision();

  00010	e8 00 00 00 00	 call	 _get_precision
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  00018	89 81 d0 8d 00
	00		 mov	 DWORD PTR [ecx+36304], eax

; 3589 :    m->alg = get_alg();

  0001e	e8 00 00 00 00	 call	 _get_alg
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  00026	89 81 c8 8d 00
	00		 mov	 DWORD PTR [ecx+36296], eax

; 3590 :    m->rendering_alg = get_rendering_alg();

  0002c	e8 00 00 00 00	 call	 _get_rendering_alg
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  00034	89 81 04 8e 00
	00		 mov	 DWORD PTR [ecx+36356], eax

; 3591 :    if (m->precision == PRECISION_EXTENDED)

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  0003d	83 b8 d0 8d 00
	00 03		 cmp	 DWORD PTR [eax+36304], 3
  00044	75 1f		 jne	 SHORT $LN2@check_alg

; 3592 :    {
; 3593 :       not_implemented_yet();

  00046	e8 00 00 00 00	 call	 _not_implemented_yet

; 3594 :       SendDlgItemMessage(hwnd, IDC_PRECISION, CB_SETCURSEL, PRECISION_DOUBLE, 0);

  0004b	6a 00		 push	 0
  0004d	6a 02		 push	 2
  0004f	68 4e 01 00 00	 push	 334			; 0000014eH
  00054	68 f2 03 00 00	 push	 1010			; 000003f2H
  00059	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0005c	50		 push	 eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 3595 :    }

  00063	eb 76		 jmp	 SHORT $LN3@check_alg
$LN2@check_alg:

; 3596 :    else if (m->precision == PRECISION_DOUBLE)

  00065	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00068	83 b8 d0 8d 00
	00 02		 cmp	 DWORD PTR [eax+36304], 2
  0006f	75 36		 jne	 SHORT $LN4@check_alg

; 3597 :    {
; 3598 :       if (sse_support < 2 && !(m->alg & ALG_C)) // If CPU doesn't support SSE2, can only run C version

  00071	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _sse_support, 2
  00078	7d 2b		 jge	 SHORT $LN6@check_alg
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  0007d	8b 88 c8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36296]
  00083	83 e1 04	 and	 ecx, 4
  00086	75 1d		 jne	 SHORT $LN6@check_alg

; 3599 :       {
; 3600 :          unsupported_alg_prec();

  00088	e8 00 00 00 00	 call	 _unsupported_alg_prec

; 3601 :          SendDlgItemMessage(hwnd, IDC_ALGORITHM, CB_SETCURSEL, ALG_FAST_C, 0);

  0008d	6a 00		 push	 0
  0008f	6a 04		 push	 4
  00091	68 4e 01 00 00	 push	 334			; 0000014eH
  00096	68 05 04 00 00	 push	 1029			; 00000405H
  0009b	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
$LN6@check_alg:

; 3602 :       }
; 3603 :    }

  000a5	eb 34		 jmp	 SHORT $LN3@check_alg
$LN4@check_alg:

; 3604 :    else
; 3605 :    {
; 3606 :       if (!sse_support && !(m->alg & ALG_C)) // If CPU doesn't support SSE, can only run C version

  000a7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _sse_support, 0
  000ae	75 2b		 jne	 SHORT $LN3@check_alg
  000b0	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  000b3	8b 88 c8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36296]
  000b9	83 e1 04	 and	 ecx, 4
  000bc	75 1d		 jne	 SHORT $LN3@check_alg

; 3607 :       {
; 3608 :          unsupported_alg_prec();

  000be	e8 00 00 00 00	 call	 _unsupported_alg_prec

; 3609 :          SendDlgItemMessage(hwnd, IDC_ALGORITHM, CB_SETCURSEL, ALG_FAST_C, 0);

  000c3	6a 00		 push	 0
  000c5	6a 04		 push	 4
  000c7	68 4e 01 00 00	 push	 334			; 0000014eH
  000cc	68 05 04 00 00	 push	 1029			; 00000405H
  000d1	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  000d4	50		 push	 eax
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
$LN3@check_alg:

; 3610 :       }
; 3611 :    }
; 3612 : 
; 3613 :    // Give user a choice to switch to exact alg if using normalized rendering
; 3614 : 
; 3615 :    if (!(m->alg & ALG_EXACT) && (m->rendering_alg == RALG_NORMALIZED))

  000db	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  000de	8b 88 c8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36296]
  000e4	83 e1 01	 and	 ecx, 1
  000e7	75 58		 jne	 SHORT $LN8@check_alg
  000e9	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  000ec	83 b8 04 8e 00
	00 01		 cmp	 DWORD PTR [eax+36356], 1
  000f3	75 4c		 jne	 SHORT $LN8@check_alg

; 3616 :       if (unrecommended_alg() == IDYES)

  000f5	e8 00 00 00 00	 call	 _unrecommended_alg
  000fa	83 f8 06	 cmp	 eax, 6
  000fd	75 42		 jne	 SHORT $LN8@check_alg

; 3617 :       {
; 3618 :          SendDlgItemMessage(hwnd, IDC_ALGORITHM, CB_SETCURSEL, m->alg |= ALG_EXACT, 0);

  000ff	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00102	8b 88 c8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36296]
  00108	83 c9 01	 or	 ecx, 1
  0010b	89 4d b8	 mov	 DWORD PTR tv140[ebp], ecx
  0010e	8b 55 fc	 mov	 edx, DWORD PTR _m$[ebp]
  00111	8b 45 b8	 mov	 eax, DWORD PTR tv140[ebp]
  00114	89 82 c8 8d 00
	00		 mov	 DWORD PTR [edx+36296], eax
  0011a	6a 00		 push	 0
  0011c	8b 4d b8	 mov	 ecx, DWORD PTR tv140[ebp]
  0011f	51		 push	 ecx
  00120	68 4e 01 00 00	 push	 334			; 0000014eH
  00125	68 05 04 00 00	 push	 1029			; 00000405H
  0012a	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0012d	52		 push	 edx
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 3619 :          status |= STAT_RECALC_FOR_PALETTE; // need to recalc if switching to exact

  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00139	83 c8 02	 or	 eax, 2
  0013c	a3 00 00 00 00	 mov	 DWORD PTR _status, eax
$LN8@check_alg:

; 3620 :       }
; 3621 :    set_alg_warning();

  00141	e8 00 00 00 00	 call	 _set_alg_warning

; 3622 : }

  00146	5f		 pop	 edi
  00147	5e		 pop	 esi
  00148	5b		 pop	 ebx
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
_check_alg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _set_alg_warning
_TEXT	SEGMENT
_m$ = -36						; size = 4
_s$ = -32						; size = 32
_set_alg_warning PROC					; COMDAT

; 3570 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3571 :    char s[32];
; 3572 :    man_calc_struct *m;
; 3573 : 
; 3574 :    m = &main_man_calc_struct;

  00009	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3575 :    sprintf_s(s, sizeof(s), "  Algorithm");

  00010	68 00 00 00 00	 push	 OFFSET $SG41732
  00015	6a 20		 push	 32			; 00000020H
  00017	8d 45 e0	 lea	 eax, DWORD PTR _s$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _sprintf_s
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3576 :    if (!(m->alg & ALG_EXACT) && (m->rendering_alg == RALG_NORMALIZED))

  00023	8b 45 dc	 mov	 eax, DWORD PTR _m$[ebp]
  00026	8b 88 c8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36296]
  0002c	83 e1 01	 and	 ecx, 1
  0002f	75 19		 jne	 SHORT $LN2@set_alg_wa
  00031	8b 45 dc	 mov	 eax, DWORD PTR _m$[ebp]
  00034	83 b8 04 8e 00
	00 01		 cmp	 DWORD PTR [eax+36356], 1
  0003b	75 0d		 jne	 SHORT $LN2@set_alg_wa

; 3577 :       s[0] = '!';

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	6b c8 00	 imul	 ecx, eax, 0
  00045	c6 44 0d e0 21	 mov	 BYTE PTR _s$[ebp+ecx], 33 ; 00000021H
$LN2@set_alg_wa:

; 3578 :    SetWindowText(GetDlgItem(hwnd_dialog, IDC_ALGORITHM_TEXT), s);

  0004a	8d 45 e0	 lea	 eax, DWORD PTR _s$[ebp]
  0004d	50		 push	 eax
  0004e	68 1f 04 00 00	 push	 1055			; 0000041fH
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_dialog
  00059	51		 push	 ecx
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00060	50		 push	 eax
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 3579 : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_set_alg_warning ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _unrecommended_alg
_TEXT	SEGMENT
_unrecommended_alg PROC					; COMDAT

; 3560 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3561 :    return MessageBox(NULL, "Using the Fast algorithm with Normalized rendering may\n"

  00009	68 34 20 00 00	 push	 8244			; 00002034H
  0000e	68 00 00 00 00	 push	 OFFSET $SG41723
  00013	68 00 00 00 00	 push	 OFFSET $SG41724
  00018	6a 00		 push	 0
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 3562 :                            "cause image artifacts. Switch to the Exact algorithm?",
; 3563 :                            "Warning", MB_YESNO | MB_ICONWARNING | MB_TASKMODAL);
; 3564 : }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_unrecommended_alg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _unsupported_alg_prec
_TEXT	SEGMENT
_unsupported_alg_prec PROC				; COMDAT

; 3554 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3555 :    MessageBox(NULL, "Your (obsolete) CPU cannot run this algorithm/precision combination.\n"

  00009	68 10 20 00 00	 push	 8208			; 00002010H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET $SG41716
  00015	6a 00		 push	 0
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 3556 :                     "Using C algorithm.", NULL, MB_OK | MB_ICONSTOP | MB_TASKMODAL);
; 3557 : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_unsupported_alg_prec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _not_implemented_yet
_TEXT	SEGMENT
_not_implemented_yet PROC				; COMDAT

; 3549 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3550 :    MessageBox(NULL, "This feature is not implemented yet.", NULL, MB_OK | MB_ICONSTOP | MB_TASKMODAL);

  00009	68 10 20 00 00	 push	 8208			; 00002010H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET $SG41708
  00015	6a 00		 push	 0
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 3551 : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_not_implemented_yet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _print_palette_status
_TEXT	SEGMENT
tv69 = -104						; size = 4
_m$ = -36						; size = 4
_s$ = -32						; size = 32
_print_palette_status PROC				; COMDAT

; 3539 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3540 :    char s[32];
; 3541 :    man_calc_struct *m;
; 3542 : 
; 3543 :    m = &main_man_calc_struct;

  00009	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3544 :    sprintf_s(s, sizeof(s), "%c Palette", (status & STAT_PALETTE_LOCKED) || m->pal_xor ? '*' : ' ');

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00015	83 e0 20	 and	 eax, 32			; 00000020H
  00018	75 15		 jne	 SHORT $LN3@print_pale
  0001a	8b 4d dc	 mov	 ecx, DWORD PTR _m$[ebp]
  0001d	83 b9 fc 8d 00
	00 00		 cmp	 DWORD PTR [ecx+36348], 0
  00024	75 09		 jne	 SHORT $LN3@print_pale
  00026	c7 45 98 20 00
	00 00		 mov	 DWORD PTR tv69[ebp], 32	; 00000020H
  0002d	eb 07		 jmp	 SHORT $LN4@print_pale
$LN3@print_pale:
  0002f	c7 45 98 2a 00
	00 00		 mov	 DWORD PTR tv69[ebp], 42	; 0000002aH
$LN4@print_pale:
  00036	8b 55 98	 mov	 edx, DWORD PTR tv69[ebp]
  00039	52		 push	 edx
  0003a	68 00 00 00 00	 push	 OFFSET $SG41700
  0003f	6a 20		 push	 32			; 00000020H
  00041	8d 45 e0	 lea	 eax, DWORD PTR _s$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _sprintf_s
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 3545 :    SetWindowText(GetDlgItem(hwnd_dialog, IDC_PAL_TEXT), s);

  0004d	8d 45 e0	 lea	 eax, DWORD PTR _s$[ebp]
  00050	50		 push	 eax
  00051	68 1d 04 00 00	 push	 1053			; 0000041dH
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_dialog
  0005c	51		 push	 ecx
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00063	50		 push	 eax
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 3546 : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_print_palette_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _print_status_line
_TEXT	SEGMENT
tv73 = -208						; size = 4
tv84 = -204						; size = 4
tv68 = -204						; size = 4
tv85 = -200						; size = 4
tv70 = -200						; size = 4
_m$ = -132						; size = 4
_s$ = -128						; size = 128
_calc$ = 8						; size = 4
_print_status_line PROC					; COMDAT

; 3517 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3518 :    char s[128];
; 3519 :    man_calc_struct *m;
; 3520 : 
; 3521 :    m = &main_man_calc_struct;

  0000c	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3522 : 
; 3523 :    if (!(status & STAT_DOING_SAVE)) // if currently saving, keep saving status in first part of line

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  0001b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00020	0f 85 8e 00 00
	00		 jne	 $LN2@print_stat

; 3524 :    {
; 3525 :       sprintf_s(s, sizeof(s), "%s%s", calc ? "Calculating..." : "Ready ",

  00026	83 7d 08 00	 cmp	 DWORD PTR _calc$[ebp], 0
  0002a	74 0c		 je	 SHORT $LN6@print_stat
  0002c	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], OFFSET $SG41686
  00036	eb 2b		 jmp	 SHORT $LN7@print_stat
$LN6@print_stat:
  00038	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _precision_loss, 0
  0003f	74 0c		 je	 SHORT $LN4@print_stat
  00041	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], OFFSET $SG41687
  0004b	eb 0a		 jmp	 SHORT $LN5@print_stat
$LN4@print_stat:
  0004d	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], OFFSET $SG41688
$LN5@print_stat:
  00057	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR tv68[ebp]
  0005d	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
$LN7@print_stat:
  00063	83 7d 08 00	 cmp	 DWORD PTR _calc$[ebp], 0
  00067	74 0c		 je	 SHORT $LN8@print_stat
  00069	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], OFFSET $SG41689
  00073	eb 0a		 jmp	 SHORT $LN9@print_stat
$LN8@print_stat:
  00075	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], OFFSET $SG41690
$LN9@print_stat:
  0007f	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv70[ebp]
  00085	51		 push	 ecx
  00086	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv73[ebp]
  0008c	52		 push	 edx
  0008d	68 00 00 00 00	 push	 OFFSET $SG41691
  00092	68 80 00 00 00	 push	 128			; 00000080H
  00097	8d 45 80	 lea	 eax, DWORD PTR _s$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _sprintf_s
  000a0	83 c4 14	 add	 esp, 20			; 00000014H

; 3526 :                 calc ? "" : precision_loss ? "[Prec Loss]" : "");
; 3527 : 
; 3528 :       SetWindowText(hwnd_status, s);

  000a3	8d 45 80	 lea	 eax, DWORD PTR _s$[ebp]
  000a6	50		 push	 eax
  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_status
  000ad	51		 push	 ecx
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
$LN2@print_stat:

; 3529 :    }
; 3530 : 
; 3531 :    sprintf_s(s, sizeof(s), "%d/%d  %c", log_pos + 1, log_count,

  000b4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  000ba	83 b8 d0 8d 00
	00 01		 cmp	 DWORD PTR [eax+36304], 1
  000c1	75 0c		 jne	 SHORT $LN12@print_stat
  000c3	c7 85 38 ff ff
	ff 53 00 00 00	 mov	 DWORD PTR tv85[ebp], 83	; 00000053H
  000cd	eb 31		 jmp	 SHORT $LN13@print_stat
$LN12@print_stat:
  000cf	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  000d5	83 b9 d0 8d 00
	00 02		 cmp	 DWORD PTR [ecx+36304], 2
  000dc	75 0c		 jne	 SHORT $LN10@print_stat
  000de	c7 85 34 ff ff
	ff 44 00 00 00	 mov	 DWORD PTR tv84[ebp], 68	; 00000044H
  000e8	eb 0a		 jmp	 SHORT $LN11@print_stat
$LN10@print_stat:
  000ea	c7 85 34 ff ff
	ff 45 00 00 00	 mov	 DWORD PTR tv84[ebp], 69	; 00000045H
$LN11@print_stat:
  000f4	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR tv84[ebp]
  000fa	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], edx
$LN13@print_stat:
  00100	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv85[ebp]
  00106	50		 push	 eax
  00107	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _log_count
  0010d	51		 push	 ecx
  0010e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _log_pos
  00114	83 c2 01	 add	 edx, 1
  00117	52		 push	 edx
  00118	68 00 00 00 00	 push	 OFFSET $SG41692
  0011d	68 80 00 00 00	 push	 128			; 00000080H
  00122	8d 45 80	 lea	 eax, DWORD PTR _s$[ebp]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _sprintf_s
  0012b	83 c4 18	 add	 esp, 24			; 00000018H

; 3532 :              m->precision == PRECISION_SINGLE ? 'S' : m->precision == PRECISION_DOUBLE ? 'D' : 'E');
; 3533 :    SetWindowText(hwnd_status2, s);

  0012e	8d 45 80	 lea	 eax, DWORD PTR _s$[ebp]
  00131	50		 push	 eax
  00132	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_status2
  00138	51		 push	 ecx
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 3534 : }

  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c3		 ret	 0
_print_status_line ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _setup_sliders
_TEXT	SEGMENT
_setup_sliders PROC					; COMDAT

; 3508 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3509 :    cfg_settings.pan_rate.val = set_slider_pos(IDC_PAN_RATE, cfg_settings.pan_rate.val);

  00009	a1 04 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+4
  0000e	50		 push	 eax
  0000f	68 17 04 00 00	 push	 1047			; 00000417H
  00014	e8 00 00 00 00	 call	 _set_slider_pos
  00019	83 c4 08	 add	 esp, 8
  0001c	a3 04 00 00 00	 mov	 DWORD PTR _cfg_settings+4, eax

; 3510 :    cfg_settings.zoom_rate.val = set_slider_pos(IDC_ZOOM_RATE, cfg_settings.zoom_rate.val);

  00021	a1 2c 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+44
  00026	50		 push	 eax
  00027	68 18 04 00 00	 push	 1048			; 00000418H
  0002c	e8 00 00 00 00	 call	 _set_slider_pos
  00031	83 c4 08	 add	 esp, 8
  00034	a3 2c 00 00 00	 mov	 DWORD PTR _cfg_settings+44, eax

; 3511 : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_setup_sliders ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _set_slider_pos
_TEXT	SEGMENT
_dlg_item$ = 8						; size = 4
_pos$ = 12						; size = 4
_set_slider_pos PROC					; COMDAT

; 3502 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3503 :    SendDlgItemMessage(hwnd_dialog, dlg_item, TBM_SETPOS, TRUE, (LONG)pos);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	68 05 04 00 00	 push	 1029			; 00000405H
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _dlg_item$[ebp]
  00017	51		 push	 ecx
  00018	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hwnd_dialog
  0001e	52		 push	 edx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 3504 :    return (int) SendDlgItemMessage(hwnd_dialog, dlg_item, TBM_GETPOS, 0, 0);

  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	68 00 04 00 00	 push	 1024			; 00000400H
  0002e	8b 45 08	 mov	 eax, DWORD PTR _dlg_item$[ebp]
  00031	50		 push	 eax
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_dialog
  00038	51		 push	 ecx
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 3505 : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_set_slider_pos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_dialog_fields
_TEXT	SEGMENT
_m$ = -4						; size = 4
_get_dialog_fields PROC					; COMDAT

; 3476 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3477 :    man_calc_struct *m;
; 3478 : 
; 3479 :    m = &main_man_calc_struct;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3480 : 
; 3481 :    m->max_iters = GetDlgItemInt(hwnd_dialog, IDC_ITERS, NULL, FALSE);

  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	68 fb 03 00 00	 push	 1019			; 000003fbH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemInt@16
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  00028	89 81 c0 8d 00
	00		 mov	 DWORD PTR [ecx+36288], eax

; 3482 :    update_iters(0, 0); // clip

  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	e8 00 00 00 00	 call	 _update_iters
  00037	83 c4 08	 add	 esp, 8

; 3483 : 
; 3484 :    // Doing these only in the dialog box handler mean they don't take effect until
; 3485 :    // user actually clicks them, whereas getting them here returns the realtime values.
; 3486 : 
; 3487 :    // It's useful to be able to set these on the fly
; 3488 :    m->alg = get_alg();

  0003a	e8 00 00 00 00	 call	 _get_alg
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  00042	89 81 c8 8d 00
	00		 mov	 DWORD PTR [ecx+36296], eax

; 3489 :    m->precision = get_precision();

  00048	e8 00 00 00 00	 call	 _get_precision
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  00050	89 81 d0 8d 00
	00		 mov	 DWORD PTR [ecx+36304], eax

; 3490 :    m->rendering_alg = get_rendering_alg();

  00056	e8 00 00 00 00	 call	 _get_rendering_alg
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  0005e	89 81 04 8e 00
	00		 mov	 DWORD PTR [ecx+36356], eax

; 3491 :    if (m->precision == PRECISION_EXTENDED) // don't allow on-the-fly change to this (unimplemented)

  00064	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00067	83 b8 d0 8d 00
	00 03		 cmp	 DWORD PTR [eax+36304], 3
  0006e	75 0d		 jne	 SHORT $LN2@get_dialog

; 3492 :       m->precision = PRECISION_DOUBLE;

  00070	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00073	c7 80 d0 8d 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+36304], 2
$LN2@get_dialog:

; 3493 : 
; 3494 :    get_builtin_palette();

  0007d	e8 00 00 00 00	 call	 _get_builtin_palette

; 3495 : 
; 3496 :    // This not so much
; 3497 :    // get_num_threads();
; 3498 : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
_get_dialog_fields ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _set_home_image
_TEXT	SEGMENT
_m$ = -4						; size = 4
_set_home_image PROC					; COMDAT

; 3460 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3461 :    man_calc_struct *m;
; 3462 : 
; 3463 :    m = &main_man_calc_struct;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3464 : 
; 3465 :    m->pan_xoffs = 0; // Reset any pan offsets

  00010	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00013	c7 80 98 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36248], 0
  0001d	c7 80 9c 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36252], 0

; 3466 :    m->pan_yoffs = 0;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  0002a	c7 80 a0 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36256], 0
  00034	c7 80 a4 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36260], 0

; 3467 :    m->re = HOME_RE;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00041	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@bfe6666666666666
  00049	f2 0f 11 80 a8
	8d 00 00	 movsd	 QWORD PTR [eax+36264], xmm0

; 3468 :    m->im = HOME_IM;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00054	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f50624dd2f1a9fc
  0005c	f2 0f 11 80 b0
	8d 00 00	 movsd	 QWORD PTR [eax+36272], xmm0

; 3469 :    m->mag = HOME_MAG;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00067	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff599999999999a
  0006f	f2 0f 11 80 b8
	8d 00 00	 movsd	 QWORD PTR [eax+36280], xmm0

; 3470 :    m->max_iters = HOME_MAX_ITERS;   // Better to reset the max iters here. Don't want large #

  00077	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  0007a	c7 80 c0 8d 00
	00 00 01 00 00	 mov	 DWORD PTR [eax+36288], 256 ; 00000100H

; 3471 :    update_iters(0, 0);              // from previous image

  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	e8 00 00 00 00	 call	 _update_iters
  0008d	83 c4 08	 add	 esp, 8

; 3472 : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_set_home_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _update_iters
_TEXT	SEGMENT
_m$ = -4						; size = 4
_up$ = 8						; size = 4
_down$ = 12						; size = 4
_update_iters PROC					; COMDAT

; 3441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3442 :    man_calc_struct *m;
; 3443 : 
; 3444 :    m = &main_man_calc_struct;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3445 : 
; 3446 :    if (up)

  00010	83 7d 08 00	 cmp	 DWORD PTR _up$[ebp], 0
  00014	74 14		 je	 SHORT $LN2@update_ite

; 3447 :       m->max_iters <<= 1;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00019	8b 88 c0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36288]
  0001f	d1 e1		 shl	 ecx, 1
  00021	8b 55 fc	 mov	 edx, DWORD PTR _m$[ebp]
  00024	89 8a c0 8d 00
	00		 mov	 DWORD PTR [edx+36288], ecx
$LN2@update_ite:

; 3448 :    if (down)

  0002a	83 7d 0c 00	 cmp	 DWORD PTR _down$[ebp], 0
  0002e	74 14		 je	 SHORT $LN3@update_ite

; 3449 :       m->max_iters >>= 1;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00033	8b 88 c0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36288]
  00039	d1 e9		 shr	 ecx, 1
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _m$[ebp]
  0003e	89 8a c0 8d 00
	00		 mov	 DWORD PTR [edx+36288], ecx
$LN3@update_ite:

; 3450 :    if (m->max_iters < MIN_ITERS)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00047	83 b8 c0 8d 00
	00 02		 cmp	 DWORD PTR [eax+36288], 2
  0004e	73 0d		 jae	 SHORT $LN4@update_ite

; 3451 :       m->max_iters = MIN_ITERS;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00053	c7 80 c0 8d 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+36288], 2
$LN4@update_ite:

; 3452 :    if (m->max_iters > MAX_ITERS)

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00060	81 b8 c0 8d 00
	00 00 00 00 08	 cmp	 DWORD PTR [eax+36288], 134217728 ; 08000000H
  0006a	76 0d		 jbe	 SHORT $LN5@update_ite

; 3453 :       m->max_iters = MAX_ITERS;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  0006f	c7 80 c0 8d 00
	00 00 00 00 08	 mov	 DWORD PTR [eax+36288], 134217728 ; 08000000H
$LN5@update_ite:

; 3454 : 
; 3455 :    SetDlgItemInt(hwnd_dialog, IDC_ITERS, m->max_iters, FALSE);

  00079	6a 00		 push	 0
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  0007e	8b 88 c0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36288]
  00084	51		 push	 ecx
  00085	68 fb 03 00 00	 push	 1019			; 000003fbH
  0008a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hwnd_dialog
  00090	52		 push	 edx
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemInt@16

; 3456 : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
_update_iters ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_num_threads
_TEXT	SEGMENT
_str$ = -256						; size = 256
_get_num_threads PROC					; COMDAT

; 3431 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3432 :    char str[256];
; 3433 : 
; 3434 :    GetDlgItemText(hwnd_dialog, IDC_THREADS, str, sizeof(str));

  0000c	68 00 01 00 00	 push	 256			; 00000100H
  00011	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00017	50		 push	 eax
  00018	68 06 04 00 00	 push	 1030			; 00000406H
  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_dialog
  00023	51		 push	 ecx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemTextA@16

; 3435 :    num_threads_ind = get_string_index(str, num_threads_strs, NUM_ELEM(num_threads_strs));

  0002a	6a 09		 push	 9
  0002c	68 00 00 00 00	 push	 OFFSET _num_threads_strs
  00031	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _get_string_index
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	a3 00 00 00 00	 mov	 DWORD PTR _num_threads_ind, eax

; 3436 :    num_threads = 1 << num_threads_ind;

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _num_threads_ind
  00050	d3 e0		 shl	 eax, cl
  00052	a3 00 00 00 00	 mov	 DWORD PTR _num_threads, eax

; 3437 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_get_num_threads ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_alg
_TEXT	SEGMENT
_str$ = -256						; size = 256
_get_alg PROC						; COMDAT

; 3423 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3424 :    char str[256];
; 3425 : 
; 3426 :    GetDlgItemText(hwnd_dialog, IDC_ALGORITHM, str, sizeof(str));

  0000c	68 00 01 00 00	 push	 256			; 00000100H
  00011	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00017	50		 push	 eax
  00018	68 05 04 00 00	 push	 1029			; 00000405H
  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_dialog
  00023	51		 push	 ecx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemTextA@16

; 3427 :    return get_string_index(str, alg_strs, NUM_ELEM(alg_strs));

  0002a	6a 06		 push	 6
  0002c	68 00 00 00 00	 push	 OFFSET _alg_strs
  00031	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _get_string_index
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3428 : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_get_alg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_precision
_TEXT	SEGMENT
_str$ = -256						; size = 256
_get_precision PROC					; COMDAT

; 3415 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3416 :    char str[256];
; 3417 : 
; 3418 :    GetDlgItemText(hwnd_dialog, IDC_PRECISION, str, sizeof(str));

  0000c	68 00 01 00 00	 push	 256			; 00000100H
  00011	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00017	50		 push	 eax
  00018	68 f2 03 00 00	 push	 1010			; 000003f2H
  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_dialog
  00023	51		 push	 ecx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemTextA@16

; 3419 :    return get_string_index(str, precision_strs, NUM_ELEM(precision_strs));

  0002a	6a 04		 push	 4
  0002c	68 00 00 00 00	 push	 OFFSET _precision_strs
  00031	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _get_string_index
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3420 : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_get_precision ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_rendering_alg
_TEXT	SEGMENT
_str$ = -256						; size = 256
_get_rendering_alg PROC					; COMDAT

; 3407 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3408 :    char str[256];
; 3409 : 
; 3410 :    GetDlgItemText(hwnd_dialog, IDC_RENDERING, str, sizeof(str));

  0000c	68 00 01 00 00	 push	 256			; 00000100H
  00011	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00017	50		 push	 eax
  00018	68 04 04 00 00	 push	 1028			; 00000404H
  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_dialog
  00023	51		 push	 ecx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemTextA@16

; 3411 :    return get_string_index(str, rendering_strs, NUM_ELEM(rendering_strs));

  0002a	6a 02		 push	 2
  0002c	68 00 00 00 00	 push	 OFFSET _rendering_strs
  00031	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _get_string_index
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3412 : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_get_rendering_alg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_user_palette
_TEXT	SEGMENT
tv95 = -84						; size = 4
tv88 = -84						; size = 4
tv77 = -84						; size = 4
_m$ = -16						; size = 4
_bmp_flag$ = -12					; size = 4
_tmp$ = -8						; size = 4
_fp$ = -4						; size = 4
_get_user_palette PROC					; COMDAT

; 3379 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3380 :    FILE *fp;
; 3381 :    unsigned tmp, bmp_flag;
; 3382 :    man_calc_struct *m;
; 3383 : 
; 3384 :    m = &main_man_calc_struct;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3385 : 
; 3386 :    GetDlgItemText(hwnd_dialog, IDC_PALETTE, palette_file, sizeof(palette_file));

  00010	68 00 01 00 00	 push	 256			; 00000100H
  00015	68 00 00 00 00	 push	 OFFSET _palette_file
  0001a	68 03 04 00 00	 push	 1027			; 00000403H
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemTextA@16

; 3387 : 
; 3388 :    // See whether it's a BMP or text palette file; load using corresponding function.
; 3389 :    // This is safe because files have to have 3-char extensions to make it into the dropdown list
; 3390 :    bmp_flag = !_strnicmp(palette_file + strlen(palette_file) - 3, "bmp", 3);

  0002b	6a 03		 push	 3
  0002d	68 00 00 00 00	 push	 OFFSET $SG41604
  00032	68 00 00 00 00	 push	 OFFSET _palette_file
  00037	e8 00 00 00 00	 call	 _strlen
  0003c	83 c4 04	 add	 esp, 4
  0003f	8d 80 fd ff ff
	ff		 lea	 eax, DWORD PTR _palette_file[eax-3]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 __strnicmp
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	85 c0		 test	 eax, eax
  00050	75 09		 jne	 SHORT $LN6@get_user_p
  00052	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  00059	eb 07		 jmp	 SHORT $LN7@get_user_p
$LN6@get_user_p:
  0005b	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN7@get_user_p:
  00062	8b 4d ac	 mov	 ecx, DWORD PTR tv77[ebp]
  00065	89 4d f4	 mov	 DWORD PTR _bmp_flag$[ebp], ecx

; 3391 : 
; 3392 :    if ((fp = open_file(palette_file, "", bmp_flag)) != NULL)

  00068	8b 45 f4	 mov	 eax, DWORD PTR _bmp_flag$[ebp]
  0006b	50		 push	 eax
  0006c	68 00 00 00 00	 push	 OFFSET $SG41606
  00071	68 00 00 00 00	 push	 OFFSET _palette_file
  00076	e8 00 00 00 00	 call	 _open_file
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax
  00081	83 7d fc 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00085	74 75		 je	 SHORT $LN1@get_user_p

; 3393 :    {
; 3394 :       tmp = bmp_flag ? load_palette_from_bmp(fp) : load_palette(fp);

  00087	83 7d f4 00	 cmp	 DWORD PTR _bmp_flag$[ebp], 0
  0008b	74 11		 je	 SHORT $LN8@get_user_p
  0008d	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _load_palette_from_bmp
  00096	83 c4 04	 add	 esp, 4
  00099	89 45 ac	 mov	 DWORD PTR tv88[ebp], eax
  0009c	eb 0f		 jmp	 SHORT $LN9@get_user_p
$LN8@get_user_p:
  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 _load_palette
  000a7	83 c4 04	 add	 esp, 4
  000aa	89 45 ac	 mov	 DWORD PTR tv88[ebp], eax
$LN9@get_user_p:
  000ad	8b 55 ac	 mov	 edx, DWORD PTR tv88[ebp]
  000b0	89 55 f8	 mov	 DWORD PTR _tmp$[ebp], edx

; 3395 : 
; 3396 :       if (tmp)          // load_palette* assigns a nonzero number to the palette

  000b3	83 7d f8 00	 cmp	 DWORD PTR _tmp$[ebp], 0
  000b7	74 0e		 je	 SHORT $LN3@get_user_p

; 3397 :          m->palette = tmp; // if valid, which can then be used with apply_palette.

  000b9	8b 45 f0	 mov	 eax, DWORD PTR _m$[ebp]
  000bc	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$[ebp]
  000bf	89 88 f4 8d 00
	00		 mov	 DWORD PTR [eax+36340], ecx
  000c5	eb 29		 jmp	 SHORT $LN4@get_user_p
$LN3@get_user_p:

; 3398 :       else
; 3399 :          MessageBox( NULL, bmp_flag ? "Unsupported file format. Please supply an uncompressed 24-bit bitmap."

  000c7	83 7d f4 00	 cmp	 DWORD PTR _bmp_flag$[ebp], 0
  000cb	74 09		 je	 SHORT $LN10@get_user_p
  000cd	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], OFFSET $SG41609
  000d4	eb 07		 jmp	 SHORT $LN11@get_user_p
$LN10@get_user_p:
  000d6	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], OFFSET $SG41610
$LN11@get_user_p:
  000dd	68 10 20 00 00	 push	 8208			; 00002010H
  000e2	6a 00		 push	 0
  000e4	8b 45 ac	 mov	 eax, DWORD PTR tv95[ebp]
  000e7	50		 push	 eax
  000e8	6a 00		 push	 0
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN4@get_user_p:

; 3400 :                                     : "Unrecognized file format.",
; 3401 :                      NULL, MB_OK | MB_ICONSTOP | MB_TASKMODAL);
; 3402 :       fclose(fp);

  000f0	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _fclose
  000f9	83 c4 04	 add	 esp, 4
$LN1@get_user_p:

; 3403 :    }
; 3404 : }

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
_get_user_palette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_builtin_palette
_TEXT	SEGMENT
_m$ = -264						; size = 4
_str$ = -260						; size = 256
_tmp$ = -4						; size = 4
_get_builtin_palette PROC				; COMDAT

; 3358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3359 :    int tmp;
; 3360 :    char str[256];
; 3361 :    man_calc_struct *m;
; 3362 : 
; 3363 :    m = &main_man_calc_struct;

  0000c	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3364 : 
; 3365 :    GetDlgItemText(hwnd_dialog, IDC_PALETTE, str, sizeof(str));

  00016	68 00 01 00 00	 push	 256			; 00000100H
  0001b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00021	50		 push	 eax
  00022	68 03 04 00 00	 push	 1027			; 00000403H
  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_dialog
  0002d	51		 push	 ecx
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemTextA@16

; 3366 : 
; 3367 :    if ((tmp = get_string_index(str, palette_strs, NUM_ELEM(palette_strs))) >= 0)

  00034	6a 0e		 push	 14			; 0000000eH
  00036	68 00 00 00 00	 push	 OFFSET _palette_strs
  0003b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _get_string_index
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	89 45 fc	 mov	 DWORD PTR _tmp$[ebp], eax
  0004d	83 7d fc 00	 cmp	 DWORD PTR _tmp$[ebp], 0
  00051	7c 16		 jl	 SHORT $LN2@get_builti

; 3368 :    {
; 3369 :       m->palette = tmp;

  00053	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _tmp$[ebp]
  0005c	89 88 f4 8d 00
	00		 mov	 DWORD PTR [eax+36340], ecx

; 3370 :       return 1;

  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	eb 02		 jmp	 SHORT $LN1@get_builti
$LN2@get_builti:

; 3371 :    }
; 3372 :    return 0;

  00069	33 c0		 xor	 eax, eax
$LN1@get_builti:

; 3373 : }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_get_builtin_palette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_string_index
_TEXT	SEGMENT
_i$ = -4						; size = 4
_str$ = 8						; size = 4
_strs$ = 12						; size = 4
_num_strs$ = 16						; size = 4
_get_string_index PROC					; COMDAT

; 3348 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3349 :    int i;
; 3350 :    for (i = 0; i < num_strs; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@get_string
$LN2@get_string:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@get_string:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 45 10	 cmp	 eax, DWORD PTR _num_strs$[ebp]
  00021	7d 21		 jge	 SHORT $LN3@get_string

; 3351 :       if (!strcmp(str, strs[i]))

  00023	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _strs$[ebp]
  00029	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0002c	52		 push	 edx
  0002d	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _strcmp
  00036	83 c4 08	 add	 esp, 8
  00039	85 c0		 test	 eax, eax
  0003b	75 05		 jne	 SHORT $LN5@get_string

; 3352 :          return i;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00040	eb 05		 jmp	 SHORT $LN1@get_string
$LN5@get_string:
  00042	eb ce		 jmp	 SHORT $LN2@get_string
$LN3@get_string:

; 3353 :    return -1;

  00044	83 c8 ff	 or	 eax, -1
$LN1@get_string:

; 3354 : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_get_string_index ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _init_combo_box
_TEXT	SEGMENT
_i$ = -4						; size = 4
_hwnd$ = 8						; size = 4
_dlg_item$ = 12						; size = 4
_strs$ = 16						; size = 4
_n$ = 20						; size = 4
_default_selection$ = 24				; size = 4
_init_combo_box PROC					; COMDAT

; 3336 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3337 :    int i;
; 3338 :    // Initialize all the strings
; 3339 :    for (i = 0; i < n; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@init_combo
$LN2@init_combo:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@init_combo:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 45 14	 cmp	 eax, DWORD PTR _n$[ebp]
  00021	7d 21		 jge	 SHORT $LN3@init_combo

; 3340 :       SendDlgItemMessage(hwnd, dlg_item, CB_ADDSTRING, 0, (LPARAM) strs[i]);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00026	8b 4d 10	 mov	 ecx, DWORD PTR _strs$[ebp]
  00029	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0002c	52		 push	 edx
  0002d	6a 00		 push	 0
  0002f	68 43 01 00 00	 push	 323			; 00000143H
  00034	8b 45 0c	 mov	 eax, DWORD PTR _dlg_item$[ebp]
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0003b	51		 push	 ecx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
  00042	eb ce		 jmp	 SHORT $LN2@init_combo
$LN3@init_combo:

; 3341 : 
; 3342 :    // Set the default selection
; 3343 :    SendDlgItemMessage(hwnd, dlg_item, CB_SETCURSEL, default_selection, 0);

  00044	6a 00		 push	 0
  00046	8b 45 18	 mov	 eax, DWORD PTR _default_selection$[ebp]
  00049	50		 push	 eax
  0004a	68 4e 01 00 00	 push	 334			; 0000014eH
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _dlg_item$[ebp]
  00052	51		 push	 ecx
  00053	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00056	52		 push	 edx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 3344 : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_init_combo_box ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _create_bitmap
_TEXT	SEGMENT
tv155 = -136						; size = 4
_m$ = -68						; size = 4
_bmihsize$ = -64					; size = 4
_err$ = -60						; size = 4
_j$ = -56						; size = 4
_i$ = -52						; size = 4
_h$ = -48						; size = 4
_bmi$ = -44						; size = 44
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_create_bitmap PROC					; COMDAT

; 3271 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3272 :    BITMAPINFO bmi;
; 3273 :    BITMAPINFOHEADER *h;
; 3274 :    int i, j, err;
; 3275 :    int bmihsize = sizeof(BITMAPINFOHEADER);

  0000c	c7 45 c0 28 00
	00 00		 mov	 DWORD PTR _bmihsize$[ebp], 40 ; 00000028H

; 3276 :    static int prev_width = 0;
; 3277 :    static int prev_height = 0;
; 3278 :    man_calc_struct *m;
; 3279 : 
; 3280 :    m = &main_man_calc_struct;

  00013	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3281 : 
; 3282 :    // If size didn't change, return
; 3283 :    if (prev_width == width && prev_height == height)

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?prev_width@?1??create_bitmap@@9@9
  0001f	3b 45 08	 cmp	 eax, DWORD PTR _width$[ebp]
  00022	75 11		 jne	 SHORT $LN14@create_bit
  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ?prev_height@?1??create_bitmap@@9@9
  00029	3b 45 0c	 cmp	 eax, DWORD PTR _height$[ebp]
  0002c	75 07		 jne	 SHORT $LN14@create_bit

; 3284 :       return 0;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 28 02 00 00	 jmp	 $LN1@create_bit
$LN14@create_bit:

; 3285 : 
; 3286 :    // free any existing arrays/bitmaps
; 3287 :    if (m->iter_data_start != NULL)

  00035	8b 45 bc	 mov	 eax, DWORD PTR _m$[ebp]
  00038	83 b8 dc 8d 00
	00 00		 cmp	 DWORD PTR [eax+36316], 0
  0003f	74 2b		 je	 SHORT $LN15@create_bit

; 3288 :       for (i = 0; i < 4; i++)

  00041	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00048	eb 09		 jmp	 SHORT $LN4@create_bit
$LN2@create_bit:
  0004a	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  0004d	83 c0 01	 add	 eax, 1
  00050	89 45 cc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@create_bit:
  00053	83 7d cc 04	 cmp	 DWORD PTR _i$[ebp], 4
  00057	7d 13		 jge	 SHORT $LN15@create_bit

; 3289 :          DeleteObject(quad[i].handle);

  00059	6b 45 cc 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  0005d	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _quad[eax+4]
  00063	51		 push	 ecx
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  0006a	eb de		 jmp	 SHORT $LN2@create_bit
$LN15@create_bit:

; 3290 :    free_man_mem(m);

  0006c	8b 45 bc	 mov	 eax, DWORD PTR _m$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _free_man_mem
  00075	83 c4 04	 add	 esp, 4

; 3291 : 
; 3292 :    memset(&bmi, 0, bmihsize);

  00078	8b 45 c0	 mov	 eax, DWORD PTR _bmihsize$[ebp]
  0007b	50		 push	 eax
  0007c	6a 00		 push	 0
  0007e	8d 4d d4	 lea	 ecx, DWORD PTR _bmi$[ebp]
  00081	51		 push	 ecx
  00082	e8 00 00 00 00	 call	 _memset
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3293 :    h = &bmi.bmiHeader;

  0008a	8d 45 d4	 lea	 eax, DWORD PTR _bmi$[ebp]
  0008d	89 45 d0	 mov	 DWORD PTR _h$[ebp], eax

; 3294 :    h->biSize         = bmihsize;

  00090	8b 45 d0	 mov	 eax, DWORD PTR _h$[ebp]
  00093	8b 4d c0	 mov	 ecx, DWORD PTR _bmihsize$[ebp]
  00096	89 08		 mov	 DWORD PTR [eax], ecx

; 3295 :    h->biWidth        = width;

  00098	8b 45 d0	 mov	 eax, DWORD PTR _h$[ebp]
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  0009e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3296 :    h->biHeight       = -height;

  000a1	8b 45 0c	 mov	 eax, DWORD PTR _height$[ebp]
  000a4	f7 d8		 neg	 eax
  000a6	8b 4d d0	 mov	 ecx, DWORD PTR _h$[ebp]
  000a9	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 3297 :    h->biPlanes       = 1;

  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	8b 4d d0	 mov	 ecx, DWORD PTR _h$[ebp]
  000b4	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 3298 :    h->biBitCount     = 32;

  000b8	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000bd	8b 4d d0	 mov	 ecx, DWORD PTR _h$[ebp]
  000c0	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 3299 :    h->biCompression  = BI_RGB;

  000c4	8b 45 d0	 mov	 eax, DWORD PTR _h$[ebp]
  000c7	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3300 : 
; 3301 :    // Create the 4 quadrant bitmaps
; 3302 :    err = 0;

  000ce	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _err$[ebp], 0

; 3303 :    for (i = 0; i < 4; i++)

  000d5	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000dc	eb 09		 jmp	 SHORT $LN7@create_bit
$LN5@create_bit:
  000de	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  000e1	83 c0 01	 add	 eax, 1
  000e4	89 45 cc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@create_bit:
  000e7	83 7d cc 04	 cmp	 DWORD PTR _i$[ebp], 4
  000eb	7d 3c		 jge	 SHORT $LN6@create_bit

; 3304 :    {
; 3305 :       quad[i].handle = CreateDIBSection(NULL, &bmi, DIB_RGB_COLORS, (void**)&quad[i].bitmap_data, NULL, 0);

  000ed	6a 00		 push	 0
  000ef	6a 00		 push	 0
  000f1	6b 45 cc 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  000f5	05 1c 00 00 00	 add	 eax, OFFSET _quad+28
  000fa	50		 push	 eax
  000fb	6a 00		 push	 0
  000fd	8d 4d d4	 lea	 ecx, DWORD PTR _bmi$[ebp]
  00100	51		 push	 ecx
  00101	6a 00		 push	 0
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDIBSection@24
  00109	6b 55 cc 38	 imul	 edx, DWORD PTR _i$[ebp], 56
  0010d	89 82 04 00 00
	00		 mov	 DWORD PTR _quad[edx+4], eax

; 3306 :       if (!quad[i].handle)

  00113	6b 45 cc 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  00117	83 b8 04 00 00
	00 00		 cmp	 DWORD PTR _quad[eax+4], 0
  0011e	75 07		 jne	 SHORT $LN16@create_bit

; 3307 :          err = 1;

  00120	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR _err$[ebp], 1
$LN16@create_bit:

; 3308 :    }

  00127	eb b5		 jmp	 SHORT $LN5@create_bit
$LN6@create_bit:

; 3309 : 
; 3310 :    if (!hscreen_dc || err || !alloc_man_mem(&main_man_calc_struct, width, height))

  00129	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hscreen_dc, 0
  00130	74 1f		 je	 SHORT $LN18@create_bit
  00132	83 7d c4 00	 cmp	 DWORD PTR _err$[ebp], 0
  00136	75 19		 jne	 SHORT $LN18@create_bit
  00138	8b 45 0c	 mov	 eax, DWORD PTR _height$[ebp]
  0013b	50		 push	 eax
  0013c	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  0013f	51		 push	 ecx
  00140	68 00 00 00 00	 push	 OFFSET _main_man_calc_struct
  00145	e8 00 00 00 00	 call	 _alloc_man_mem
  0014a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014d	85 c0		 test	 eax, eax
  0014f	75 14		 jne	 SHORT $LN17@create_bit
$LN18@create_bit:

; 3311 :    {
; 3312 :       MessageBox(NULL, "Error allocating storage arrays.", NULL, MB_OK | MB_ICONSTOP | MB_TASKMODAL);

  00151	68 10 20 00 00	 push	 8208			; 00002010H
  00156	6a 00		 push	 0
  00158	68 00 00 00 00	 push	 OFFSET $SG41548
  0015d	6a 00		 push	 0
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN17@create_bit:

; 3313 :       // really should exit cleanly here... subsequent code will crash
; 3314 :    }
; 3315 : 
; 3316 :    update_re_im(m, m->pan_xoffs, m->pan_yoffs); // update re/im from any pan offsets and reset offsets

  00165	8b 45 bc	 mov	 eax, DWORD PTR _m$[ebp]
  00168	8b 88 a4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36260]
  0016e	51		 push	 ecx
  0016f	8b 90 a0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36256]
  00175	52		 push	 edx
  00176	8b 45 bc	 mov	 eax, DWORD PTR _m$[ebp]
  00179	8b 88 9c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36252]
  0017f	51		 push	 ecx
  00180	8b 90 98 8d 00
	00		 mov	 edx, DWORD PTR [eax+36248]
  00186	52		 push	 edx
  00187	8b 45 bc	 mov	 eax, DWORD PTR _m$[ebp]
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _update_re_im
  00190	83 c4 14	 add	 esp, 20			; 00000014H

; 3317 :    status |= STAT_NEED_RECALC;         // resized; need to recalculate entire image

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00198	83 c8 01	 or	 eax, 1
  0019b	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 3318 :    prev_width = width;

  001a0	8b 45 08	 mov	 eax, DWORD PTR _width$[ebp]
  001a3	a3 00 00 00 00	 mov	 DWORD PTR ?prev_width@?1??create_bitmap@@9@9, eax

; 3319 :    prev_height = height;

  001a8	8b 45 0c	 mov	 eax, DWORD PTR _height$[ebp]
  001ab	a3 00 00 00 00	 mov	 DWORD PTR ?prev_height@?1??create_bitmap@@9@9, eax

; 3320 :    m->min_dimension = (width < height) ? width: height; // set smaller dimension

  001b0	8b 45 08	 mov	 eax, DWORD PTR _width$[ebp]
  001b3	3b 45 0c	 cmp	 eax, DWORD PTR _height$[ebp]
  001b6	7d 0b		 jge	 SHORT $LN20@create_bit
  001b8	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  001bb	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv155[ebp], ecx
  001c1	eb 09		 jmp	 SHORT $LN21@create_bit
$LN20@create_bit:
  001c3	8b 55 0c	 mov	 edx, DWORD PTR _height$[ebp]
  001c6	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv155[ebp], edx
$LN21@create_bit:
  001cc	8b 45 bc	 mov	 eax, DWORD PTR _m$[ebp]
  001cf	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv155[ebp]
  001d5	89 88 90 8d 00
	00		 mov	 DWORD PTR [eax+36240], ecx

; 3321 : 
; 3322 :    // Precalculate pointer offsets of neighboring pixels for the fast "wave" algorithm
; 3323 :    // (these only change when image width changes). Not needed for save
; 3324 :    for (j = 1; j < 7; j++)

  001db	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1
  001e2	eb 09		 jmp	 SHORT $LN10@create_bit
$LN8@create_bit:
  001e4	8b 45 c8	 mov	 eax, DWORD PTR _j$[ebp]
  001e7	83 c0 01	 add	 eax, 1
  001ea	89 45 c8	 mov	 DWORD PTR _j$[ebp], eax
$LN10@create_bit:
  001ed	83 7d c8 07	 cmp	 DWORD PTR _j$[ebp], 7
  001f1	7d 56		 jge	 SHORT $LN9@create_bit

; 3325 :       for (i = 0; i < 4; i++)

  001f3	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001fa	eb 09		 jmp	 SHORT $LN13@create_bit
$LN11@create_bit:
  001fc	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  001ff	83 c0 01	 add	 eax, 1
  00202	89 45 cc	 mov	 DWORD PTR _i$[ebp], eax
$LN13@create_bit:
  00205	83 7d cc 04	 cmp	 DWORD PTR _i$[ebp], 4
  00209	7d 3c		 jge	 SHORT $LN12@create_bit

; 3326 :          wave_ptr_offs[j][i] = wave_yoffs[j][i] * m->iter_data_line_size + wave_xoffs[j][i];

  0020b	8b 45 c8	 mov	 eax, DWORD PTR _j$[ebp]
  0020e	c1 e0 04	 shl	 eax, 4
  00211	8b 4d cc	 mov	 ecx, DWORD PTR _i$[ebp]
  00214	8b 55 bc	 mov	 edx, DWORD PTR _m$[ebp]
  00217	8b 84 88 00 00
	00 00		 mov	 eax, DWORD PTR _wave_yoffs[eax+ecx*4]
  0021e	0f af 82 e4 8d
	00 00		 imul	 eax, DWORD PTR [edx+36324]
  00225	8b 4d c8	 mov	 ecx, DWORD PTR _j$[ebp]
  00228	c1 e1 04	 shl	 ecx, 4
  0022b	8b 55 cc	 mov	 edx, DWORD PTR _i$[ebp]
  0022e	03 84 91 00 00
	00 00		 add	 eax, DWORD PTR _wave_xoffs[ecx+edx*4]
  00235	8b 4d c8	 mov	 ecx, DWORD PTR _j$[ebp]
  00238	c1 e1 04	 shl	 ecx, 4
  0023b	8b 55 cc	 mov	 edx, DWORD PTR _i$[ebp]
  0023e	89 84 91 00 00
	00 00		 mov	 DWORD PTR _wave_ptr_offs[ecx+edx*4], eax
  00245	eb b5		 jmp	 SHORT $LN11@create_bit
$LN12@create_bit:
  00247	eb 9b		 jmp	 SHORT $LN8@create_bit
$LN9@create_bit:

; 3327 : 
; 3328 :    reset_quadrants();   // reset to recalculate all

  00249	e8 00 00 00 00	 call	 _reset_quadrants

; 3329 :    reset_fps_values();  // reset frames/sec timing values

  0024e	e8 00 00 00 00	 call	 _reset_fps_values

; 3330 :    reset_pan_state();   // reset pan filters and movement state

  00253	e8 00 00 00 00	 call	 _reset_pan_state

; 3331 : 
; 3332 :    return 1;

  00258	b8 01 00 00 00	 mov	 eax, 1
$LN1@create_bit:

; 3333 : }

  0025d	5f		 pop	 edi
  0025e	5e		 pop	 esi
  0025f	5b		 pop	 ebx
  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c3		 ret	 0
_create_bitmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _free_man_mem
_TEXT	SEGMENT
_m$ = 8							; size = 4
_free_man_mem PROC					; COMDAT

; 3251 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3252 :    if (m->iter_data_start != NULL)

  00009	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0000c	83 b8 dc 8d 00
	00 00		 cmp	 DWORD PTR [eax+36316], 0
  00013	74 66		 je	 SHORT $LN1@free_man_m

; 3253 :    {
; 3254 :       free(m->iter_data_start);

  00015	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00018	8b 88 dc 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36316]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _free
  00024	83 c4 04	 add	 esp, 4

; 3255 :       free(m->mag_data);

  00027	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0002a	8b 88 e8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36328]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _free
  00036	83 c4 04	 add	 esp, 4

; 3256 :       free(m->img_re);

  00039	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0003c	8b 88 d4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36308]
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 _free
  00048	83 c4 04	 add	 esp, 4

; 3257 :       free(m->img_im);

  0004b	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0004e	8b 88 d8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36312]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _free
  0005a	83 c4 04	 add	 esp, 4

; 3258 :       if (m->png_buffer != NULL)

  0005d	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00060	83 b8 f0 8d 00
	00 00		 cmp	 DWORD PTR [eax+36336], 0
  00067	74 12		 je	 SHORT $LN1@free_man_m

; 3259 :          free(m->png_buffer);

  00069	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0006c	8b 88 f0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36336]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 _free
  00078	83 c4 04	 add	 esp, 4
$LN1@free_man_m:

; 3260 :    }
; 3261 : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_free_man_mem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _alloc_man_mem
_TEXT	SEGMENT
_n$ = -4						; size = 4
_m$ = 8							; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_alloc_man_mem PROC					; COMDAT

; 3208 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3209 :    int n;
; 3210 : 
; 3211 :    m->iter_data_line_size = width + 2;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0000c	83 c0 02	 add	 eax, 2
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  00012	89 81 e4 8d 00
	00		 mov	 DWORD PTR [ecx+36324], eax

; 3212 :    m->image_size = width * height; // new image size

  00018	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0001b	0f af 45 10	 imul	 eax, DWORD PTR _height$[ebp]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  00022	89 81 94 8d 00
	00		 mov	 DWORD PTR [ecx+36244], eax

; 3213 : 
; 3214 :    // Because the fast algorithm checks offsets from the current pixel location, iter_data needs dummy
; 3215 :    // lines to accomodate off-screen checks. Needs one line at y = -1, and 6 at y = ysize. Also needs
; 3216 :    // two dummy pixels at the end of each line.
; 3217 : 
; 3218 :    // Need separate pointer to be able to free later
; 3219 : 
; 3220 :    m->iter_data_start = (unsigned *) malloc(n = m->iter_data_line_size * (height + 7) * sizeof(m->iter_data_start[0]));

  00028	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0002b	83 c0 07	 add	 eax, 7
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  00031	0f af 81 e4 8d
	00 00		 imul	 eax, DWORD PTR [ecx+36324]
  00038	c1 e0 02	 shl	 eax, 2
  0003b	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 _malloc
  00047	83 c4 04	 add	 esp, 4
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0004d	89 81 dc 8d 00
	00		 mov	 DWORD PTR [ecx+36316], eax

; 3221 :    if (m->iter_data_start != NULL)

  00053	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00056	83 b8 dc 8d 00
	00 00		 cmp	 DWORD PTR [eax+36316], 0
  0005d	74 18		 je	 SHORT $LN2@alloc_man_

; 3222 :       memset(m->iter_data_start, 0, n);

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00062	50		 push	 eax
  00063	6a 00		 push	 0
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  00068	8b 91 dc 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36316]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 _memset
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@alloc_man_:

; 3223 : 
; 3224 :    m->iter_data = m->iter_data_start + m->iter_data_line_size; // create dummy lines at y = -1 for fast alg

  00077	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0007a	8b 88 e4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36324]
  00080	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00083	8b 82 dc 8d 00
	00		 mov	 eax, DWORD PTR [edx+36316]
  00089	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  0008c	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  0008f	89 8a e0 8d 00
	00		 mov	 DWORD PTR [edx+36320], ecx

; 3225 : 
; 3226 :    // Create a corresponding array for the magnitudes. Don't really need the dummy lines but this
; 3227 :    // allows using a fixed offset from iter_data
; 3228 :    m->mag_data = (float *) malloc(m->iter_data_line_size * (height + 7) * sizeof(m->mag_data[0]));

  00095	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  00098	83 c0 07	 add	 eax, 7
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0009e	0f af 81 e4 8d
	00 00		 imul	 eax, DWORD PTR [ecx+36324]
  000a5	c1 e0 02	 shl	 eax, 2
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _malloc
  000ae	83 c4 04	 add	 esp, 4
  000b1	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  000b4	89 82 e8 8d 00
	00		 mov	 DWORD PTR [edx+36328], eax

; 3229 : 
; 3230 :    m->mag_data_offs = (int)((char *) m->mag_data - (char *) m->iter_data);

  000ba	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  000c0	8b 90 e8 8d 00
	00		 mov	 edx, DWORD PTR [eax+36328]
  000c6	2b 91 e0 8d 00
	00		 sub	 edx, DWORD PTR [ecx+36320]
  000cc	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  000cf	89 90 ec 8d 00
	00		 mov	 DWORD PTR [eax+36332], edx

; 3231 : 
; 3232 :    // These two need 4 extra dummy values
; 3233 :    m->img_re = (double *) malloc((width + 4) * sizeof(m->img_re[0]));

  000d5	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  000d8	8d 0c c5 20 00
	00 00		 lea	 ecx, DWORD PTR [eax*8+32]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _malloc
  000e5	83 c4 04	 add	 esp, 4
  000e8	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  000eb	89 82 d4 8d 00
	00		 mov	 DWORD PTR [edx+36308], eax

; 3234 :    m->img_im = (double *) malloc((height + 4) * sizeof(m->img_im[0]));

  000f1	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  000f4	8d 0c c5 20 00
	00 00		 lea	 ecx, DWORD PTR [eax*8+32]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 _malloc
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00107	89 82 d8 8d 00
	00		 mov	 DWORD PTR [edx+36312], eax

; 3235 : 
; 3236 :    // Buffer for PNG save (not needed for main calculation). 4 bytes per pixel
; 3237 :    if (m->flags & FLAG_IS_SAVE)

  0010d	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00110	8b 88 0c 93 02
	00		 mov	 ecx, DWORD PTR [eax+168716]
  00116	83 e1 01	 and	 ecx, 1
  00119	74 2c		 je	 SHORT $LN3@alloc_man_

; 3238 :    {
; 3239 :       m->png_buffer = (unsigned char *) malloc((width << 2) * height * sizeof(unsigned char));

  0011b	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0011e	c1 e0 02	 shl	 eax, 2
  00121	0f af 45 10	 imul	 eax, DWORD PTR _height$[ebp]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _malloc
  0012b	83 c4 04	 add	 esp, 4
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  00131	89 81 f0 8d 00
	00		 mov	 DWORD PTR [ecx+36336], eax

; 3240 :       if (m->png_buffer == NULL)

  00137	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0013a	83 b8 f0 8d 00
	00 00		 cmp	 DWORD PTR [eax+36336], 0
  00141	75 04		 jne	 SHORT $LN3@alloc_man_

; 3241 :          return 0;

  00143	33 c0		 xor	 eax, eax
  00145	eb 39		 jmp	 SHORT $LN1@alloc_man_
$LN3@alloc_man_:

; 3242 :    }
; 3243 : 
; 3244 :    if (m->iter_data_start == NULL || m->mag_data == NULL || m->img_re == NULL || m->img_im == NULL)

  00147	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0014a	83 b8 dc 8d 00
	00 00		 cmp	 DWORD PTR [eax+36316], 0
  00151	74 24		 je	 SHORT $LN6@alloc_man_
  00153	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00156	83 b8 e8 8d 00
	00 00		 cmp	 DWORD PTR [eax+36328], 0
  0015d	74 18		 je	 SHORT $LN6@alloc_man_
  0015f	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00162	83 b8 d4 8d 00
	00 00		 cmp	 DWORD PTR [eax+36308], 0
  00169	74 0c		 je	 SHORT $LN6@alloc_man_
  0016b	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0016e	83 b8 d8 8d 00
	00 00		 cmp	 DWORD PTR [eax+36312], 0
  00175	75 04		 jne	 SHORT $LN5@alloc_man_
$LN6@alloc_man_:

; 3245 :       return 0;

  00177	33 c0		 xor	 eax, eax
  00179	eb 05		 jmp	 SHORT $LN1@alloc_man_
$LN5@alloc_man_:

; 3246 :    return 1;

  0017b	b8 01 00 00 00	 mov	 eax, 1
$LN1@alloc_man_:

; 3247 : }

  00180	5f		 pop	 edi
  00181	5e		 pop	 esi
  00182	5b		 pop	 ebx
  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c3		 ret	 0
_alloc_man_mem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_cpu_info
_TEXT	SEGMENT
_m$ = -60						; size = 4
_info$ = -56						; size = 36
_features$ = -20					; size = 4
_vendor$ = -16						; size = 16
_get_cpu_info PROC					; COMDAT

; 3139 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3140 :    unsigned vendor[4];
; 3141 :    unsigned features;
; 3142 :    SYSTEM_INFO info;
; 3143 :    man_calc_struct *m;
; 3144 : 
; 3145 :    m = &main_man_calc_struct;

  00009	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3146 : 
; 3147 :    vendor[3] = 0;

  00010	b8 04 00 00 00	 mov	 eax, 4
  00015	6b c8 03	 imul	 ecx, eax, 3
  00018	c7 44 0d f0 00
	00 00 00	 mov	 DWORD PTR _vendor$[ebp+ecx], 0

; 3148 : 
; 3149 :    __asm
; 3150 :    {
; 3151 :       // If the (ancient) CPU doesn't support the CPUID instruction, we would never get here...
; 3152 : 
; 3153 :       xor eax, eax   // get vendor

  00020	33 c0		 xor	 eax, eax

; 3154 :       cpuid

  00022	0f a2		 cpuid

; 3155 :       mov vendor,     ebx

  00024	89 5d f0	 mov	 DWORD PTR _vendor$[ebp], ebx

; 3156 :       mov vendor + 4, edx

  00027	89 55 f4	 mov	 DWORD PTR _vendor$[ebp+4], edx

; 3157 :       mov vendor + 8, ecx

  0002a	89 4d f8	 mov	 DWORD PTR _vendor$[ebp+8], ecx

; 3158 :       mov eax, 1     // get features

  0002d	b8 01 00 00 00	 mov	 eax, 1

; 3159 :       cpuid

  00032	0f a2		 cpuid

; 3160 :       mov features, edx

  00034	89 55 ec	 mov	 DWORD PTR _features$[ebp], edx

; 3161 :    }
; 3162 : 
; 3163 :    // Use vendor to select default algorithm
; 3164 :    if (!strcmp((const char *) vendor, "AuthenticAMD"))

  00037	68 00 00 00 00	 push	 OFFSET $SG41455
  0003c	8d 45 f0	 lea	 eax, DWORD PTR _vendor$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _strcmp
  00045	83 c4 08	 add	 esp, 8
  00048	85 c0		 test	 eax, eax
  0004a	75 0f		 jne	 SHORT $LN5@get_cpu_in

; 3165 :       m->alg = ALG_FAST_ASM_AMD;

  0004c	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  0004f	c7 80 c8 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36296], 0
  00059	eb 0d		 jmp	 SHORT $LN6@get_cpu_in
$LN5@get_cpu_in:

; 3166 :    else
; 3167 :       m->alg = ALG_FAST_ASM_INTEL;

  0005b	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  0005e	c7 80 c8 8d 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+36296], 2
$LN6@get_cpu_in:

; 3168 : 
; 3169 :    // Set exact alg if configured by quickman.cfg options field
; 3170 :    if (cfg_settings.options.val & OPT_EXACT_ALG)

  00068	a1 a4 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+164
  0006d	83 e0 08	 and	 eax, 8
  00070	74 15		 je	 SHORT $LN7@get_cpu_in

; 3171 :       m->alg |= ALG_EXACT;

  00072	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  00075	8b 88 c8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36296]
  0007b	83 c9 01	 or	 ecx, 1
  0007e	8b 55 c4	 mov	 edx, DWORD PTR _m$[ebp]
  00081	89 8a c8 8d 00
	00		 mov	 DWORD PTR [edx+36296], ecx
$LN7@get_cpu_in:

; 3172 : 
; 3173 :    sse_support = 0;

  00087	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _sse_support, 0

; 3174 :    if ((features & (FEATURE_SSE | FEATURE_CMOV)) == (FEATURE_SSE | FEATURE_CMOV))

  00091	8b 45 ec	 mov	 eax, DWORD PTR _features$[ebp]
  00094	25 00 80 00 02	 and	 eax, 33587200		; 02008000H
  00099	3d 00 80 00 02	 cmp	 eax, 33587200		; 02008000H
  0009e	75 0a		 jne	 SHORT $LN8@get_cpu_in

; 3175 :       sse_support = 1;

  000a0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _sse_support, 1
$LN8@get_cpu_in:

; 3176 :    if ((features & (FEATURE_SSE2 | FEATURE_CMOV)) == (FEATURE_SSE2 | FEATURE_CMOV))

  000aa	8b 45 ec	 mov	 eax, DWORD PTR _features$[ebp]
  000ad	25 00 80 00 04	 and	 eax, 67141632		; 04008000H
  000b2	3d 00 80 00 04	 cmp	 eax, 67141632		; 04008000H
  000b7	75 0a		 jne	 SHORT $LN9@get_cpu_in

; 3177 :       sse_support = 2;

  000b9	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _sse_support, 2
$LN9@get_cpu_in:

; 3178 : 
; 3179 :    if (sse_support < 2)

  000c3	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _sse_support, 2
  000ca	7d 2d		 jge	 SHORT $LN10@get_cpu_in

; 3180 :    {
; 3181 :       MessageBox(NULL, "Your (obsolete) CPU does not support SSE2 instructions.\r\n"

  000cc	68 10 20 00 00	 push	 8208			; 00002010H
  000d1	68 00 00 00 00	 push	 OFFSET $SG41460
  000d6	68 00 00 00 00	 push	 OFFSET $SG41461
  000db	6a 00		 push	 0
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 3182 :                        "Performance will be suboptimal.",  "Warning", MB_OK | MB_ICONSTOP | MB_TASKMODAL);
; 3183 : 
; 3184 :       // Ok to stay in auto precision mode with only sse support- will switch
; 3185 :       // to C algorithm for double. If no sse support, no choice but to use C
; 3186 :       if (!sse_support)

  000e3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _sse_support, 0
  000ea	75 0d		 jne	 SHORT $LN10@get_cpu_in

; 3187 :          m->alg = ALG_FAST_C;

  000ec	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  000ef	c7 80 c8 8d 00
	00 04 00 00 00	 mov	 DWORD PTR [eax+36296], 4
$LN10@get_cpu_in:

; 3188 :    }
; 3189 : 
; 3190 :    // Set the default number of threads to the number of cores. Does this count a hyperthreading
; 3191 :    // single core as more than one core? Should ignore these as hyperthreading won't help.
; 3192 :    GetSystemInfo(&info);

  000f9	8d 45 c8	 lea	 eax, DWORD PTR _info$[ebp]
  000fc	50		 push	 eax
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4

; 3193 :    num_threads = info.dwNumberOfProcessors;

  00103	8b 45 dc	 mov	 eax, DWORD PTR _info$[ebp+20]
  00106	a3 00 00 00 00	 mov	 DWORD PTR _num_threads, eax

; 3194 : 
; 3195 :    // Convert number of threads (cores) to a selection index for the dropdown box
; 3196 : 
; 3197 :    // Get log2(num_threads)
; 3198 :    for (num_threads_ind = 0; num_threads_ind <= MAX_THREADS_IND; num_threads_ind++)

  0010b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _num_threads_ind, 0
  00115	eb 0d		 jmp	 SHORT $LN4@get_cpu_in
$LN2@get_cpu_in:
  00117	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_threads_ind
  0011c	83 c0 01	 add	 eax, 1
  0011f	a3 00 00 00 00	 mov	 DWORD PTR _num_threads_ind, eax
$LN4@get_cpu_in:
  00124	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _num_threads_ind, 5
  0012b	7f 19		 jg	 SHORT $LN3@get_cpu_in

; 3199 :       if ((1 << num_threads_ind) >= num_threads)

  0012d	b8 01 00 00 00	 mov	 eax, 1
  00132	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _num_threads_ind
  00138	d3 e0		 shl	 eax, cl
  0013a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _num_threads
  00140	7c 02		 jl	 SHORT $LN12@get_cpu_in

; 3200 :          break;

  00142	eb 02		 jmp	 SHORT $LN3@get_cpu_in
$LN12@get_cpu_in:
  00144	eb d1		 jmp	 SHORT $LN2@get_cpu_in
$LN3@get_cpu_in:

; 3201 : 
; 3202 :    num_threads = 1 << num_threads_ind;

  00146	b8 01 00 00 00	 mov	 eax, 1
  0014b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _num_threads_ind
  00151	d3 e0		 shl	 eax, cl
  00153	a3 00 00 00 00	 mov	 DWORD PTR _num_threads, eax

; 3203 : }

  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	5b		 pop	 ebx
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c3		 ret	 0
_get_cpu_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _init_man
_TEXT	SEGMENT
tv75 = -88						; size = 4
tv70 = -88						; size = 4
tv67 = -88						; size = 4
_m$ = -20						; size = 4
_e$ = -16						; size = 4
_ps_ptr$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_init_man PROC						; COMDAT

; 3088 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3089 :    int i, j;
; 3090 :    man_pointstruct *ps_ptr;
; 3091 :    HANDLE e;
; 3092 :    man_calc_struct *m;
; 3093 : 
; 3094 :    for (j = 0; j < 2; j++) // Initialize both main and save calculation structures

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@init_man
$LN2@init_man:
  00012	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN4@init_man:
  0001b	83 7d f8 02	 cmp	 DWORD PTR _j$[ebp], 2
  0001f	0f 8d 90 02 00
	00		 jge	 $LN3@init_man

; 3095 :    {
; 3096 :       m = j ? &save_man_calc_struct : &main_man_calc_struct;

  00025	83 7d f8 00	 cmp	 DWORD PTR _j$[ebp], 0
  00029	74 09		 je	 SHORT $LN9@init_man
  0002b	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], OFFSET _save_man_calc_struct
  00032	eb 07		 jmp	 SHORT $LN10@init_man
$LN9@init_man:
  00034	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], OFFSET _main_man_calc_struct
$LN10@init_man:
  0003b	8b 45 a8	 mov	 eax, DWORD PTR tv67[ebp]
  0003e	89 45 ec	 mov	 DWORD PTR _m$[ebp], eax

; 3097 : 
; 3098 :       m->flags = j ? FLAG_IS_SAVE | FLAG_CALC_RE_ARRAY: FLAG_CALC_RE_ARRAY;

  00041	83 7d f8 00	 cmp	 DWORD PTR _j$[ebp], 0
  00045	74 09		 je	 SHORT $LN11@init_man
  00047	c7 45 a8 03 00
	00 00		 mov	 DWORD PTR tv70[ebp], 3
  0004e	eb 07		 jmp	 SHORT $LN12@init_man
$LN11@init_man:
  00050	c7 45 a8 02 00
	00 00		 mov	 DWORD PTR tv70[ebp], 2
$LN12@init_man:
  00057	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  0005a	8b 4d a8	 mov	 ecx, DWORD PTR tv70[ebp]
  0005d	89 88 0c 93 02
	00		 mov	 DWORD PTR [eax+168716], ecx

; 3099 :       m->palette = DEFAULT_PAL;

  00063	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  00066	c7 80 f4 8d 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+36340], 2

; 3100 :       m->rendering_alg = cfg_settings.options.val & OPT_NORMALIZED ? RALG_NORMALIZED: RALG_STANDARD;

  00070	a1 a4 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+164
  00075	83 e0 04	 and	 eax, 4
  00078	74 09		 je	 SHORT $LN13@init_man
  0007a	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  00081	eb 07		 jmp	 SHORT $LN14@init_man
$LN13@init_man:
  00083	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN14@init_man:
  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _m$[ebp]
  0008d	8b 55 a8	 mov	 edx, DWORD PTR tv75[ebp]
  00090	89 91 04 8e 00
	00		 mov	 DWORD PTR [ecx+36356], edx

; 3101 :       m->precision = PRECISION_AUTO;

  00096	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  00099	c7 80 d0 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36304], 0

; 3102 :       m->mag = HOME_MAG;

  000a3	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  000a6	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff599999999999a
  000ae	f2 0f 11 80 b8
	8d 00 00	 movsd	 QWORD PTR [eax+36280], xmm0

; 3103 :       m->max_iters = HOME_MAX_ITERS;

  000b6	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  000b9	c7 80 c0 8d 00
	00 00 01 00 00	 mov	 DWORD PTR [eax+36288], 256 ; 00000100H

; 3104 : 
; 3105 :       // Initialize the thread state structures
; 3106 :       for (i = 0; i < MAX_THREADS; i++)

  000c3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ca	eb 09		 jmp	 SHORT $LN7@init_man
$LN5@init_man:
  000cc	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@init_man:
  000d5	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000d9	0f 8d d1 01 00
	00		 jge	 $LN6@init_man

; 3107 :       {
; 3108 :          m->thread_states[i].thread_num = i;

  000df	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 168
  000e6	8b 4d ec	 mov	 ecx, DWORD PTR _m$[ebp]
  000e9	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000ec	89 94 01 08 78
	00 00		 mov	 DWORD PTR [ecx+eax+30728], edx

; 3109 :          m->thread_states[i].calc_struct = m;

  000f3	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 168
  000fa	8b 4d ec	 mov	 ecx, DWORD PTR _m$[ebp]
  000fd	8b 55 ec	 mov	 edx, DWORD PTR _m$[ebp]
  00100	89 94 01 98 78
	00 00		 mov	 DWORD PTR [ecx+eax+30872], edx

; 3110 : 
; 3111 :          // Create an auto-reset done event for each thread. The thread sets it when done with a calculation
; 3112 :          e = CreateEvent(NULL, FALSE, FALSE, NULL);

  00107	6a 00		 push	 0
  00109	6a 00		 push	 0
  0010b	6a 00		 push	 0
  0010d	6a 00		 push	 0
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventA@16
  00115	89 45 f0	 mov	 DWORD PTR _e$[ebp], eax

; 3113 :          m->thread_states[i].done_event = e;

  00118	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 168
  0011f	8b 4d ec	 mov	 ecx, DWORD PTR _m$[ebp]
  00122	8b 55 f0	 mov	 edx, DWORD PTR _e$[ebp]
  00125	89 94 01 94 78
	00 00		 mov	 DWORD PTR [ecx+eax+30868], edx

; 3114 :          m->thread_done_events[i] = e;

  0012c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0012f	8b 4d ec	 mov	 ecx, DWORD PTR _m$[ebp]
  00132	8b 55 f0	 mov	 edx, DWORD PTR _e$[ebp]
  00135	89 94 81 08 8d
	00 00		 mov	 DWORD PTR [ecx+eax*4+36104], edx

; 3115 : 
; 3116 :          // Init each thread's point structure
; 3117 :          m->thread_states[i].ps_ptr = ps_ptr = &m->pointstruct_array[i];

  0013c	69 45 fc c0 03
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 960
  00143	03 45 ec	 add	 eax, DWORD PTR _m$[ebp]
  00146	89 45 f4	 mov	 DWORD PTR _ps_ptr$[ebp], eax
  00149	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 168
  00150	8b 55 ec	 mov	 edx, DWORD PTR _m$[ebp]
  00153	8b 45 f4	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  00156	89 84 0a 0c 78
	00 00		 mov	 DWORD PTR [edx+ecx+30732], eax

; 3118 : 
; 3119 :          // Init 64-bit double and 32-bit float fields with divergence radius and constant 2.0
; 3120 :          ps_ptr->two_d[1] = ps_ptr->two_d[0] = 2.0;

  0015d	b8 08 00 00 00	 mov	 eax, 8
  00162	6b c8 00	 imul	 ecx, eax, 0
  00165	8b 55 f4	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  00168	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  00170	f2 0f 11 84 0a
	c0 01 00 00	 movsd	 QWORD PTR [edx+ecx+448], xmm0
  00179	b8 08 00 00 00	 mov	 eax, 8
  0017e	c1 e0 00	 shl	 eax, 0
  00181	8b 4d f4	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00184	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  0018c	f2 0f 11 84 01
	c0 01 00 00	 movsd	 QWORD PTR [ecx+eax+448], xmm0

; 3121 :          ps_ptr->two_f[3] = ps_ptr->two_f[2] = ps_ptr->two_f[1] = ps_ptr->two_f[0] = 2.0;

  00195	b8 04 00 00 00	 mov	 eax, 4
  0019a	6b c8 00	 imul	 ecx, eax, 0
  0019d	8b 55 f4	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  001a0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  001a8	f3 0f 11 84 0a
	00 02 00 00	 movss	 DWORD PTR [edx+ecx+512], xmm0
  001b1	b8 04 00 00 00	 mov	 eax, 4
  001b6	c1 e0 00	 shl	 eax, 0
  001b9	8b 4d f4	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  001bc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  001c4	f3 0f 11 84 01
	00 02 00 00	 movss	 DWORD PTR [ecx+eax+512], xmm0
  001cd	ba 04 00 00 00	 mov	 edx, 4
  001d2	d1 e2		 shl	 edx, 1
  001d4	8b 45 f4	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  001d7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  001df	f3 0f 11 84 10
	00 02 00 00	 movss	 DWORD PTR [eax+edx+512], xmm0
  001e8	b9 04 00 00 00	 mov	 ecx, 4
  001ed	6b d1 03	 imul	 edx, ecx, 3
  001f0	8b 45 f4	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  001f3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  001fb	f3 0f 11 84 10
	00 02 00 00	 movss	 DWORD PTR [eax+edx+512], xmm0

; 3122 : 
; 3123 :          ps_ptr->rad_d[1] = ps_ptr->rad_d[0] = DIVERGED_THRESH;

  00204	b8 08 00 00 00	 mov	 eax, 8
  00209	6b c8 00	 imul	 ecx, eax, 0
  0020c	8b 55 f4	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  0020f	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4030000000000000
  00217	f2 0f 11 84 0a
	40 02 00 00	 movsd	 QWORD PTR [edx+ecx+576], xmm0
  00220	b8 08 00 00 00	 mov	 eax, 8
  00225	c1 e0 00	 shl	 eax, 0
  00228	8b 4d f4	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  0022b	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4030000000000000
  00233	f2 0f 11 84 01
	40 02 00 00	 movsd	 QWORD PTR [ecx+eax+576], xmm0

; 3124 :          ps_ptr->rad_f[3] = ps_ptr->rad_f[2] = ps_ptr->rad_f[1] = ps_ptr->rad_f[0] = DIVERGED_THRESH;

  0023c	b8 04 00 00 00	 mov	 eax, 4
  00241	6b c8 00	 imul	 ecx, eax, 0
  00244	8b 55 f4	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  00247	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41800000
  0024f	f3 0f 11 84 0a
	80 02 00 00	 movss	 DWORD PTR [edx+ecx+640], xmm0
  00258	b8 04 00 00 00	 mov	 eax, 4
  0025d	c1 e0 00	 shl	 eax, 0
  00260	8b 4d f4	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00263	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41800000
  0026b	f3 0f 11 84 01
	80 02 00 00	 movss	 DWORD PTR [ecx+eax+640], xmm0
  00274	ba 04 00 00 00	 mov	 edx, 4
  00279	d1 e2		 shl	 edx, 1
  0027b	8b 45 f4	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  0027e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41800000
  00286	f3 0f 11 84 10
	80 02 00 00	 movss	 DWORD PTR [eax+edx+640], xmm0
  0028f	b9 04 00 00 00	 mov	 ecx, 4
  00294	6b d1 03	 imul	 edx, ecx, 3
  00297	8b 45 f4	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  0029a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41800000
  002a2	f3 0f 11 84 10
	80 02 00 00	 movss	 DWORD PTR [eax+edx+640], xmm0

; 3125 :       }

  002ab	e9 1c fe ff ff	 jmp	 $LN5@init_man
$LN6@init_man:

; 3126 :    }

  002b0	e9 5d fd ff ff	 jmp	 $LN2@init_man
$LN3@init_man:

; 3127 : }

  002b5	5f		 pop	 edi
  002b6	5e		 pop	 esi
  002b7	5b		 pop	 ebx
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c3		 ret	 0
_init_man ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _do_recalc
_TEXT	SEGMENT
_do_recalc PROC						; COMDAT

; 3077 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3078 :    if (status & STAT_RECALC_IMMEDIATELY)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  0000e	83 e0 08	 and	 eax, 8
  00011	74 17		 je	 SHORT $LN2@do_recalc

; 3079 :    {
; 3080 :       do_man_calculate(1);

  00013	6a 01		 push	 1
  00015	e8 00 00 00 00	 call	 _do_man_calculate
  0001a	83 c4 04	 add	 esp, 4

; 3081 :       status &= ~STAT_RECALC_IMMEDIATELY;

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00022	83 e0 f7	 and	 eax, -9			; fffffff7H
  00025	a3 00 00 00 00	 mov	 DWORD PTR _status, eax
$LN2@do_recalc:

; 3082 :    }
; 3083 :    return 0;

  0002a	33 c0		 xor	 eax, eax

; 3084 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_do_recalc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _do_zooming
_TEXT	SEGMENT
tv259 = -100						; size = 8
tv244 = -100						; size = 8
_m$ = -28						; size = 4
_step$ = -24						; size = 8
_done$ = -16						; size = 4
_my$ = -12						; size = 4
_mx$ = -8						; size = 4
_start_time$ = -4					; size = 4
_do_zooming PROC					; COMDAT

; 2996 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2997 :    TIME_UNIT start_time;
; 2998 :    int mx, my, done = 0;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _done$[ebp], 0

; 2999 :    double step;
; 3000 :    man_calc_struct *m;
; 3001 : 
; 3002 :    m = &main_man_calc_struct;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3003 : 
; 3004 :    // If a panning key is pressed, temporarily exit to do the pan, then resume any zooming
; 3005 :    // (but abort zooming started with the zoom button). Need to improve this...
; 3006 :    // Problem is that zoom frame rate is vastly lower than pan rate
; 3007 : 
; 3008 :    if (get_keys_pressed() & PAN_KEY)

  00017	e8 00 00 00 00	 call	 _get_keys_pressed
  0001c	83 e0 0f	 and	 eax, 15			; 0000000fH
  0001f	74 35		 je	 SHORT $LN2@do_zooming

; 3009 :    {
; 3010 :       if (do_rtzoom)

  00021	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _do_rtzoom, 0
  00028	74 20		 je	 SHORT $LN6@do_zooming

; 3011 :          if (!(do_rtzoom & RTZOOM_WITH_BUTTON))

  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR _do_rtzoom
  0002f	83 e0 04	 and	 eax, 4
  00032	75 0c		 jne	 SHORT $LN5@do_zooming

; 3012 :             prev_do_rtzoom = do_rtzoom;

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR _do_rtzoom
  00039	a3 00 00 00 00	 mov	 DWORD PTR _prev_do_rtzoom, eax
  0003e	eb 0a		 jmp	 SHORT $LN6@do_zooming
$LN5@do_zooming:

; 3013 :          else
; 3014 :             prev_do_rtzoom = 0;

  00040	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _prev_do_rtzoom, 0
$LN6@do_zooming:

; 3015 :       do_rtzoom = 0;

  0004a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _do_rtzoom, 0

; 3016 :    }

  00054	eb 6c		 jmp	 SHORT $LN7@do_zooming
$LN2@do_zooming:

; 3017 :    else
; 3018 :    {
; 3019 :       if (prev_do_rtzoom)

  00056	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _prev_do_rtzoom, 0
  0005d	74 63		 je	 SHORT $LN7@do_zooming

; 3020 :       {
; 3021 :          update_re_im(m, m->pan_xoffs, m->pan_yoffs);       // update re/im from any pan offsets and reset offsets

  0005f	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  00062	8b 88 a4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36260]
  00068	51		 push	 ecx
  00069	8b 90 a0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36256]
  0006f	52		 push	 edx
  00070	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  00073	8b 88 9c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36252]
  00079	51		 push	 ecx
  0007a	8b 90 98 8d 00
	00		 mov	 edx, DWORD PTR [eax+36248]
  00080	52		 push	 edx
  00081	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _update_re_im
  0008a	83 c4 14	 add	 esp, 20			; 00000014H

; 3022 :          get_mouse_re_im(mouse_x[1], mouse_y[1]);  // update mouse coords after any pan

  0008d	b8 04 00 00 00	 mov	 eax, 4
  00092	c1 e0 00	 shl	 eax, 0
  00095	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _mouse_y[eax]
  0009b	51		 push	 ecx
  0009c	ba 04 00 00 00	 mov	 edx, 4
  000a1	c1 e2 00	 shl	 edx, 0
  000a4	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_x[edx]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 _get_mouse_re_im
  000b0	83 c4 08	 add	 esp, 8

; 3023 :          reset_pan_state();                        // reset pan so we don't get extra movement

  000b3	e8 00 00 00 00	 call	 _reset_pan_state

; 3024 :          do_rtzoom = prev_do_rtzoom;               // after stopping zoom

  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _prev_do_rtzoom
  000bd	a3 00 00 00 00	 mov	 DWORD PTR _do_rtzoom, eax
$LN7@do_zooming:

; 3025 :       }
; 3026 :    }
; 3027 :    if (!do_rtzoom) // Return if not zooming

  000c2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _do_rtzoom, 0
  000c9	75 07		 jne	 SHORT $LN8@do_zooming

; 3028 :       return 0;

  000cb	33 c0		 xor	 eax, eax
  000cd	e9 eb 01 00 00	 jmp	 $LN1@do_zooming
$LN8@do_zooming:

; 3029 : 
; 3030 :    update_re_im(m, m->pan_xoffs, m->pan_yoffs);       // update re/im from any pan offsets and reset offsets

  000d2	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  000d5	8b 88 a4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36260]
  000db	51		 push	 ecx
  000dc	8b 90 a0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36256]
  000e2	52		 push	 edx
  000e3	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  000e6	8b 88 9c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36252]
  000ec	51		 push	 ecx
  000ed	8b 90 98 8d 00
	00		 mov	 edx, DWORD PTR [eax+36248]
  000f3	52		 push	 edx
  000f4	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _update_re_im
  000fd	83 c4 14	 add	 esp, 20			; 00000014H

; 3031 : 
; 3032 :    step = rtzoom_mag_steps[cfg_settings.zoom_rate.val];

  00100	a1 2c 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+44
  00105	f2 0f 10 04 c5
	00 00 00 00	 movsd	 xmm0, QWORD PTR _rtzoom_mag_steps[eax*8]
  0010e	f2 0f 11 45 e8	 movsd	 QWORD PTR _step$[ebp], xmm0

; 3033 : 
; 3034 :    start_time = get_timer();

  00113	e8 00 00 00 00	 call	 _get_timer
  00118	89 45 fc	 mov	 DWORD PTR _start_time$[ebp], eax

; 3035 : 
; 3036 :    if (do_rtzoom & RTZOOM_IN)

  0011b	a1 00 00 00 00	 mov	 eax, DWORD PTR _do_rtzoom
  00120	83 e0 01	 and	 eax, 1
  00123	74 1d		 je	 SHORT $LN9@do_zooming

; 3037 :       m->mag *= step;

  00125	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  00128	f2 0f 10 80 b8
	8d 00 00	 movsd	 xmm0, QWORD PTR [eax+36280]
  00130	f2 0f 59 45 e8	 mulsd	 xmm0, QWORD PTR _step$[ebp]
  00135	8b 4d e4	 mov	 ecx, DWORD PTR _m$[ebp]
  00138	f2 0f 11 81 b8
	8d 00 00	 movsd	 QWORD PTR [ecx+36280], xmm0
  00140	eb 43		 jmp	 SHORT $LN11@do_zooming
$LN9@do_zooming:

; 3038 :    else
; 3039 :    {
; 3040 :       m->mag /= step;

  00142	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  00145	f2 0f 10 80 b8
	8d 00 00	 movsd	 xmm0, QWORD PTR [eax+36280]
  0014d	f2 0f 5e 45 e8	 divsd	 xmm0, QWORD PTR _step$[ebp]
  00152	8b 4d e4	 mov	 ecx, DWORD PTR _m$[ebp]
  00155	f2 0f 11 81 b8
	8d 00 00	 movsd	 QWORD PTR [ecx+36280], xmm0

; 3041 :       if (m->mag < MAG_MIN)

  0015d	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  00160	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f947ae147ae147b
  00168	66 0f 2f 80 b8
	8d 00 00	 comisd	 xmm0, QWORD PTR [eax+36280]
  00170	76 13		 jbe	 SHORT $LN11@do_zooming

; 3042 :          m->mag = MAG_MIN;

  00172	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  00175	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f947ae147ae147b
  0017d	f2 0f 11 80 b8
	8d 00 00	 movsd	 QWORD PTR [eax+36280], xmm0
$LN11@do_zooming:

; 3043 :    }
; 3044 :    if (!(do_rtzoom & RTZOOM_WITH_BUTTON)) // if zooming using the mouse

  00185	a1 00 00 00 00	 mov	 eax, DWORD PTR _do_rtzoom
  0018a	83 e0 04	 and	 eax, 4
  0018d	0f 85 98 00 00
	00		 jne	 $LN12@do_zooming

; 3045 :    {
; 3046 :       // Set the new image center re/im to keep the position at mouse[1]
; 3047 :       // at the same point on the screen.
; 3048 : 
; 3049 :       mx = mouse_x[1] - (m->xsize >> 1); // Get offset from image center

  00193	b8 04 00 00 00	 mov	 eax, 4
  00198	c1 e0 00	 shl	 eax, 0
  0019b	8b 4d e4	 mov	 ecx, DWORD PTR _m$[ebp]
  0019e	8b 91 88 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36232]
  001a4	d1 fa		 sar	 edx, 1
  001a6	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_x[eax]
  001ac	2b c2		 sub	 eax, edx
  001ae	89 45 f8	 mov	 DWORD PTR _mx$[ebp], eax

; 3050 :       my = mouse_y[1] - (m->ysize >> 1);

  001b1	b8 04 00 00 00	 mov	 eax, 4
  001b6	c1 e0 00	 shl	 eax, 0
  001b9	8b 4d e4	 mov	 ecx, DWORD PTR _m$[ebp]
  001bc	8b 91 8c 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36236]
  001c2	d1 fa		 sar	 edx, 1
  001c4	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _mouse_y[eax]
  001ca	2b c2		 sub	 eax, edx
  001cc	89 45 f4	 mov	 DWORD PTR _my$[ebp], eax

; 3051 : 
; 3052 :       m->re = mouse_re - get_re_im_offs(m, mx);

  001cf	8b 45 f8	 mov	 eax, DWORD PTR _mx$[ebp]
  001d2	99		 cdq
  001d3	52		 push	 edx
  001d4	50		 push	 eax
  001d5	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  001d8	50		 push	 eax
  001d9	e8 00 00 00 00	 call	 _get_re_im_offs
  001de	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e1	dd 5d 9c	 fstp	 QWORD PTR tv244[ebp]
  001e4	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _mouse_re
  001ec	f2 0f 5c 45 9c	 subsd	 xmm0, QWORD PTR tv244[ebp]
  001f1	8b 4d e4	 mov	 ecx, DWORD PTR _m$[ebp]
  001f4	f2 0f 11 81 a8
	8d 00 00	 movsd	 QWORD PTR [ecx+36264], xmm0

; 3053 :       m->im = mouse_im + get_re_im_offs(m, my);

  001fc	8b 45 f4	 mov	 eax, DWORD PTR _my$[ebp]
  001ff	99		 cdq
  00200	52		 push	 edx
  00201	50		 push	 eax
  00202	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  00205	50		 push	 eax
  00206	e8 00 00 00 00	 call	 _get_re_im_offs
  0020b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020e	dd 5d 9c	 fstp	 QWORD PTR tv259[ebp]
  00211	f2 0f 10 45 9c	 movsd	 xmm0, QWORD PTR tv259[ebp]
  00216	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR _mouse_im
  0021e	8b 4d e4	 mov	 ecx, DWORD PTR _m$[ebp]
  00221	f2 0f 11 81 b0
	8d 00 00	 movsd	 QWORD PTR [ecx+36272], xmm0

; 3054 :    }

  00229	eb 2f		 jmp	 SHORT $LN14@do_zooming
$LN12@do_zooming:

; 3055 :    else // if zooming using the button, stop when we hit the start mag
; 3056 :       if (m->mag > zoom_start_mag)

  0022b	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  0022e	f2 0f 10 80 b8
	8d 00 00	 movsd	 xmm0, QWORD PTR [eax+36280]
  00236	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR _zoom_start_mag
  0023e	76 1a		 jbe	 SHORT $LN14@do_zooming

; 3057 :       {
; 3058 :          m->mag = zoom_start_mag;

  00240	8b 45 e4	 mov	 eax, DWORD PTR _m$[ebp]
  00243	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _zoom_start_mag
  0024b	f2 0f 11 80 b8
	8d 00 00	 movsd	 QWORD PTR [eax+36280], xmm0

; 3059 :          done = 1; // setting do_rtzoom 0 here wipes out fps numbers after button zoom is done

  00253	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _done$[ebp], 1
$LN14@do_zooming:

; 3060 :       }
; 3061 : 
; 3062 :    do_man_calculate(1);

  0025a	6a 01		 push	 1
  0025c	e8 00 00 00 00	 call	 _do_man_calculate
  00261	83 c4 04	 add	 esp, 4

; 3063 : 
; 3064 :    update_benchmarks(get_seconds_elapsed(start_time), 1);

  00264	6a 01		 push	 1
  00266	8b 45 fc	 mov	 eax, DWORD PTR _start_time$[ebp]
  00269	50		 push	 eax
  0026a	e8 00 00 00 00	 call	 _get_seconds_elapsed
  0026f	83 c4 fc	 add	 esp, -4			; fffffffcH
  00272	dd 1c 24	 fstp	 QWORD PTR [esp]
  00275	e8 00 00 00 00	 call	 _update_benchmarks
  0027a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3065 : 
; 3066 :    if (done) // If we just finished button zoom, update info

  0027d	83 7d f0 00	 cmp	 DWORD PTR _done$[ebp], 0
  00281	74 35		 je	 SHORT $LN15@do_zooming

; 3067 :    {
; 3068 :       do_rtzoom = 0;

  00283	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _do_rtzoom, 0

; 3069 :       file_tot_time = get_seconds_elapsed(zoom_start_time); // use for benchmarking

  0028d	a1 00 00 00 00	 mov	 eax, DWORD PTR _zoom_start_time
  00292	50		 push	 eax
  00293	e8 00 00 00 00	 call	 _get_seconds_elapsed
  00298	83 c4 04	 add	 esp, 4
  0029b	dd 1d 00 00 00
	00		 fstp	 QWORD PTR _file_tot_time

; 3070 :       SetWindowText(hwnd_info, get_image_info(1)); // Update all info

  002a1	6a 01		 push	 1
  002a3	e8 00 00 00 00	 call	 _get_image_info
  002a8	83 c4 04	 add	 esp, 4
  002ab	50		 push	 eax
  002ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_info
  002b1	50		 push	 eax
  002b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
$LN15@do_zooming:

; 3071 :    }
; 3072 :    return 1;

  002b8	b8 01 00 00 00	 mov	 eax, 1
$LN1@do_zooming:

; 3073 : }

  002bd	5f		 pop	 edi
  002be	5e		 pop	 esi
  002bf	5b		 pop	 ebx
  002c0	8b e5		 mov	 esp, ebp
  002c2	5d		 pop	 ebp
  002c3	c3		 ret	 0
_do_zooming ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_mouse_re_im
_TEXT	SEGMENT
tv148 = -76						; size = 8
tv133 = -76						; size = 8
_m$ = -4						; size = 4
_mx$ = 8						; size = 4
_my$ = 12						; size = 4
_get_mouse_re_im PROC					; COMDAT

; 2975 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2976 :    man_calc_struct *m;
; 2977 : 
; 2978 :    m = &main_man_calc_struct;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 2979 : 
; 2980 :    mx -= (m->xsize >> 1); // Get offset from image center

  00010	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00013	8b 88 88 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36232]
  00019	d1 f9		 sar	 ecx, 1
  0001b	8b 55 08	 mov	 edx, DWORD PTR _mx$[ebp]
  0001e	2b d1		 sub	 edx, ecx
  00020	89 55 08	 mov	 DWORD PTR _mx$[ebp], edx

; 2981 :    my -= (m->ysize >> 1);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00026	8b 88 8c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36236]
  0002c	d1 f9		 sar	 ecx, 1
  0002e	8b 55 0c	 mov	 edx, DWORD PTR _my$[ebp]
  00031	2b d1		 sub	 edx, ecx
  00033	89 55 0c	 mov	 DWORD PTR _my$[ebp], edx

; 2982 : 
; 2983 :    mouse_re = m->re + get_re_im_offs(m, mx);

  00036	8b 45 08	 mov	 eax, DWORD PTR _mx$[ebp]
  00039	99		 cdq
  0003a	52		 push	 edx
  0003b	50		 push	 eax
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _get_re_im_offs
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	dd 5d b4	 fstp	 QWORD PTR tv133[ebp]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  0004e	f2 0f 10 45 b4	 movsd	 xmm0, QWORD PTR tv133[ebp]
  00053	f2 0f 58 81 a8
	8d 00 00	 addsd	 xmm0, QWORD PTR [ecx+36264]
  0005b	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _mouse_re, xmm0

; 2984 :    mouse_im = m->im - get_re_im_offs(m, my);

  00063	8b 45 0c	 mov	 eax, DWORD PTR _my$[ebp]
  00066	99		 cdq
  00067	52		 push	 edx
  00068	50		 push	 eax
  00069	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _get_re_im_offs
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	dd 5d b4	 fstp	 QWORD PTR tv148[ebp]
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  0007b	f2 0f 10 81 b0
	8d 00 00	 movsd	 xmm0, QWORD PTR [ecx+36272]
  00083	f2 0f 5c 45 b4	 subsd	 xmm0, QWORD PTR tv148[ebp]
  00088	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _mouse_im, xmm0

; 2985 : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_get_mouse_re_im ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _do_panning
_TEXT	SEGMENT
_ystep$ = -8						; size = 4
_xstep$ = -4						; size = 4
_do_panning PROC					; COMDAT

; 2931 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2932 :    int xstep, ystep;
; 2933 :    static TIME_UNIT start_time;
; 2934 :    static double pan_time = -1.0;
; 2935 : 
; 2936 :    // Update coords, xstep, and ystep based on keys pressed. Returns a 1-clock pulse when
; 2937 :    // panning transitioned from active to stopped.
; 2938 : 
; 2939 :    if (get_pan_steps(&xstep, &ystep, 0))

  00009	6a 00		 push	 0
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _ystep$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d fc	 lea	 ecx, DWORD PTR _xstep$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 _get_pan_steps
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	85 c0		 test	 eax, eax
  0001d	74 2b		 je	 SHORT $LN2@do_panning

; 2940 :    {
; 2941 :       SetWindowText(hwnd_info, get_image_info(0)); // update image info

  0001f	6a 00		 push	 0
  00021	e8 00 00 00 00	 call	 _get_image_info
  00026	83 c4 04	 add	 esp, 4
  00029	50		 push	 eax
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_info
  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 2942 :       pan_time = -1.0;                             // restart timing next time

  00036	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@bff0000000000000
  0003e	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?pan_time@?1??do_panning@@9@9, xmm0

; 2943 :       return 0;

  00046	33 c0		 xor	 eax, eax
  00048	eb 79		 jmp	 SHORT $LN1@do_panning
$LN2@do_panning:

; 2944 :    }
; 2945 : 
; 2946 :    // The Sleep value in the main loop can affect the timing when panning has almost
; 2947 :    // decelerated to a stop (when the x and y steps are both zero, but may be 1 next
; 2948 :    // cycle). In this case the Sleep time substitutes for the iteration + bitblit time.
; 2949 :    // Want these to be as close as possible for smooth stops. Using a sleep value of 1
; 2950 :    // caused some discontinuities (sometimes doesn't sleep at all?) whereas 2 seems pretty good.
; 2951 :    // Later, probably want to do dummy iteration instead.
; 2952 : 
; 2953 :    if (xstep | ystep)

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _xstep$[ebp]
  0004d	0b 45 f8	 or	 eax, DWORD PTR _ystep$[ebp]
  00050	74 6f		 je	 SHORT $LN3@do_panning

; 2954 :    {
; 2955 :       if (pan_time < 0.0) // if < 0, we need to restart timer

  00052	0f 57 c0	 xorps	 xmm0, xmm0
  00055	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR ?pan_time@?1??do_panning@@9@9
  0005d	76 0a		 jbe	 SHORT $LN4@do_panning

; 2956 :          start_time = get_timer();

  0005f	e8 00 00 00 00	 call	 _get_timer
  00064	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@?1??do_panning@@9@9, eax
$LN4@do_panning:

; 2957 : 
; 2958 :       pan_image(xstep, ystep);

  00069	8b 45 f8	 mov	 eax, DWORD PTR _ystep$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _xstep$[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 _pan_image
  00076	83 c4 08	 add	 esp, 8

; 2959 : 
; 2960 :       pan_time = get_seconds_elapsed(start_time);  // get time since last screen update

  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR ?start_time@?1??do_panning@@9@9
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _get_seconds_elapsed
  00084	83 c4 04	 add	 esp, 4
  00087	dd 1d 00 00 00
	00		 fstp	 QWORD PTR ?pan_time@?1??do_panning@@9@9

; 2961 : 
; 2962 :       // skip update if the whole image was recalculated (due to size change, etc). messes
; 2963 :       // up the averages.
; 2964 :       if (!all_recalculated)

  0008d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _all_recalculated, 0
  00094	75 1a		 jne	 SHORT $LN5@do_panning

; 2965 :          update_benchmarks(pan_time, 0);           // update the fps, average fps, and iteration %

  00096	6a 00		 push	 0
  00098	83 ec 08	 sub	 esp, 8
  0009b	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR ?pan_time@?1??do_panning@@9@9
  000a3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000a8	e8 00 00 00 00	 call	 _update_benchmarks
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@do_panning:

; 2966 :       start_time = get_timer();                    // restart timer for next update

  000b0	e8 00 00 00 00	 call	 _get_timer
  000b5	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@?1??do_panning@@9@9, eax

; 2967 : 
; 2968 :       return 1;

  000ba	b8 01 00 00 00	 mov	 eax, 1
  000bf	eb 02		 jmp	 SHORT $LN1@do_panning
$LN3@do_panning:

; 2969 :    }
; 2970 :    return 0;

  000c1	33 c0		 xor	 eax, eax
$LN1@do_panning:

; 2971 : }

  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
_do_panning ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_pan_steps
_TEXT	SEGMENT
tv157 = -184						; size = 8
tv150 = -184						; size = 8
tv176 = -176						; size = 8
tv171 = -176						; size = 8
tv159 = -176						; size = 8
tv152 = -176						; size = 8
_m$ = -104						; size = 4
_pfc_offs$ = -100					; size = 8
_pfc_slope$ = -92					; size = 8
_pfcmax$ = -84						; size = 8
_pfcmin$ = -76						; size = 8
_tmp$ = -68						; size = 8
_pan_filter_const$ = -60				; size = 8
_pan_step_scale$ = -52					; size = 8
_ys$ = -44						; size = 8
_xs$ = -36						; size = 8
_pan_step$ = -28					; size = 8
_pulse$ = -20						; size = 4
_ystep_int$ = -16					; size = 4
_xstep_int$ = -12					; size = 4
_pkey$ = -8						; size = 4
_key$ = -4						; size = 4
_xstep$ = 8						; size = 4
_ystep$ = 12						; size = 4
_set_pan_key$ = 16					; size = 4
_get_pan_steps PROC					; COMDAT

; 2796 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 2797 :    int key, pkey, xstep_int, ystep_int, pulse;
; 2798 :    static int key_lock = 0, wait_release;
; 2799 :    double pan_step, xs, ys, pan_step_scale, pan_filter_const, tmp;
; 2800 :    double pfcmin, pfcmax, pfc_slope, pfc_offs;
; 2801 :    static int stopped_counter = 0;
; 2802 :    static int stopped = 0;
; 2803 :    man_calc_struct *m;
; 2804 : 
; 2805 :    m = &main_man_calc_struct;

  0000c	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 2806 : 
; 2807 : #define STOPPED_COUNTER_MAX 25
; 2808 : 
; 2809 :    if (xstep == NULL || ystep == NULL) // null pointers mean set pan key

  00013	83 7d 08 00	 cmp	 DWORD PTR _xstep$[ebp], 0
  00017	74 06		 je	 SHORT $LN3@get_pan_st
  00019	83 7d 0c 00	 cmp	 DWORD PTR _ystep$[ebp], 0
  0001d	75 0f		 jne	 SHORT $LN2@get_pan_st
$LN3@get_pan_st:

; 2810 :    {
; 2811 :       key_lock = set_pan_key;

  0001f	8b 45 10	 mov	 eax, DWORD PTR _set_pan_key$[ebp]
  00022	a3 00 00 00 00	 mov	 DWORD PTR ?key_lock@?1??get_pan_steps@@9@9, eax

; 2812 :       return 0;

  00027	33 c0		 xor	 eax, eax
  00029	e9 32 04 00 00	 jmp	 $LN1@get_pan_st
$LN2@get_pan_st:

; 2813 :    }
; 2814 : 
; 2815 :    // Without this, will pan even if other applications have the focus... still does
; 2816 :    // if it recaptures focus due to the cursor moving over the main window.
; 2817 : 
; 2818 :    if (GetFocus() != hwnd_main)

  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFocus@0
  00034	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _hwnd_main
  0003a	74 0f		 je	 SHORT $LN4@get_pan_st

; 2819 :    {
; 2820 :       // Stay active even if we don't have the focus, but don't accept any keys.
; 2821 :       // Necessary for clearing/updating the pan filters, and for keeping pan lock
; 2822 :       // going. Maybe go into low-priority mode too?
; 2823 :       key = pkey = 0;

  0003c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pkey$[ebp], 0
  00043	8b 45 f8	 mov	 eax, DWORD PTR _pkey$[ebp]
  00046	89 45 fc	 mov	 DWORD PTR _key$[ebp], eax

; 2824 :    }

  00049	eb 0e		 jmp	 SHORT $LN5@get_pan_st
$LN4@get_pan_st:

; 2825 :    else
; 2826 :       key = pkey = get_keys_pressed();

  0004b	e8 00 00 00 00	 call	 _get_keys_pressed
  00050	89 45 f8	 mov	 DWORD PTR _pkey$[ebp], eax
  00053	8b 45 f8	 mov	 eax, DWORD PTR _pkey$[ebp]
  00056	89 45 fc	 mov	 DWORD PTR _key$[ebp], eax
$LN5@get_pan_st:

; 2827 : 
; 2828 :    // No need to do all the code below if we're stopped and no pan keys were pressed.
; 2829 :    if (!(key & (PAN_KEY | KEY_CTRL)) && !key_lock)

  00059	8b 45 fc	 mov	 eax, DWORD PTR _key$[ebp]
  0005c	83 e0 1f	 and	 eax, 31			; 0000001fH
  0005f	75 1b		 jne	 SHORT $LN6@get_pan_st
  00061	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?key_lock@?1??get_pan_steps@@9@9, 0
  00068	75 12		 jne	 SHORT $LN6@get_pan_st

; 2830 :    {
; 2831 :       if (stopped)

  0006a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?stopped@?1??get_pan_steps@@9@9, 0
  00071	74 07		 je	 SHORT $LN8@get_pan_st

; 2832 :          return 0;

  00073	33 c0		 xor	 eax, eax
  00075	e9 e6 03 00 00	 jmp	 $LN1@get_pan_st
$LN8@get_pan_st:

; 2833 :    }

  0007a	eb 0a		 jmp	 SHORT $LN7@get_pan_st
$LN6@get_pan_st:

; 2834 :    else // a pan key was pressed
; 2835 :       stopped = 0;

  0007c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?stopped@?1??get_pan_steps@@9@9, 0
$LN7@get_pan_st:

; 2836 : 
; 2837 :    // Do pan lock with the shift key. If pan is locked, keep panning in the
; 2838 :    // current direction. CTRL can toggle speed. Fun...
; 2839 :    if (key_lock)

  00086	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?key_lock@?1??get_pan_steps@@9@9, 0
  0008d	74 6f		 je	 SHORT $LN9@get_pan_st

; 2840 :    {
; 2841 :       if (pkey & (PAN_KEY | KEY_CTRL))

  0008f	8b 45 f8	 mov	 eax, DWORD PTR _pkey$[ebp]
  00092	83 e0 1f	 and	 eax, 31			; 0000001fH
  00095	74 41		 je	 SHORT $LN11@get_pan_st

; 2842 :       {
; 2843 :          if (!wait_release)

  00097	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?wait_release@?1??get_pan_steps@@9@9, 0
  0009e	75 36		 jne	 SHORT $LN15@get_pan_st

; 2844 :             if (pkey & KEY_CTRL)

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _pkey$[ebp]
  000a3	83 e0 10	 and	 eax, 16			; 00000010H
  000a6	74 19		 je	 SHORT $LN14@get_pan_st

; 2845 :             {
; 2846 :                key_lock ^= KEY_CTRL;

  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?key_lock@?1??get_pan_steps@@9@9
  000ad	83 f0 10	 xor	 eax, 16			; 00000010H
  000b0	a3 00 00 00 00	 mov	 DWORD PTR ?key_lock@?1??get_pan_steps@@9@9, eax

; 2847 :                wait_release = 1;

  000b5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?wait_release@?1??get_pan_steps@@9@9, 1

; 2848 :             }

  000bf	eb 15		 jmp	 SHORT $LN15@get_pan_st
$LN14@get_pan_st:

; 2849 :             else
; 2850 :                key_lock = (key_lock & ~PAN_KEY) | (pkey & PAN_KEY); // preserve CTRL (fast/slow) state

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?key_lock@?1??get_pan_steps@@9@9
  000c6	83 e0 f0	 and	 eax, -16		; fffffff0H
  000c9	8b 4d f8	 mov	 ecx, DWORD PTR _pkey$[ebp]
  000cc	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000cf	0b c1		 or	 eax, ecx
  000d1	a3 00 00 00 00	 mov	 DWORD PTR ?key_lock@?1??get_pan_steps@@9@9, eax
$LN15@get_pan_st:

; 2851 :       }

  000d6	eb 1c		 jmp	 SHORT $LN12@get_pan_st
$LN11@get_pan_st:

; 2852 :       else
; 2853 :       {
; 2854 :          if (pkey & KEY_SHIFT) // leave lock mode if shift pressed without a pan key

  000d8	8b 45 f8	 mov	 eax, DWORD PTR _pkey$[ebp]
  000db	83 e0 40	 and	 eax, 64			; 00000040H
  000de	74 0a		 je	 SHORT $LN16@get_pan_st

; 2855 :             key_lock = 0;

  000e0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?key_lock@?1??get_pan_steps@@9@9, 0
$LN16@get_pan_st:

; 2856 :          wait_release = 0;

  000ea	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?wait_release@?1??get_pan_steps@@9@9, 0
$LN12@get_pan_st:

; 2857 :       }
; 2858 :       key = key_lock;

  000f4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?key_lock@?1??get_pan_steps@@9@9
  000f9	89 45 fc	 mov	 DWORD PTR _key$[ebp], eax

; 2859 :    }

  000fc	eb 25		 jmp	 SHORT $LN17@get_pan_st
$LN9@get_pan_st:

; 2860 :    else // not in pan lock mode: see if we need to go into it
; 2861 :       if ((pkey & KEY_SHIFT) && (pkey & PAN_KEY))

  000fe	8b 45 f8	 mov	 eax, DWORD PTR _pkey$[ebp]
  00101	83 e0 40	 and	 eax, 64			; 00000040H
  00104	74 1d		 je	 SHORT $LN17@get_pan_st
  00106	8b 45 f8	 mov	 eax, DWORD PTR _pkey$[ebp]
  00109	83 e0 0f	 and	 eax, 15			; 0000000fH
  0010c	74 15		 je	 SHORT $LN17@get_pan_st

; 2862 :       {
; 2863 :          key_lock = pkey & (PAN_KEY | KEY_CTRL);

  0010e	8b 45 f8	 mov	 eax, DWORD PTR _pkey$[ebp]
  00111	83 e0 1f	 and	 eax, 31			; 0000001fH
  00114	a3 00 00 00 00	 mov	 DWORD PTR ?key_lock@?1??get_pan_steps@@9@9, eax

; 2864 :          wait_release = 1;

  00119	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?wait_release@?1??get_pan_steps@@9@9, 1
$LN17@get_pan_st:

; 2865 :       }
; 2866 : 
; 2867 :    // Get the step scale from the pan rate slider
; 2868 :    pan_step_scale = pan_step_scales[cfg_settings.pan_rate.val];

  00123	a1 04 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+4
  00128	f2 0f 10 04 c5
	00 00 00 00	 movsd	 xmm0, QWORD PTR _pan_step_scales[eax*8]
  00131	f2 0f 11 45 cc	 movsd	 QWORD PTR _pan_step_scale$[ebp], xmm0

; 2869 : 
; 2870 :    // Adjust the step based on the image size, to try to compensate for size-based variable frame rates
; 2871 :    pan_step = pan_step_scale * (double) (m->image_size + OVERHEAD_FACTOR) * (1.0 / PAN_STEP_DIV);

  00136	8b 45 98	 mov	 eax, DWORD PTR _m$[ebp]
  00139	8b 88 94 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36244]
  0013f	81 c1 a0 86 01
	00		 add	 ecx, 100000		; 000186a0H
  00145	f2 0f 2a c1	 cvtsi2sd xmm0, ecx
  00149	f2 0f 59 45 cc	 mulsd	 xmm0, QWORD PTR _pan_step_scale$[ebp]
  0014e	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3edbf647612f3696
  00156	f2 0f 11 45 e4	 movsd	 QWORD PTR _pan_step$[ebp], xmm0

; 2872 : 
; 2873 :    // Pan filter settings now come from config file. The 0.0001 scales large config file
; 2874 :    // integers to the values needed here.
; 2875 :    pfcmin = 0.0001 * (double) cfg_settings.pfcmin.val;

  0015b	f2 0f 2a 05 e0
	00 00 00	 cvtsi2sd xmm0, DWORD PTR _cfg_settings+224
  00163	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3f1a36e2eb1c432d
  0016b	f2 0f 11 45 b4	 movsd	 QWORD PTR _pfcmin$[ebp], xmm0

; 2876 :    pfcmax = 0.0001 * (double) cfg_settings.pfcmax.val;

  00170	f2 0f 2a 05 f4
	00 00 00	 cvtsi2sd xmm0, DWORD PTR _cfg_settings+244
  00178	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3f1a36e2eb1c432d
  00180	f2 0f 11 45 ac	 movsd	 QWORD PTR _pfcmax$[ebp], xmm0

; 2877 :    pfc_slope = (pfcmax - pfcmin) * (1.0 / PFC_SLOPE_FACTOR);

  00185	f2 0f 10 45 ac	 movsd	 xmm0, QWORD PTR _pfcmax$[ebp]
  0018a	f2 0f 5c 45 b4	 subsd	 xmm0, QWORD PTR _pfcmin$[ebp]
  0018f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ea9273b38557509
  00197	f2 0f 11 45 a4	 movsd	 QWORD PTR _pfc_slope$[ebp], xmm0

; 2878 :    pfc_offs = pfcmin - pfc_slope * PFC_OFFS_FACTOR;

  0019c	f2 0f 10 45 a4	 movsd	 xmm0, QWORD PTR _pfc_slope$[ebp]
  001a1	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@411de84000000000
  001a9	f2 0f 10 4d b4	 movsd	 xmm1, QWORD PTR _pfcmin$[ebp]
  001ae	f2 0f 5c c8	 subsd	 xmm1, xmm0
  001b2	f2 0f 11 4d 9c	 movsd	 QWORD PTR _pfc_offs$[ebp], xmm1

; 2879 : 
; 2880 :    pan_filter_const = (double) m->image_size * pfc_slope + pfc_offs;

  001b7	8b 45 98	 mov	 eax, DWORD PTR _m$[ebp]
  001ba	f2 0f 2a 80 94
	8d 00 00	 cvtsi2sd xmm0, DWORD PTR [eax+36244]
  001c2	f2 0f 59 45 a4	 mulsd	 xmm0, QWORD PTR _pfc_slope$[ebp]
  001c7	f2 0f 58 45 9c	 addsd	 xmm0, QWORD PTR _pfc_offs$[ebp]
  001cc	f2 0f 11 45 c4	 movsd	 QWORD PTR _pan_filter_const$[ebp], xmm0

; 2881 :    if (pan_filter_const < pfcmin)

  001d1	f2 0f 10 45 b4	 movsd	 xmm0, QWORD PTR _pfcmin$[ebp]
  001d6	66 0f 2f 45 c4	 comisd	 xmm0, QWORD PTR _pan_filter_const$[ebp]
  001db	76 0a		 jbe	 SHORT $LN18@get_pan_st

; 2882 :       pan_filter_const = pfcmin;

  001dd	f2 0f 10 45 b4	 movsd	 xmm0, QWORD PTR _pfcmin$[ebp]
  001e2	f2 0f 11 45 c4	 movsd	 QWORD PTR _pan_filter_const$[ebp], xmm0
$LN18@get_pan_st:

; 2883 : 
; 2884 :    // Go to fast mode while CTRL key is held down
; 2885 :    if (key & KEY_CTRL)

  001e7	8b 45 fc	 mov	 eax, DWORD PTR _key$[ebp]
  001ea	83 e0 10	 and	 eax, 16			; 00000010H
  001ed	74 12		 je	 SHORT $LN19@get_pan_st

; 2886 :       pan_step *= 4.0;  // arbitrary speedup factor: 4 seems to work pretty well

  001ef	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _pan_step$[ebp]
  001f4	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4010000000000000
  001fc	f2 0f 11 45 e4	 movsd	 QWORD PTR _pan_step$[ebp], xmm0
$LN19@get_pan_st:

; 2887 : 
; 2888 :    // Get x and y steps
; 2889 :    xs = key & KEY_RIGHT ? -pan_step : key & KEY_LEFT ? pan_step : 0.0;

  00201	8b 45 fc	 mov	 eax, DWORD PTR _key$[ebp]
  00204	83 e0 02	 and	 eax, 2
  00207	74 16		 je	 SHORT $LN26@get_pan_st
  00209	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _pan_step$[ebp]
  0020e	0f 57 05 00 00
	00 00		 xorps	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  00215	f2 0f 11 85 50
	ff ff ff	 movsd	 QWORD PTR tv152[ebp], xmm0
  0021d	eb 32		 jmp	 SHORT $LN27@get_pan_st
$LN26@get_pan_st:
  0021f	8b 4d fc	 mov	 ecx, DWORD PTR _key$[ebp]
  00222	83 e1 01	 and	 ecx, 1
  00225	74 0f		 je	 SHORT $LN24@get_pan_st
  00227	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _pan_step$[ebp]
  0022c	f2 0f 11 85 48
	ff ff ff	 movsd	 QWORD PTR tv150[ebp], xmm0
  00234	eb 0b		 jmp	 SHORT $LN25@get_pan_st
$LN24@get_pan_st:
  00236	0f 57 c0	 xorps	 xmm0, xmm0
  00239	f2 0f 11 85 48
	ff ff ff	 movsd	 QWORD PTR tv150[ebp], xmm0
$LN25@get_pan_st:
  00241	f2 0f 10 85 48
	ff ff ff	 movsd	 xmm0, QWORD PTR tv150[ebp]
  00249	f2 0f 11 85 50
	ff ff ff	 movsd	 QWORD PTR tv152[ebp], xmm0
$LN27@get_pan_st:
  00251	f2 0f 10 85 50
	ff ff ff	 movsd	 xmm0, QWORD PTR tv152[ebp]
  00259	f2 0f 11 45 dc	 movsd	 QWORD PTR _xs$[ebp], xmm0

; 2890 :    ys = key & KEY_DOWN  ? -pan_step : key & KEY_UP   ? pan_step : 0.0;

  0025e	8b 45 fc	 mov	 eax, DWORD PTR _key$[ebp]
  00261	83 e0 08	 and	 eax, 8
  00264	74 16		 je	 SHORT $LN30@get_pan_st
  00266	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _pan_step$[ebp]
  0026b	0f 57 05 00 00
	00 00		 xorps	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  00272	f2 0f 11 85 50
	ff ff ff	 movsd	 QWORD PTR tv159[ebp], xmm0
  0027a	eb 32		 jmp	 SHORT $LN31@get_pan_st
$LN30@get_pan_st:
  0027c	8b 4d fc	 mov	 ecx, DWORD PTR _key$[ebp]
  0027f	83 e1 04	 and	 ecx, 4
  00282	74 0f		 je	 SHORT $LN28@get_pan_st
  00284	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _pan_step$[ebp]
  00289	f2 0f 11 85 48
	ff ff ff	 movsd	 QWORD PTR tv157[ebp], xmm0
  00291	eb 0b		 jmp	 SHORT $LN29@get_pan_st
$LN28@get_pan_st:
  00293	0f 57 c0	 xorps	 xmm0, xmm0
  00296	f2 0f 11 85 48
	ff ff ff	 movsd	 QWORD PTR tv157[ebp], xmm0
$LN29@get_pan_st:
  0029e	f2 0f 10 85 48
	ff ff ff	 movsd	 xmm0, QWORD PTR tv157[ebp]
  002a6	f2 0f 11 85 50
	ff ff ff	 movsd	 QWORD PTR tv159[ebp], xmm0
$LN31@get_pan_st:
  002ae	f2 0f 10 85 50
	ff ff ff	 movsd	 xmm0, QWORD PTR tv159[ebp]
  002b6	f2 0f 11 45 d4	 movsd	 QWORD PTR _ys$[ebp], xmm0

; 2891 : 
; 2892 :    // Filter the pan movements
; 2893 :    cur_pan_xstep = xs * pan_filter_const + (tmp = 1.0 - pan_filter_const) * cur_pan_xstep;

  002bb	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  002c3	f2 0f 5c 45 c4	 subsd	 xmm0, QWORD PTR _pan_filter_const$[ebp]
  002c8	f2 0f 11 45 bc	 movsd	 QWORD PTR _tmp$[ebp], xmm0
  002cd	f2 0f 10 45 bc	 movsd	 xmm0, QWORD PTR _tmp$[ebp]
  002d2	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR _cur_pan_xstep
  002da	f2 0f 10 4d dc	 movsd	 xmm1, QWORD PTR _xs$[ebp]
  002df	f2 0f 59 4d c4	 mulsd	 xmm1, QWORD PTR _pan_filter_const$[ebp]
  002e4	f2 0f 58 c8	 addsd	 xmm1, xmm0
  002e8	f2 0f 11 0d 00
	00 00 00	 movsd	 QWORD PTR _cur_pan_xstep, xmm1

; 2894 :    cur_pan_ystep = ys * pan_filter_const + tmp * cur_pan_ystep;

  002f0	f2 0f 10 45 d4	 movsd	 xmm0, QWORD PTR _ys$[ebp]
  002f5	f2 0f 59 45 c4	 mulsd	 xmm0, QWORD PTR _pan_filter_const$[ebp]
  002fa	f2 0f 10 4d bc	 movsd	 xmm1, QWORD PTR _tmp$[ebp]
  002ff	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR _cur_pan_ystep
  00307	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0030b	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _cur_pan_ystep, xmm0

; 2895 : 
; 2896 :    // Accumulate fractional steps
; 2897 :    pan_xstep_accum += cur_pan_xstep;

  00313	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _pan_xstep_accum
  0031b	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR _cur_pan_xstep
  00323	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _pan_xstep_accum, xmm0

; 2898 :    pan_ystep_accum += cur_pan_ystep;

  0032b	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _pan_ystep_accum
  00333	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR _cur_pan_ystep
  0033b	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _pan_ystep_accum, xmm0

; 2899 : 
; 2900 :    // Round up/down based on sign; convert to int
; 2901 :    xstep_int = (int) (pan_xstep_accum + ((pan_xstep_accum < 0.0) ? -0.5 : 0.5));

  00343	0f 57 c0	 xorps	 xmm0, xmm0
  00346	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR _pan_xstep_accum
  0034e	76 12		 jbe	 SHORT $LN32@get_pan_st
  00350	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@bfe0000000000000
  00358	f2 0f 11 85 50
	ff ff ff	 movsd	 QWORD PTR tv171[ebp], xmm0
  00360	eb 10		 jmp	 SHORT $LN33@get_pan_st
$LN32@get_pan_st:
  00362	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0036a	f2 0f 11 85 50
	ff ff ff	 movsd	 QWORD PTR tv171[ebp], xmm0
$LN33@get_pan_st:
  00372	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _pan_xstep_accum
  0037a	f2 0f 58 85 50
	ff ff ff	 addsd	 xmm0, QWORD PTR tv171[ebp]
  00382	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00386	89 45 f4	 mov	 DWORD PTR _xstep_int$[ebp], eax

; 2902 :    ystep_int = (int) (pan_ystep_accum + ((pan_ystep_accum < 0.0) ? -0.5 : 0.5));

  00389	0f 57 c0	 xorps	 xmm0, xmm0
  0038c	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR _pan_ystep_accum
  00394	76 12		 jbe	 SHORT $LN34@get_pan_st
  00396	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@bfe0000000000000
  0039e	f2 0f 11 85 50
	ff ff ff	 movsd	 QWORD PTR tv176[ebp], xmm0
  003a6	eb 10		 jmp	 SHORT $LN35@get_pan_st
$LN34@get_pan_st:
  003a8	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3fe0000000000000
  003b0	f2 0f 11 85 50
	ff ff ff	 movsd	 QWORD PTR tv176[ebp], xmm0
$LN35@get_pan_st:
  003b8	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _pan_ystep_accum
  003c0	f2 0f 58 85 50
	ff ff ff	 addsd	 xmm0, QWORD PTR tv176[ebp]
  003c8	f2 0f 2c c0	 cvttsd2si eax, xmm0
  003cc	89 45 f0	 mov	 DWORD PTR _ystep_int$[ebp], eax

; 2903 : 
; 2904 :    // Subtract integer part
; 2905 :    pan_xstep_accum -= (double) xstep_int;

  003cf	f2 0f 2a 45 f4	 cvtsi2sd xmm0, DWORD PTR _xstep_int$[ebp]
  003d4	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR _pan_xstep_accum
  003dc	f2 0f 5c c8	 subsd	 xmm1, xmm0
  003e0	f2 0f 11 0d 00
	00 00 00	 movsd	 QWORD PTR _pan_xstep_accum, xmm1

; 2906 :    pan_ystep_accum -= (double) ystep_int;

  003e8	f2 0f 2a 45 f0	 cvtsi2sd xmm0, DWORD PTR _ystep_int$[ebp]
  003ed	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR _pan_ystep_accum
  003f5	f2 0f 5c c8	 subsd	 xmm1, xmm0
  003f9	f2 0f 11 0d 00
	00 00 00	 movsd	 QWORD PTR _pan_ystep_accum, xmm1

; 2907 : 
; 2908 :    // Set integer steps
; 2909 :    *xstep = xstep_int;

  00401	8b 45 08	 mov	 eax, DWORD PTR _xstep$[ebp]
  00404	8b 4d f4	 mov	 ecx, DWORD PTR _xstep_int$[ebp]
  00407	89 08		 mov	 DWORD PTR [eax], ecx

; 2910 :    *ystep = ystep_int;

  00409	8b 45 0c	 mov	 eax, DWORD PTR _ystep$[ebp]
  0040c	8b 4d f0	 mov	 ecx, DWORD PTR _ystep_int$[ebp]
  0040f	89 08		 mov	 DWORD PTR [eax], ecx

; 2911 : 
; 2912 :    // Detect when a pan stopped
; 2913 :    pulse = 0;

  00411	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pulse$[ebp], 0

; 2914 :    if (key | xstep_int | ystep_int)  // Reset the stopped counter on any activity

  00418	8b 45 fc	 mov	 eax, DWORD PTR _key$[ebp]
  0041b	0b 45 f4	 or	 eax, DWORD PTR _xstep_int$[ebp]
  0041e	0b 45 f0	 or	 eax, DWORD PTR _ystep_int$[ebp]
  00421	74 0c		 je	 SHORT $LN20@get_pan_st

; 2915 :       stopped_counter = STOPPED_COUNTER_MAX;

  00423	c7 05 00 00 00
	00 19 00 00 00	 mov	 DWORD PTR ?stopped_counter@?1??get_pan_steps@@9@9, 25 ; 00000019H
  0042d	eb 2e		 jmp	 SHORT $LN22@get_pan_st
$LN20@get_pan_st:

; 2916 :    else
; 2917 :       if (stopped_counter && !--stopped_counter)  // else decrement and pulse on transition to 0

  0042f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?stopped_counter@?1??get_pan_steps@@9@9, 0
  00436	74 25		 je	 SHORT $LN22@get_pan_st
  00438	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stopped_counter@?1??get_pan_steps@@9@9
  0043d	83 e8 01	 sub	 eax, 1
  00440	a3 00 00 00 00	 mov	 DWORD PTR ?stopped_counter@?1??get_pan_steps@@9@9, eax
  00445	75 16		 jne	 SHORT $LN22@get_pan_st

; 2918 :       {
; 2919 :          stopped = 1;

  00447	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?stopped@?1??get_pan_steps@@9@9, 1

; 2920 :          reset_pan_state();       // Clear out old data. Without this, there can be

  00451	e8 00 00 00 00	 call	 _reset_pan_state

; 2921 :          pulse = 1;               // little artifacts when restarting.

  00456	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _pulse$[ebp], 1
$LN22@get_pan_st:

; 2922 :       }
; 2923 :    return pulse;

  0045d	8b 45 ec	 mov	 eax, DWORD PTR _pulse$[ebp]
$LN1@get_pan_st:

; 2924 : }

  00460	5f		 pop	 edi
  00461	5e		 pop	 esi
  00462	5b		 pop	 ebx
  00463	8b e5		 mov	 esp, ebp
  00465	5d		 pop	 ebp
  00466	c3		 ret	 0
_get_pan_steps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _reset_pan_state
_TEXT	SEGMENT
_reset_pan_state PROC					; COMDAT

; 2775 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2776 :    cur_pan_xstep = 0.0;

  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _cur_pan_xstep, xmm0

; 2777 :    cur_pan_ystep = 0.0;

  00014	0f 57 c0	 xorps	 xmm0, xmm0
  00017	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _cur_pan_ystep, xmm0

; 2778 :    pan_xstep_accum = 0.0;

  0001f	0f 57 c0	 xorps	 xmm0, xmm0
  00022	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _pan_xstep_accum, xmm0

; 2779 :    pan_ystep_accum = 0.0;

  0002a	0f 57 c0	 xorps	 xmm0, xmm0
  0002d	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _pan_ystep_accum, xmm0

; 2780 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_reset_pan_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _update_benchmarks
_TEXT	SEGMENT
tv129 = -72						; size = 4
tv92 = -68						; size = 4
_op_time$ = 8						; size = 8
_update_iters_sec$ = 16					; size = 4
_update_benchmarks PROC					; COMDAT

; 2735 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2736 :    #define UPDATE_INTERVAL_TIME  0.25 // update about 4 times per sec
; 2737 : 
; 2738 :    interval_frames++;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _interval_frames
  0000e	83 c0 01	 add	 eax, 1
  00011	a3 00 00 00 00	 mov	 DWORD PTR _interval_frames, eax

; 2739 :    total_frames++;

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _total_frames
  0001b	83 c0 01	 add	 eax, 1
  0001e	a3 00 00 00 00	 mov	 DWORD PTR _total_frames, eax

; 2740 :    interval_time += op_time;        // Update interval and total operation times

  00023	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _interval_time
  0002b	f2 0f 58 45 08	 addsd	 xmm0, QWORD PTR _op_time$[ebp]
  00030	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _interval_time, xmm0

; 2741 :    total_time += op_time;

  00038	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _total_time
  00040	f2 0f 58 45 08	 addsd	 xmm0, QWORD PTR _op_time$[ebp]
  00045	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _total_time, xmm0

; 2742 :    calc_total_time += iter_time;    // Update time spent only on mandelbrot calculation

  0004d	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _calc_total_time
  00055	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR _iter_time
  0005d	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _calc_total_time, xmm0

; 2743 :    calc_interval_time += iter_time; // Update time spent only on mandelbrot calculation this interval

  00065	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _calc_interval_time
  0006d	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR _iter_time
  00075	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _calc_interval_time, xmm0

; 2744 : 
; 2745 :    if (interval_time >= UPDATE_INTERVAL_TIME) // Update status line every interval

  0007d	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _interval_time
  00085	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3fd0000000000000
  0008d	0f 82 bb 00 00
	00		 jb	 $LN2@update_ben

; 2746 :    {
; 2747 :       print_fps_status_line((double) interval_frames / interval_time,

  00093	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4059000000000000
  0009b	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR _calc_interval_time
  000a3	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR _interval_time
  000ab	83 ec 08	 sub	 esp, 8
  000ae	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _total_frames
  000b8	89 45 bc	 mov	 DWORD PTR tv92[ebp], eax
  000bb	f2 0f 2a 45 bc	 cvtsi2sd xmm0, DWORD PTR tv92[ebp]
  000c0	8b 4d bc	 mov	 ecx, DWORD PTR tv92[ebp]
  000c3	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000c6	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  000cf	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR _total_time
  000d7	83 ec 08	 sub	 esp, 8
  000da	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _interval_frames
  000e5	89 55 b8	 mov	 DWORD PTR tv129[ebp], edx
  000e8	f2 0f 2a 45 b8	 cvtsi2sd xmm0, DWORD PTR tv129[ebp]
  000ed	8b 45 b8	 mov	 eax, DWORD PTR tv129[ebp]
  000f0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000f3	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  000fc	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR _interval_time
  00104	83 ec 08	 sub	 esp, 8
  00107	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0010c	e8 00 00 00 00	 call	 _print_fps_status_line
  00111	83 c4 18	 add	 esp, 24			; 00000018H

; 2748 :                            (double) total_frames / total_time,
; 2749 :                            100.0 * (double) calc_interval_time / interval_time); // interval iteration %
; 2750 :                            //100.0 * (double) calc_total_time / total_time);     // average iteration %
; 2751 : 
; 2752 :       SetWindowText(hwnd_info, get_image_info(update_iters_sec)); // Update image info

  00114	8b 45 10	 mov	 eax, DWORD PTR _update_iters_sec$[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _get_image_info
  0011d	83 c4 04	 add	 esp, 4
  00120	50		 push	 eax
  00121	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_info
  00127	51		 push	 ecx
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 2753 :       interval_frames = 0;

  0012e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _interval_frames, 0

; 2754 :       interval_time = 0.0;

  00138	0f 57 c0	 xorps	 xmm0, xmm0
  0013b	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _interval_time, xmm0

; 2755 :       calc_interval_time = 0.0;

  00143	0f 57 c0	 xorps	 xmm0, xmm0
  00146	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _calc_interval_time, xmm0
$LN2@update_ben:

; 2756 :    }
; 2757 : }

  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	5b		 pop	 ebx
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c3		 ret	 0
_update_benchmarks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _print_fps_status_line
_TEXT	SEGMENT
tv72 = -328						; size = 4
_m$ = -260						; size = 4
_s$ = -256						; size = 256
_fps$ = 8						; size = 8
_avg_fps$ = 16						; size = 8
_eff$ = 24						; size = 8
_print_fps_status_line PROC				; COMDAT

; 2710 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 2711 :    char s[256];
; 2712 :    man_calc_struct *m;
; 2713 : 
; 2714 :    if (status & STAT_DOING_SAVE) // if currently saving, keep saving status line

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00011	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00016	74 05		 je	 SHORT $LN2@print_fps_

; 2715 :       return;

  00018	e9 b9 00 00 00	 jmp	 $LN1@print_fps_
$LN2@print_fps_:

; 2716 : 
; 2717 :    m = &main_man_calc_struct;

  0001d	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 2718 : 
; 2719 :    // Interval and average frames/sec. Removed "AVG" so large frame rates don't get cut off
; 2720 :    sprintf_s(s, sizeof(s), "%c Fps %3.0f/%-3.0f", m->cur_alg & ALG_EXACT ? 'E' : 'F',

  00027	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  0002d	8b 88 cc 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36300]
  00033	83 e1 01	 and	 ecx, 1
  00036	74 0c		 je	 SHORT $LN4@print_fps_
  00038	c7 85 b8 fe ff
	ff 45 00 00 00	 mov	 DWORD PTR tv72[ebp], 69	; 00000045H
  00042	eb 0a		 jmp	 SHORT $LN5@print_fps_
$LN4@print_fps_:
  00044	c7 85 b8 fe ff
	ff 46 00 00 00	 mov	 DWORD PTR tv72[ebp], 70	; 00000046H
$LN5@print_fps_:
  0004e	83 ec 08	 sub	 esp, 8
  00051	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _avg_fps$[ebp]
  00056	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0005b	83 ec 08	 sub	 esp, 8
  0005e	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _fps$[ebp]
  00063	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00068	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  0006e	52		 push	 edx
  0006f	68 00 00 00 00	 push	 OFFSET $SG41278
  00074	68 00 01 00 00	 push	 256			; 00000100H
  00079	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 _sprintf_s
  00085	83 c4 20	 add	 esp, 32			; 00000020H

; 2721 :              fps, avg_fps);
; 2722 :    SetWindowText(hwnd_status, s);

  00088	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0008e	50		 push	 eax
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_status
  00095	51		 push	 ecx
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 2723 : 
; 2724 :    // Iteration percentage: mandelbrot calculation time / total time
; 2725 :    sprintf_s(s, sizeof(s), "Iter %2.0f%%", eff);

  0009c	83 ec 08	 sub	 esp, 8
  0009f	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _eff$[ebp]
  000a4	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000a9	68 00 00 00 00	 push	 OFFSET $SG41279
  000ae	68 00 01 00 00	 push	 256			; 00000100H
  000b3	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _sprintf_s
  000bf	83 c4 14	 add	 esp, 20			; 00000014H

; 2726 :    SetWindowText(hwnd_status2, s);

  000c2	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  000c8	50		 push	 eax
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_status2
  000cf	51		 push	 ecx
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
$LN1@print_fps_:

; 2727 : }

  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
_print_fps_status_line ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_image_info
_TEXT	SEGMENT
tv380 = -400						; size = 8
tv309 = -400						; size = 8
tv378 = -392						; size = 8
tv296 = -392						; size = 8
_m$ = -320						; size = 4
_tmp$ = -316						; size = 256
_t$ = -60						; size = 4
_points_guessed$ = -56					; size = 4
_i$ = -52						; size = 4
_max_tot_pct$ = -48					; size = 8
_tot_pct$ = -40						; size = 8
_max_cur_pct$ = -32					; size = 8
_cur_pct$ = -24						; size = 8
_ictr_total_raw$ = -16					; size = 8
_ictr_raw$ = -8						; size = 8
_update_iters_sec$ = 8					; size = 4
_get_image_info PROC					; COMDAT

; 2589 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 01 00
	00		 sub	 esp, 400		; 00000190H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 2590 :    static char s[1024 + 32 * MAX_THREADS];
; 2591 :    static char iters_str[256];
; 2592 :    static unsigned long long ictr = 0;
; 2593 :    static double guessed_pct = 0.0;
; 2594 :    static double miters_s = 0.0;             // mega iterations/sec
; 2595 :    static double avg_iters = 0.0;            // average iterations per pixel
; 2596 : 
; 2597 :    unsigned long long ictr_raw;
; 2598 :    unsigned long long ictr_total_raw;
; 2599 :    double cur_pct, max_cur_pct, tot_pct, max_tot_pct;
; 2600 :    int i, points_guessed;
; 2601 :    thread_state *t;
; 2602 :    char tmp[256];
; 2603 :    man_calc_struct *m;
; 2604 : 
; 2605 :    m = &main_man_calc_struct;

  0000c	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 2606 : 
; 2607 :    ictr_raw = 0;

  00016	0f 57 c0	 xorps	 xmm0, xmm0
  00019	66 0f 13 45 f8	 movlpd	 QWORD PTR _ictr_raw$[ebp], xmm0

; 2608 :    ictr_total_raw = 0;

  0001e	0f 57 c0	 xorps	 xmm0, xmm0
  00021	66 0f 13 45 f0	 movlpd	 QWORD PTR _ictr_total_raw$[ebp], xmm0

; 2609 :    points_guessed = 0;

  00026	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _points_guessed$[ebp], 0

; 2610 :    for (i = 0; i < num_threads; i++)

  0002d	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00034	eb 09		 jmp	 SHORT $LN4@get_image_
$LN2@get_image_:
  00036	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 45 cc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@get_image_:
  0003f	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  00042	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _num_threads
  00048	7d 61		 jge	 SHORT $LN3@get_image_

; 2611 :    {
; 2612 :       t = &m->thread_states[i];

  0004a	69 45 cc a8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 168
  00051	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00057	8d 94 01 08 78
	00 00		 lea	 edx, DWORD PTR [ecx+eax+30728]
  0005e	89 55 c4	 mov	 DWORD PTR _t$[ebp], edx

; 2613 :       points_guessed += t->points_guessed;

  00061	8b 45 c4	 mov	 eax, DWORD PTR _t$[ebp]
  00064	8b 4d c8	 mov	 ecx, DWORD PTR _points_guessed$[ebp]
  00067	03 88 a0 00 00
	00		 add	 ecx, DWORD PTR [eax+160]
  0006d	89 4d c8	 mov	 DWORD PTR _points_guessed$[ebp], ecx

; 2614 :       ictr_raw += t->ps_ptr->iterctr;         // N iterations per tick

  00070	8b 45 c4	 mov	 eax, DWORD PTR _t$[ebp]
  00073	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00076	8b 55 f8	 mov	 edx, DWORD PTR _ictr_raw$[ebp]
  00079	03 91 80 03 00
	00		 add	 edx, DWORD PTR [ecx+896]
  0007f	8b 45 fc	 mov	 eax, DWORD PTR _ictr_raw$[ebp+4]
  00082	13 81 84 03 00
	00		 adc	 eax, DWORD PTR [ecx+900]
  00088	89 55 f8	 mov	 DWORD PTR _ictr_raw$[ebp], edx
  0008b	89 45 fc	 mov	 DWORD PTR _ictr_raw$[ebp+4], eax

; 2615 :       ictr_total_raw += t->total_iters;

  0008e	8b 45 c4	 mov	 eax, DWORD PTR _t$[ebp]
  00091	8b 4d f0	 mov	 ecx, DWORD PTR _ictr_total_raw$[ebp]
  00094	03 88 98 00 00
	00		 add	 ecx, DWORD PTR [eax+152]
  0009a	8b 55 f4	 mov	 edx, DWORD PTR _ictr_total_raw$[ebp+4]
  0009d	13 90 9c 00 00
	00		 adc	 edx, DWORD PTR [eax+156]
  000a3	89 4d f0	 mov	 DWORD PTR _ictr_total_raw$[ebp], ecx
  000a6	89 55 f4	 mov	 DWORD PTR _ictr_total_raw$[ebp+4], edx

; 2616 :    }

  000a9	eb 8b		 jmp	 SHORT $LN2@get_image_
$LN3@get_image_:

; 2617 : 
; 2618 :    if (update_iters_sec)

  000ab	83 7d 08 00	 cmp	 DWORD PTR _update_iters_sec$[ebp], 0
  000af	0f 84 70 01 00
	00		 je	 $LN8@get_image_

; 2619 :    {
; 2620 :       // For the C versions, each tick is 1 iteration.
; 2621 :       // For the SSE2 ASM versions, each tick is 4 iterations.
; 2622 :       // For the SSE ASM versions, each tick is 8 iterations.
; 2623 : 
; 2624 :       ictr = ictr_raw;

  000b5	8b 45 f8	 mov	 eax, DWORD PTR _ictr_raw$[ebp]
  000b8	a3 00 00 00 00	 mov	 DWORD PTR ?ictr@?1??get_image_info@@9@9, eax
  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _ictr_raw$[ebp+4]
  000c0	89 0d 04 00 00
	00		 mov	 DWORD PTR ?ictr@?1??get_image_info@@9@9+4, ecx

; 2625 :       if (!(m->alg & ALG_C))

  000c6	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  000cc	8b 88 c8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36296]
  000d2	83 e1 04	 and	 ecx, 4
  000d5	75 6a		 jne	 SHORT $LN11@get_image_

; 2626 :       {
; 2627 :          if (m->precision == PRECISION_DOUBLE && sse_support >= 2)

  000d7	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  000dd	83 b8 d0 8d 00
	00 02		 cmp	 DWORD PTR [eax+36304], 2
  000e4	75 26		 jne	 SHORT $LN10@get_image_
  000e6	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _sse_support, 2
  000ed	7c 1d		 jl	 SHORT $LN10@get_image_

; 2628 :             ictr <<= 2;

  000ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ictr@?1??get_image_info@@9@9
  000f4	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?ictr@?1??get_image_info@@9@9+4
  000fa	b1 02		 mov	 cl, 2
  000fc	e8 00 00 00 00	 call	 __allshl
  00101	a3 00 00 00 00	 mov	 DWORD PTR ?ictr@?1??get_image_info@@9@9, eax
  00106	89 15 04 00 00
	00		 mov	 DWORD PTR ?ictr@?1??get_image_info@@9@9+4, edx
$LN10@get_image_:

; 2629 :          if (m->precision == PRECISION_SINGLE && sse_support >= 1)

  0010c	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00112	83 b8 d0 8d 00
	00 01		 cmp	 DWORD PTR [eax+36304], 1
  00119	75 26		 jne	 SHORT $LN11@get_image_
  0011b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _sse_support, 1
  00122	7c 1d		 jl	 SHORT $LN11@get_image_

; 2630 :             ictr <<= 3;

  00124	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ictr@?1??get_image_info@@9@9
  00129	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?ictr@?1??get_image_info@@9@9+4
  0012f	b1 03		 mov	 cl, 3
  00131	e8 00 00 00 00	 call	 __allshl
  00136	a3 00 00 00 00	 mov	 DWORD PTR ?ictr@?1??get_image_info@@9@9, eax
  0013b	89 15 04 00 00
	00		 mov	 DWORD PTR ?ictr@?1??get_image_info@@9@9+4, edx
$LN11@get_image_:

; 2631 :       }
; 2632 : 
; 2633 :       if (iter_time < 0.001)  // Prevent division by 0. If the time is in this neighborhood

  00141	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f50624dd2f1a9fc
  00149	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR _iter_time
  00151	76 10		 jbe	 SHORT $LN12@get_image_

; 2634 :          iter_time = 0.001;   // the iters/sec won't be accurate anyway.

  00153	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f50624dd2f1a9fc
  0015b	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _iter_time, xmm0
$LN12@get_image_:

; 2635 :       miters_s = (double) ictr * 1e-6 / iter_time;

  00163	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?ictr@?1??get_image_info@@9@9+4
  00169	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ictr@?1??get_image_info@@9@9
  0016f	e8 00 00 00 00	 call	 __ultod3
  00174	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3eb0c6f7a0b5ed8d
  0017c	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR _iter_time
  00184	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?miters_s@?1??get_image_info@@9@9, xmm0

; 2636 :       avg_iters = (double) ictr / (double) m->image_size;

  0018c	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?ictr@?1??get_image_info@@9@9+4
  00192	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ictr@?1??get_image_info@@9@9
  00198	e8 00 00 00 00	 call	 __ultod3
  0019d	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  001a3	f2 0f 2a 88 94
	8d 00 00	 cvtsi2sd xmm1, DWORD PTR [eax+36244]
  001ab	f2 0f 5e c1	 divsd	 xmm0, xmm1
  001af	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?avg_iters@?1??get_image_info@@9@9, xmm0

; 2637 : 
; 2638 :       guessed_pct = 100.0 * (double) points_guessed / (double) m->image_size;

  001b7	f2 0f 2a 45 c8	 cvtsi2sd xmm0, DWORD PTR _points_guessed$[ebp]
  001bc	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  001c4	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  001ca	f2 0f 2a 88 94
	8d 00 00	 cvtsi2sd xmm1, DWORD PTR [eax+36244]
  001d2	f2 0f 5e c1	 divsd	 xmm0, xmm1
  001d6	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?guessed_pct@?1??get_image_info@@9@9, xmm0

; 2639 : 
; 2640 :       // Since one flop is optimized out per 18 flops in the ASM versions,
; 2641 :       // factor should really be 8.5 for those. But actually does 9 "effective" flops per iteration
; 2642 : 
; 2643 :       sprintf_s(iters_str, sizeof(iters_str), "%-4.4gM (%-.2f GFlops)", miters_s,

  001de	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR ?miters_s@?1??get_image_info@@9@9
  001e6	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4022000000000000
  001ee	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3f50624dd2f1a9fc
  001f6	83 ec 08	 sub	 esp, 8
  001f9	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001fe	83 ec 08	 sub	 esp, 8
  00201	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR ?miters_s@?1??get_image_info@@9@9
  00209	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0020e	68 00 00 00 00	 push	 OFFSET $SG41258
  00213	68 00 01 00 00	 push	 256			; 00000100H
  00218	68 00 00 00 00	 push	 OFFSET ?iters_str@?1??get_image_info@@9@9
  0021d	e8 00 00 00 00	 call	 _sprintf_s
  00222	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN8@get_image_:

; 2644 :                 miters_s * 9.0 * 1e-3);
; 2645 :    }
; 2646 : 
; 2647 :    sprintf_s(s, sizeof(s),   // Microsoft wants secure version

  00225	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?ictr@?1??get_image_info@@9@9+4
  0022b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ictr@?1??get_image_info@@9@9
  00231	e8 00 00 00 00	 call	 __ultod3
  00236	83 ec 08	 sub	 esp, 8
  00239	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0023e	83 ec 08	 sub	 esp, 8
  00241	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR ?guessed_pct@?1??get_image_info@@9@9
  00249	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0024e	83 ec 08	 sub	 esp, 8
  00251	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR ?avg_iters@?1??get_image_info@@9@9
  00259	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0025e	68 00 00 00 00	 push	 OFFSET ?iters_str@?1??get_image_info@@9@9
  00263	83 ec 08	 sub	 esp, 8
  00266	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _iter_time
  0026e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00273	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00279	8b 88 8c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36236]
  0027f	51		 push	 ecx
  00280	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _m$[ebp]
  00286	8b 82 88 8d 00
	00		 mov	 eax, DWORD PTR [edx+36232]
  0028c	50		 push	 eax
  0028d	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00293	83 ec 08	 sub	 esp, 8
  00296	f2 0f 10 81 b8
	8d 00 00	 movsd	 xmm0, QWORD PTR [ecx+36280]
  0029e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002a3	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _m$[ebp]
  002a9	8b 82 a4 8d 00
	00		 mov	 eax, DWORD PTR [edx+36260]
  002af	50		 push	 eax
  002b0	8b 8a a0 8d 00
	00		 mov	 ecx, DWORD PTR [edx+36256]
  002b6	51		 push	 ecx
  002b7	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _m$[ebp]
  002bd	52		 push	 edx
  002be	e8 00 00 00 00	 call	 _get_re_im_offs
  002c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c6	dd 9d 78 fe ff
	ff		 fstp	 QWORD PTR tv296[ebp]
  002cc	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  002d2	f2 0f 10 80 b0
	8d 00 00	 movsd	 xmm0, QWORD PTR [eax+36272]
  002da	f2 0f 5c 85 78
	fe ff ff	 subsd	 xmm0, QWORD PTR tv296[ebp]
  002e2	83 ec 08	 sub	 esp, 8
  002e5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002ea	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  002f0	8b 91 9c 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36252]
  002f6	52		 push	 edx
  002f7	8b 81 98 8d 00
	00		 mov	 eax, DWORD PTR [ecx+36248]
  002fd	50		 push	 eax
  002fe	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00304	51		 push	 ecx
  00305	e8 00 00 00 00	 call	 _get_re_im_offs
  0030a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0030d	dd 9d 70 fe ff
	ff		 fstp	 QWORD PTR tv309[ebp]
  00313	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _m$[ebp]
  00319	f2 0f 10 85 70
	fe ff ff	 movsd	 xmm0, QWORD PTR tv309[ebp]
  00321	f2 0f 58 82 a8
	8d 00 00	 addsd	 xmm0, QWORD PTR [edx+36264]
  00329	83 ec 08	 sub	 esp, 8
  0032c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00331	68 00 00 00 00	 push	 OFFSET $SG41259
  00336	68 00 08 00 00	 push	 2048			; 00000800H
  0033b	68 00 00 00 00	 push	 OFFSET ?s@?1??get_image_info@@9@9
  00340	e8 00 00 00 00	 call	 _sprintf_s
  00345	83 c4 50	 add	 esp, 80			; 00000050H

; 2648 :               "Real\t%-16.16lf\r\n"
; 2649 :               "Imag\t%-16.16lf\r\n"
; 2650 :               "Mag\t%-16lf\r\n"
; 2651 :               "\r\n"
; 2652 :               "Size\t%u x %u\r\n"
; 2653 :               "Time\t%-3.3fs\r\n"
; 2654 :               "Iters/s\t%s\r\n"
; 2655 : 
; 2656 :               "\r\n" // Everything here and below is "hidden" - must scroll down to see
; 2657 : 
; 2658 :               "Avg iters/pixel\t%-.1lf\r\n"
; 2659 :               "Points guessed\t%-.1lf%%\r\n"
; 2660 :               "Total iters\t%-.0lf\r\n",
; 2661 : 
; 2662 :               // With new panning method, need to get actual screen centerpoint using pan offsets
; 2663 :               m->re + get_re_im_offs(m, m->pan_xoffs),
; 2664 :               m->im - get_re_im_offs(m, m->pan_yoffs),
; 2665 :               m->mag, m->xsize, m->ysize, iter_time, iters_str,  // Miters/s string created above
; 2666 :               avg_iters, guessed_pct, (double) ictr
; 2667 :               );
; 2668 : 
; 2669 :    // Get each thread's percentage of the total load, to check balance.
; 2670 : 
; 2671 :    sprintf_s(tmp, sizeof(tmp), "\r\nThread load %%\tCur    Total\r\n");

  00348	68 00 00 00 00	 push	 OFFSET $SG41260
  0034d	68 00 01 00 00	 push	 256			; 00000100H
  00352	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  00358	50		 push	 eax
  00359	e8 00 00 00 00	 call	 _sprintf_s
  0035e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2672 :    strcat_s(s, sizeof(s), tmp);

  00361	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  00367	50		 push	 eax
  00368	68 00 08 00 00	 push	 2048			; 00000800H
  0036d	68 00 00 00 00	 push	 OFFSET ?s@?1??get_image_info@@9@9
  00372	e8 00 00 00 00	 call	 _strcat_s
  00377	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2673 : 
; 2674 :    max_cur_pct = 0.0;

  0037a	0f 57 c0	 xorps	 xmm0, xmm0
  0037d	f2 0f 11 45 e0	 movsd	 QWORD PTR _max_cur_pct$[ebp], xmm0

; 2675 :    max_tot_pct = 0.0;

  00382	0f 57 c0	 xorps	 xmm0, xmm0
  00385	f2 0f 11 45 d0	 movsd	 QWORD PTR _max_tot_pct$[ebp], xmm0

; 2676 :    for (i = 0; i < num_threads; i++)

  0038a	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00391	eb 09		 jmp	 SHORT $LN7@get_image_
$LN5@get_image_:
  00393	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  00396	83 c0 01	 add	 eax, 1
  00399	89 45 cc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@get_image_:
  0039c	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  0039f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _num_threads
  003a5	0f 8d 1b 01 00
	00		 jge	 $LN6@get_image_

; 2677 :    {
; 2678 :       t = &m->thread_states[i];

  003ab	69 45 cc a8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 168
  003b2	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  003b8	8d 94 01 08 78
	00 00		 lea	 edx, DWORD PTR [ecx+eax+30728]
  003bf	89 55 c4	 mov	 DWORD PTR _t$[ebp], edx

; 2679 :       sprintf_s(tmp, sizeof(tmp),

  003c2	8b 45 c4	 mov	 eax, DWORD PTR _t$[ebp]
  003c5	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  003cb	8b 90 9c 00 00
	00		 mov	 edx, DWORD PTR [eax+156]
  003d1	e8 00 00 00 00	 call	 __ultod3
  003d6	8b 55 f4	 mov	 edx, DWORD PTR _ictr_total_raw$[ebp+4]
  003d9	8b 4d f0	 mov	 ecx, DWORD PTR _ictr_total_raw$[ebp]
  003dc	f2 0f 11 85 78
	fe ff ff	 movsd	 QWORD PTR tv378[ebp], xmm0
  003e4	e8 00 00 00 00	 call	 __ultod3
  003e9	f2 0f 10 8d 78
	fe ff ff	 movsd	 xmm1, QWORD PTR tv378[ebp]
  003f1	f2 0f 5e c8	 divsd	 xmm1, xmm0
  003f5	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@4059000000000000
  003fd	f2 0f 11 4d d8	 movsd	 QWORD PTR _tot_pct$[ebp], xmm1
  00402	8b 4d c4	 mov	 ecx, DWORD PTR _t$[ebp]
  00405	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00408	8b 8a 80 03 00
	00		 mov	 ecx, DWORD PTR [edx+896]
  0040e	8b 92 84 03 00
	00		 mov	 edx, DWORD PTR [edx+900]
  00414	e8 00 00 00 00	 call	 __ultod3
  00419	8b 55 fc	 mov	 edx, DWORD PTR _ictr_raw$[ebp+4]
  0041c	8b 4d f8	 mov	 ecx, DWORD PTR _ictr_raw$[ebp]
  0041f	f2 0f 11 85 70
	fe ff ff	 movsd	 QWORD PTR tv380[ebp], xmm0
  00427	e8 00 00 00 00	 call	 __ultod3
  0042c	f2 0f 10 8d 70
	fe ff ff	 movsd	 xmm1, QWORD PTR tv380[ebp]
  00434	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00438	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@4059000000000000
  00440	f2 0f 11 4d e8	 movsd	 QWORD PTR _cur_pct$[ebp], xmm1
  00445	83 ec 08	 sub	 esp, 8
  00448	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR _tot_pct$[ebp]
  0044d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00452	83 ec 08	 sub	 esp, 8
  00455	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _cur_pct$[ebp]
  0045a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0045f	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  00462	50		 push	 eax
  00463	68 00 00 00 00	 push	 OFFSET $SG41261
  00468	68 00 01 00 00	 push	 256			; 00000100H
  0046d	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _tmp$[ebp]
  00473	51		 push	 ecx
  00474	e8 00 00 00 00	 call	 _sprintf_s
  00479	83 c4 20	 add	 esp, 32			; 00000020H

; 2680 :                "Thread %d\t%#3.3g   %#3.3g\r\n", i,
; 2681 :                cur_pct = (double) t->ps_ptr->iterctr / (double) ictr_raw * 100.0,
; 2682 :                tot_pct = (double) t->total_iters / (double) ictr_total_raw * 100.0);
; 2683 :       strcat_s(s, sizeof(s), tmp);

  0047c	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  00482	50		 push	 eax
  00483	68 00 08 00 00	 push	 2048			; 00000800H
  00488	68 00 00 00 00	 push	 OFFSET ?s@?1??get_image_info@@9@9
  0048d	e8 00 00 00 00	 call	 _strcat_s
  00492	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2684 : 
; 2685 :       if (cur_pct > max_cur_pct)

  00495	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _cur_pct$[ebp]
  0049a	66 0f 2f 45 e0	 comisd	 xmm0, QWORD PTR _max_cur_pct$[ebp]
  0049f	76 0a		 jbe	 SHORT $LN13@get_image_

; 2686 :          max_cur_pct = cur_pct;

  004a1	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _cur_pct$[ebp]
  004a6	f2 0f 11 45 e0	 movsd	 QWORD PTR _max_cur_pct$[ebp], xmm0
$LN13@get_image_:

; 2687 :       if (tot_pct > max_tot_pct)

  004ab	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR _tot_pct$[ebp]
  004b0	66 0f 2f 45 d0	 comisd	 xmm0, QWORD PTR _max_tot_pct$[ebp]
  004b5	76 0a		 jbe	 SHORT $LN14@get_image_

; 2688 :          max_tot_pct = tot_pct;

  004b7	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR _tot_pct$[ebp]
  004bc	f2 0f 11 45 d0	 movsd	 QWORD PTR _max_tot_pct$[ebp], xmm0
$LN14@get_image_:

; 2689 :    }

  004c1	e9 cd fe ff ff	 jmp	 $LN5@get_image_
$LN6@get_image_:

; 2690 : 
; 2691 :    // Figure of merit: percentage of best possible speed, which occurs with
; 2692 :    // perfect thread load balancing.
; 2693 :    sprintf_s(tmp, sizeof(tmp),

  004c6	83 ec 08	 sub	 esp, 8
  004c9	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _file_tot_time
  004d1	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  004d6	f2 0f 2a 05 00
	00 00 00	 cvtsi2sd xmm0, DWORD PTR _num_threads
  004de	f2 0f 59 45 d0	 mulsd	 xmm0, QWORD PTR _max_tot_pct$[ebp]
  004e3	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@40c3880000000000
  004eb	f2 0f 5e c8	 divsd	 xmm1, xmm0
  004ef	83 ec 08	 sub	 esp, 8
  004f2	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  004f7	f2 0f 2a 05 00
	00 00 00	 cvtsi2sd xmm0, DWORD PTR _num_threads
  004ff	f2 0f 59 45 e0	 mulsd	 xmm0, QWORD PTR _max_cur_pct$[ebp]
  00504	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@40c3880000000000
  0050c	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00510	83 ec 08	 sub	 esp, 8
  00513	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00518	68 00 00 00 00	 push	 OFFSET $SG41264
  0051d	68 00 01 00 00	 push	 256			; 00000100H
  00522	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  00528	50		 push	 eax
  00529	e8 00 00 00 00	 call	 _sprintf_s
  0052e	83 c4 24	 add	 esp, 36			; 00000024H

; 2694 :               "Efficiency %%\t%#3.3g   %#3.3g\r\n"
; 2695 :               "\r\nTotal calc time\t%-.3lfs\r\n" // resets whenever new file is opened
; 2696 :               "\r\n(C) 2006-2008 Paul Gentieu",
; 2697 :               100.0 * 100.0 / (num_threads * max_cur_pct),
; 2698 :               100.0 * 100.0 / (num_threads * max_tot_pct),
; 2699 :               file_tot_time);
; 2700 :    strcat_s(s, sizeof(s), tmp);

  00531	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  00537	50		 push	 eax
  00538	68 00 08 00 00	 push	 2048			; 00000800H
  0053d	68 00 00 00 00	 push	 OFFSET ?s@?1??get_image_info@@9@9
  00542	e8 00 00 00 00	 call	 _strcat_s
  00547	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2701 : 
; 2702 :    return s;

  0054a	b8 00 00 00 00	 mov	 eax, OFFSET ?s@?1??get_image_info@@9@9

; 2703 : }

  0054f	5f		 pop	 edi
  00550	5e		 pop	 esi
  00551	5b		 pop	 ebx
  00552	8b e5		 mov	 esp, ebp
  00554	5d		 pop	 ebp
  00555	c3		 ret	 0
_get_image_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _pan_image
_TEXT	SEGMENT
_m$ = -32						; size = 4
_u$ = -28						; size = 4
_q$ = -24						; size = 4
_tmp$ = -20						; size = 4
_swap_y$ = -16						; size = 4
_swap_x$ = -12						; size = 4
_ysize$ = -8						; size = 4
_xsize$ = -4						; size = 4
_offs_x$ = 8						; size = 4
_offs_y$ = 12						; size = 4
_pan_image PROC						; COMDAT

; 2423 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2424 :    int xsize, ysize, swap_x, swap_y, tmp;
; 2425 :    quadrant *q;
; 2426 :    rectangle *u;
; 2427 :    man_calc_struct *m;
; 2428 : 
; 2429 :    m = &main_man_calc_struct;

  00009	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 2430 : 
; 2431 :    if (offs_x | offs_y) // Recalculate only if the image moved

  00010	8b 45 08	 mov	 eax, DWORD PTR _offs_x$[ebp]
  00013	0b 45 0c	 or	 eax, DWORD PTR _offs_y$[ebp]
  00016	0f 84 8f 05 00
	00		 je	 $LN1@pan_image

; 2432 :    {
; 2433 :       // Update pan offsets
; 2434 :       m->pan_xoffs -= offs_x; // maybe invert offs_x, offs_y signs later

  0001c	8b 45 08	 mov	 eax, DWORD PTR _offs_x$[ebp]
  0001f	99		 cdq
  00020	8b 4d e0	 mov	 ecx, DWORD PTR _m$[ebp]
  00023	8b b1 98 8d 00
	00		 mov	 esi, DWORD PTR [ecx+36248]
  00029	2b f0		 sub	 esi, eax
  0002b	8b 81 9c 8d 00
	00		 mov	 eax, DWORD PTR [ecx+36252]
  00031	1b c2		 sbb	 eax, edx
  00033	8b 4d e0	 mov	 ecx, DWORD PTR _m$[ebp]
  00036	89 b1 98 8d 00
	00		 mov	 DWORD PTR [ecx+36248], esi
  0003c	89 81 9c 8d 00
	00		 mov	 DWORD PTR [ecx+36252], eax

; 2435 :       m->pan_yoffs -= offs_y;

  00042	8b 45 0c	 mov	 eax, DWORD PTR _offs_y$[ebp]
  00045	99		 cdq
  00046	8b 4d e0	 mov	 ecx, DWORD PTR _m$[ebp]
  00049	8b b1 a0 8d 00
	00		 mov	 esi, DWORD PTR [ecx+36256]
  0004f	2b f0		 sub	 esi, eax
  00051	8b 81 a4 8d 00
	00		 mov	 eax, DWORD PTR [ecx+36260]
  00057	1b c2		 sbb	 eax, edx
  00059	8b 4d e0	 mov	 ecx, DWORD PTR _m$[ebp]
  0005c	89 b1 a0 8d 00
	00		 mov	 DWORD PTR [ecx+36256], esi
  00062	89 81 a4 8d 00
	00		 mov	 DWORD PTR [ecx+36260], eax

; 2436 : 
; 2437 :       xsize = m->xsize;

  00068	8b 45 e0	 mov	 eax, DWORD PTR _m$[ebp]
  0006b	8b 88 88 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36232]
  00071	89 4d fc	 mov	 DWORD PTR _xsize$[ebp], ecx

; 2438 :       ysize = m->ysize;

  00074	8b 45 e0	 mov	 eax, DWORD PTR _m$[ebp]
  00077	8b 88 8c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36236]
  0007d	89 4d f8	 mov	 DWORD PTR _ysize$[ebp], ecx

; 2439 : 
; 2440 :       // See algorithm explanation above
; 2441 :       screen_xpos -= offs_x;  // update screen pos

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_xpos
  00085	2b 45 08	 sub	 eax, DWORD PTR _offs_x$[ebp]
  00088	a3 00 00 00 00	 mov	 DWORD PTR _screen_xpos, eax

; 2442 :       screen_ypos -= offs_y;

  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_ypos
  00092	2b 45 0c	 sub	 eax, DWORD PTR _offs_y$[ebp]
  00095	a3 00 00 00 00	 mov	 DWORD PTR _screen_ypos, eax

; 2443 : 
; 2444 :       // Renormalize screen coordinates and swap quadrants if necessary
; 2445 :       swap_x = swap_y = 0;

  0009a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _swap_y$[ebp], 0
  000a1	8b 45 f0	 mov	 eax, DWORD PTR _swap_y$[ebp]
  000a4	89 45 f4	 mov	 DWORD PTR _swap_x$[ebp], eax

; 2446 :       if (screen_xpos < 0)

  000a7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _screen_xpos, 0
  000ae	7d 14		 jge	 SHORT $LN3@pan_image

; 2447 :       {
; 2448 :          screen_xpos += xsize;

  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_xpos
  000b5	03 45 fc	 add	 eax, DWORD PTR _xsize$[ebp]
  000b8	a3 00 00 00 00	 mov	 DWORD PTR _screen_xpos, eax

; 2449 :          swap_x = 1;

  000bd	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _swap_x$[ebp], 1
$LN3@pan_image:

; 2450 :       }
; 2451 :       if (screen_xpos > xsize)

  000c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_xpos
  000c9	3b 45 fc	 cmp	 eax, DWORD PTR _xsize$[ebp]
  000cc	7e 14		 jle	 SHORT $LN4@pan_image

; 2452 :       {
; 2453 :          screen_xpos -= xsize;

  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_xpos
  000d3	2b 45 fc	 sub	 eax, DWORD PTR _xsize$[ebp]
  000d6	a3 00 00 00 00	 mov	 DWORD PTR _screen_xpos, eax

; 2454 :          swap_x = 1;

  000db	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _swap_x$[ebp], 1
$LN4@pan_image:

; 2455 :       }
; 2456 :       if (screen_ypos < 0)

  000e2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _screen_ypos, 0
  000e9	7d 14		 jge	 SHORT $LN5@pan_image

; 2457 :       {
; 2458 :          screen_ypos += ysize;

  000eb	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_ypos
  000f0	03 45 f8	 add	 eax, DWORD PTR _ysize$[ebp]
  000f3	a3 00 00 00 00	 mov	 DWORD PTR _screen_ypos, eax

; 2459 :          swap_y = 1;

  000f8	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _swap_y$[ebp], 1
$LN5@pan_image:

; 2460 :       }
; 2461 :       if (screen_ypos > ysize)

  000ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_ypos
  00104	3b 45 f8	 cmp	 eax, DWORD PTR _ysize$[ebp]
  00107	7e 14		 jle	 SHORT $LN6@pan_image

; 2462 :       {
; 2463 :          screen_ypos -= ysize;

  00109	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_ypos
  0010e	2b 45 f8	 sub	 eax, DWORD PTR _ysize$[ebp]
  00111	a3 00 00 00 00	 mov	 DWORD PTR _screen_ypos, eax

; 2464 :          swap_y = 1;

  00116	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _swap_y$[ebp], 1
$LN6@pan_image:

; 2465 :       }
; 2466 :       if (swap_x)

  0011d	83 7d f4 00	 cmp	 DWORD PTR _swap_x$[ebp], 0
  00121	74 4a		 je	 SHORT $LN7@pan_image

; 2467 :       {
; 2468 :          swap_quadrants(&quad[UL], &quad[UR]);

  00123	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  00128	c1 e0 00	 shl	 eax, 0
  0012b	05 00 00 00 00	 add	 eax, OFFSET _quad
  00130	50		 push	 eax
  00131	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00136	6b d1 00	 imul	 edx, ecx, 0
  00139	81 c2 00 00 00
	00		 add	 edx, OFFSET _quad
  0013f	52		 push	 edx
  00140	e8 00 00 00 00	 call	 _swap_quadrants
  00145	83 c4 08	 add	 esp, 8

; 2469 :          swap_quadrants(&quad[LL], &quad[LR]);

  00148	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  0014d	6b c8 03	 imul	 ecx, eax, 3
  00150	81 c1 00 00 00
	00		 add	 ecx, OFFSET _quad
  00156	51		 push	 ecx
  00157	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  0015c	d1 e2		 shl	 edx, 1
  0015e	81 c2 00 00 00
	00		 add	 edx, OFFSET _quad
  00164	52		 push	 edx
  00165	e8 00 00 00 00	 call	 _swap_quadrants
  0016a	83 c4 08	 add	 esp, 8
$LN7@pan_image:

; 2470 :       }
; 2471 :       if (swap_y)

  0016d	83 7d f0 00	 cmp	 DWORD PTR _swap_y$[ebp], 0
  00171	74 4a		 je	 SHORT $LN8@pan_image

; 2472 :       {
; 2473 :          swap_quadrants(&quad[UL], &quad[LL]);

  00173	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  00178	d1 e0		 shl	 eax, 1
  0017a	05 00 00 00 00	 add	 eax, OFFSET _quad
  0017f	50		 push	 eax
  00180	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00185	6b d1 00	 imul	 edx, ecx, 0
  00188	81 c2 00 00 00
	00		 add	 edx, OFFSET _quad
  0018e	52		 push	 edx
  0018f	e8 00 00 00 00	 call	 _swap_quadrants
  00194	83 c4 08	 add	 esp, 8

; 2474 :          swap_quadrants(&quad[UR], &quad[LR]);

  00197	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  0019c	6b c8 03	 imul	 ecx, eax, 3
  0019f	81 c1 00 00 00
	00		 add	 ecx, OFFSET _quad
  001a5	51		 push	 ecx
  001a6	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  001ab	c1 e2 00	 shl	 edx, 0
  001ae	81 c2 00 00 00
	00		 add	 edx, OFFSET _quad
  001b4	52		 push	 edx
  001b5	e8 00 00 00 00	 call	 _swap_quadrants
  001ba	83 c4 08	 add	 esp, 8
$LN8@pan_image:

; 2475 :       }
; 2476 : 
; 2477 :       // Get the update rectangles (there can be either 1 or 2): determined by difference
; 2478 :       // between screen pos and previous screen pos (offs_x and offs_y). Use quadrant
; 2479 :       // coordinates (0,0 to 2 * xsize - 1, 2 * ysize - 1). Rectangles will be split
; 2480 :       // at quadrant boundaries during palette mapping. If either of the sizes is 0,
; 2481 :       // the rectangle will be ignored (not calculated or palette mapped).
; 2482 : 
; 2483 :       // Check for vertical rectangles (have an x offset)
; 2484 :       u = &update_rect[1];

  001bd	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001c2	c1 e0 00	 shl	 eax, 0
  001c5	05 00 00 00 00	 add	 eax, OFFSET _update_rect
  001ca	89 45 e4	 mov	 DWORD PTR _u$[ebp], eax

; 2485 :       u->valid = offs_x;                  // valid if any nonzero offset

  001cd	8b 45 e4	 mov	 eax, DWORD PTR _u$[ebp]
  001d0	8b 4d 08	 mov	 ecx, DWORD PTR _offs_x$[ebp]
  001d3	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2486 :       u->y[0] = screen_ypos;              // vertical rectangles are

  001d6	b8 04 00 00 00	 mov	 eax, 4
  001db	6b c8 00	 imul	 ecx, eax, 0
  001de	8b 55 e4	 mov	 edx, DWORD PTR _u$[ebp]
  001e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_ypos
  001e6	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 2487 :       u->y[1] = screen_ypos + ysize - 1;  // full height of screen

  001ea	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  001ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_ypos
  001f3	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  001f7	b8 04 00 00 00	 mov	 eax, 4
  001fc	c1 e0 00	 shl	 eax, 0
  001ff	8b 4d e4	 mov	 ecx, DWORD PTR _u$[ebp]
  00202	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 2488 : 
; 2489 :       if (offs_x > 0)

  00206	83 7d 08 00	 cmp	 DWORD PTR _offs_x$[ebp], 0
  0020a	7e 2e		 jle	 SHORT $LN9@pan_image

; 2490 :       {  // vertical rect at left
; 2491 :          u->x[0] = screen_xpos;

  0020c	b8 04 00 00 00	 mov	 eax, 4
  00211	6b c8 00	 imul	 ecx, eax, 0
  00214	8b 55 e4	 mov	 edx, DWORD PTR _u$[ebp]
  00217	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_xpos
  0021c	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 2492 :          u->x[1] = screen_xpos + offs_x - 1;

  0021f	8b 45 08	 mov	 eax, DWORD PTR _offs_x$[ebp]
  00222	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_xpos
  00228	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  0022c	b8 04 00 00 00	 mov	 eax, 4
  00231	c1 e0 00	 shl	 eax, 0
  00234	8b 4d e4	 mov	 ecx, DWORD PTR _u$[ebp]
  00237	89 14 01	 mov	 DWORD PTR [ecx+eax], edx
$LN9@pan_image:

; 2493 :       }
; 2494 :       if (offs_x < 0)

  0023a	83 7d 08 00	 cmp	 DWORD PTR _offs_x$[ebp], 0
  0023e	7d 34		 jge	 SHORT $LN10@pan_image

; 2495 :       {  // vertical rect at right
; 2496 :          u->x[0] = screen_xpos + xsize + offs_x;

  00240	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_xpos
  00245	03 45 fc	 add	 eax, DWORD PTR _xsize$[ebp]
  00248	03 45 08	 add	 eax, DWORD PTR _offs_x$[ebp]
  0024b	b9 04 00 00 00	 mov	 ecx, 4
  00250	6b d1 00	 imul	 edx, ecx, 0
  00253	8b 4d e4	 mov	 ecx, DWORD PTR _u$[ebp]
  00256	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 2497 :          u->x[1] = screen_xpos + xsize - 1;

  00259	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  0025c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_xpos
  00262	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  00266	b8 04 00 00 00	 mov	 eax, 4
  0026b	c1 e0 00	 shl	 eax, 0
  0026e	8b 4d e4	 mov	 ecx, DWORD PTR _u$[ebp]
  00271	89 14 01	 mov	 DWORD PTR [ecx+eax], edx
$LN10@pan_image:

; 2498 :       }
; 2499 : 
; 2500 :       // Check for horizontal rectangles (have a y offset).
; 2501 :       // Optimize out the corner intersection with any vertical rectangles so we don't
; 2502 :       // calculate it twice. Clip it off the vertical rect. The intersection could
; 2503 :       // be a large area for drag pans.
; 2504 : 
; 2505 :       u = &update_rect[0];

  00274	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00279	6b c8 00	 imul	 ecx, eax, 0
  0027c	81 c1 00 00 00
	00		 add	 ecx, OFFSET _update_rect
  00282	89 4d e4	 mov	 DWORD PTR _u$[ebp], ecx

; 2506 :       u->valid = offs_y;                  // valid if any nonzero offset

  00285	8b 45 e4	 mov	 eax, DWORD PTR _u$[ebp]
  00288	8b 4d 0c	 mov	 ecx, DWORD PTR _offs_y$[ebp]
  0028b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2507 :       u->x[0] = screen_xpos;              // horizontal rectangles are

  0028e	b8 04 00 00 00	 mov	 eax, 4
  00293	6b c8 00	 imul	 ecx, eax, 0
  00296	8b 55 e4	 mov	 edx, DWORD PTR _u$[ebp]
  00299	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_xpos
  0029e	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 2508 :       u->x[1] = screen_xpos + xsize - 1;  // full width of screen

  002a1	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  002a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_xpos
  002aa	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  002ae	b8 04 00 00 00	 mov	 eax, 4
  002b3	c1 e0 00	 shl	 eax, 0
  002b6	8b 4d e4	 mov	 ecx, DWORD PTR _u$[ebp]
  002b9	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 2509 : 
; 2510 :       if (offs_y > 0)

  002bc	83 7d 0c 00	 cmp	 DWORD PTR _offs_y$[ebp], 0
  002c0	7e 53		 jle	 SHORT $LN11@pan_image

; 2511 :       {  // horizontal rect at top
; 2512 :          u->y[0] = screen_ypos;

  002c2	b8 04 00 00 00	 mov	 eax, 4
  002c7	6b c8 00	 imul	 ecx, eax, 0
  002ca	8b 55 e4	 mov	 edx, DWORD PTR _u$[ebp]
  002cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_ypos
  002d2	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 2513 :          u->y[1] = tmp = screen_ypos + offs_y - 1;

  002d6	8b 45 0c	 mov	 eax, DWORD PTR _offs_y$[ebp]
  002d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_ypos
  002df	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  002e3	89 55 ec	 mov	 DWORD PTR _tmp$[ebp], edx
  002e6	b8 04 00 00 00	 mov	 eax, 4
  002eb	c1 e0 00	 shl	 eax, 0
  002ee	8b 4d e4	 mov	 ecx, DWORD PTR _u$[ebp]
  002f1	8b 55 ec	 mov	 edx, DWORD PTR _tmp$[ebp]
  002f4	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 2514 :          u[1].y[0] = tmp + 1;    // clip off corner intersection from any vertical rect

  002f8	8b 45 ec	 mov	 eax, DWORD PTR _tmp$[ebp]
  002fb	83 c0 01	 add	 eax, 1
  002fe	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00303	c1 e1 00	 shl	 ecx, 0
  00306	03 4d e4	 add	 ecx, DWORD PTR _u$[ebp]
  00309	ba 04 00 00 00	 mov	 edx, 4
  0030e	6b d2 00	 imul	 edx, edx, 0
  00311	89 44 11 08	 mov	 DWORD PTR [ecx+edx+8], eax
$LN11@pan_image:

; 2515 :       }
; 2516 :       if (offs_y < 0)

  00315	83 7d 0c 00	 cmp	 DWORD PTR _offs_y$[ebp], 0
  00319	7d 59		 jge	 SHORT $LN12@pan_image

; 2517 :       {  // horizontal rect at bottom
; 2518 :          u->y[0] = tmp = screen_ypos + ysize + offs_y;

  0031b	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_ypos
  00320	03 45 f8	 add	 eax, DWORD PTR _ysize$[ebp]
  00323	03 45 0c	 add	 eax, DWORD PTR _offs_y$[ebp]
  00326	89 45 ec	 mov	 DWORD PTR _tmp$[ebp], eax
  00329	b9 04 00 00 00	 mov	 ecx, 4
  0032e	6b d1 00	 imul	 edx, ecx, 0
  00331	8b 45 e4	 mov	 eax, DWORD PTR _u$[ebp]
  00334	8b 4d ec	 mov	 ecx, DWORD PTR _tmp$[ebp]
  00337	89 4c 10 08	 mov	 DWORD PTR [eax+edx+8], ecx

; 2519 :          u->y[1] = screen_ypos + ysize - 1;

  0033b	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  0033e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_ypos
  00344	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  00348	b8 04 00 00 00	 mov	 eax, 4
  0034d	c1 e0 00	 shl	 eax, 0
  00350	8b 4d e4	 mov	 ecx, DWORD PTR _u$[ebp]
  00353	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 2520 :          u[1].y[1] = tmp - 1;    // clip off corner intersection from any vertical rect

  00357	8b 45 ec	 mov	 eax, DWORD PTR _tmp$[ebp]
  0035a	83 e8 01	 sub	 eax, 1
  0035d	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00362	c1 e1 00	 shl	 ecx, 0
  00365	03 4d e4	 add	 ecx, DWORD PTR _u$[ebp]
  00368	ba 04 00 00 00	 mov	 edx, 4
  0036d	c1 e2 00	 shl	 edx, 0
  00370	89 44 11 08	 mov	 DWORD PTR [ecx+edx+8], eax
$LN12@pan_image:

; 2521 :       }
; 2522 : 
; 2523 :       // Get the blit rectangles from the screen position (screen_xpos, screen_ypos = screen upper
; 2524 :       // left corner). Screen coordinates always range from 0 to xsize and 0 to ysize inclusive here.
; 2525 :       // Refer to diagram.
; 2526 : 
; 2527 :       quad[UL].status = 0; // Default: all inactive

  00374	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  00379	6b c8 00	 imul	 ecx, eax, 0
  0037c	c7 81 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _quad[ecx], 0

; 2528 :       quad[UR].status = 0;

  00386	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  0038b	c1 e0 00	 shl	 eax, 0
  0038e	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _quad[eax], 0

; 2529 :       quad[LL].status = 0;

  00398	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  0039d	d1 e0		 shl	 eax, 1
  0039f	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _quad[eax], 0

; 2530 :       quad[LR].status = 0;

  003a9	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  003ae	6b c8 03	 imul	 ecx, eax, 3
  003b1	c7 81 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _quad[ecx], 0

; 2531 : 
; 2532 :       if (screen_xpos < xsize && screen_ypos < ysize) // Check if UL has a blit rectangle

  003bb	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_xpos
  003c0	3b 45 fc	 cmp	 eax, DWORD PTR _xsize$[ebp]
  003c3	7d 6e		 jge	 SHORT $LN13@pan_image
  003c5	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_ypos
  003ca	3b 45 f8	 cmp	 eax, DWORD PTR _ysize$[ebp]
  003cd	7d 64		 jge	 SHORT $LN13@pan_image

; 2533 :       {
; 2534 :          q = &quad[UL];

  003cf	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  003d4	6b c8 00	 imul	 ecx, eax, 0
  003d7	81 c1 00 00 00
	00		 add	 ecx, OFFSET _quad
  003dd	89 4d e8	 mov	 DWORD PTR _q$[ebp], ecx

; 2535 :          q->status = QSTAT_DO_BLIT; // need a blit

  003e0	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  003e3	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 2536 :          q->dest_xoffs = 0;         // always blits to screen upper left corner

  003e9	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  003ec	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 2537 :          q->dest_yoffs = 0;

  003f3	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  003f6	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 2538 :          q->src_xoffs = screen_xpos;

  003fd	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  00400	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_xpos
  00406	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 2539 :          q->src_yoffs = screen_ypos;

  00409	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  0040c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_ypos
  00412	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 2540 :          q->blit_xsize = xsize - screen_xpos;

  00415	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  00418	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _screen_xpos
  0041e	8b 4d e8	 mov	 ecx, DWORD PTR _q$[ebp]
  00421	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 2541 :          q->blit_ysize = ysize - screen_ypos;

  00424	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  00427	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _screen_ypos
  0042d	8b 4d e8	 mov	 ecx, DWORD PTR _q$[ebp]
  00430	89 41 34	 mov	 DWORD PTR [ecx+52], eax
$LN13@pan_image:

; 2542 :       }
; 2543 :       if (screen_xpos > 0 && screen_ypos < ysize)     // Check if UR has a blit rectangle

  00433	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _screen_xpos, 0
  0043a	7e 6d		 jle	 SHORT $LN14@pan_image
  0043c	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_ypos
  00441	3b 45 f8	 cmp	 eax, DWORD PTR _ysize$[ebp]
  00444	7d 63		 jge	 SHORT $LN14@pan_image

; 2544 :       {
; 2545 :          q = &quad[UR];

  00446	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  0044b	c1 e0 00	 shl	 eax, 0
  0044e	05 00 00 00 00	 add	 eax, OFFSET _quad
  00453	89 45 e8	 mov	 DWORD PTR _q$[ebp], eax

; 2546 :          q->status = QSTAT_DO_BLIT; // need a blit

  00456	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  00459	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 2547 :          q->dest_xoffs = xsize - screen_xpos;

  0045f	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  00462	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _screen_xpos
  00468	8b 4d e8	 mov	 ecx, DWORD PTR _q$[ebp]
  0046b	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 2548 :          q->dest_yoffs = 0;         // always blits to screen upper edge

  0046e	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  00471	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 2549 :          q->src_xoffs = 0;          // always blits from bitmap left edge

  00478	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  0047b	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 2550 :          q->src_yoffs = screen_ypos;

  00482	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  00485	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_ypos
  0048b	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 2551 :          q->blit_xsize = screen_xpos;

  0048e	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  00491	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_xpos
  00497	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 2552 :          q->blit_ysize = ysize - screen_ypos;

  0049a	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  0049d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _screen_ypos
  004a3	8b 4d e8	 mov	 ecx, DWORD PTR _q$[ebp]
  004a6	89 41 34	 mov	 DWORD PTR [ecx+52], eax
$LN14@pan_image:

; 2553 :       }
; 2554 :       if (screen_xpos < xsize && screen_ypos > 0)     // Check if LL has a blit rectangle

  004a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _screen_xpos
  004ae	3b 45 fc	 cmp	 eax, DWORD PTR _xsize$[ebp]
  004b1	7d 6b		 jge	 SHORT $LN15@pan_image
  004b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _screen_ypos, 0
  004ba	7e 62		 jle	 SHORT $LN15@pan_image

; 2555 :       {
; 2556 :          q = &quad[LL];

  004bc	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  004c1	d1 e0		 shl	 eax, 1
  004c3	05 00 00 00 00	 add	 eax, OFFSET _quad
  004c8	89 45 e8	 mov	 DWORD PTR _q$[ebp], eax

; 2557 :          q->status = QSTAT_DO_BLIT; // need a blit

  004cb	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  004ce	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 2558 :          q->dest_xoffs = 0;         // always blits to screen left edge

  004d4	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  004d7	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 2559 :          q->dest_yoffs = ysize - screen_ypos;

  004de	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  004e1	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _screen_ypos
  004e7	8b 4d e8	 mov	 ecx, DWORD PTR _q$[ebp]
  004ea	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 2560 :          q->src_xoffs = screen_xpos;

  004ed	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  004f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_xpos
  004f6	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 2561 :          q->src_yoffs = 0;          // always blits from bitmap top edge

  004f9	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  004fc	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 2562 :          q->blit_xsize = xsize - screen_xpos;

  00503	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  00506	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _screen_xpos
  0050c	8b 4d e8	 mov	 ecx, DWORD PTR _q$[ebp]
  0050f	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 2563 :          q->blit_ysize = screen_ypos;

  00512	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  00515	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_ypos
  0051b	89 48 34	 mov	 DWORD PTR [eax+52], ecx
$LN15@pan_image:

; 2564 :       }
; 2565 :       if (screen_xpos > 0 && screen_ypos > 0)         // Check if LR has a blit rectangle

  0051e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _screen_xpos, 0
  00525	7e 6d		 jle	 SHORT $LN16@pan_image
  00527	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _screen_ypos, 0
  0052e	7e 64		 jle	 SHORT $LN16@pan_image

; 2566 :       {
; 2567 :          q = &quad[LR];

  00530	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  00535	6b c8 03	 imul	 ecx, eax, 3
  00538	81 c1 00 00 00
	00		 add	 ecx, OFFSET _quad
  0053e	89 4d e8	 mov	 DWORD PTR _q$[ebp], ecx

; 2568 :          q->status = QSTAT_DO_BLIT; // need a blit

  00541	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  00544	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 2569 :          q->dest_xoffs = xsize - screen_xpos;

  0054a	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  0054d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _screen_xpos
  00553	8b 4d e8	 mov	 ecx, DWORD PTR _q$[ebp]
  00556	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 2570 :          q->dest_yoffs = ysize - screen_ypos;

  00559	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  0055c	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _screen_ypos
  00562	8b 4d e8	 mov	 ecx, DWORD PTR _q$[ebp]
  00565	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 2571 :          q->src_xoffs = 0;          // always blits from bitmap upper left corner

  00568	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  0056b	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 2572 :          q->src_yoffs = 0;

  00572	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  00575	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 2573 :          q->blit_xsize = screen_xpos;

  0057c	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  0057f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_xpos
  00585	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 2574 :          q->blit_ysize = screen_ypos;

  00588	8b 45 e8	 mov	 eax, DWORD PTR _q$[ebp]
  0058b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _screen_ypos
  00591	89 48 34	 mov	 DWORD PTR [eax+52], ecx
$LN16@pan_image:

; 2575 :       }
; 2576 : 
; 2577 :       status |= STAT_RECALC_FOR_PALETTE;

  00594	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00599	83 c8 02	 or	 eax, 2
  0059c	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 2578 : 
; 2579 :       // Calculate and palette map the new update rectangles
; 2580 :       do_man_calculate(0);

  005a1	6a 00		 push	 0
  005a3	e8 00 00 00 00	 call	 _do_man_calculate
  005a8	83 c4 04	 add	 esp, 4
$LN1@pan_image:

; 2581 :    }
; 2582 : }

  005ab	5f		 pop	 edi
  005ac	5e		 pop	 esi
  005ad	5b		 pop	 ebx
  005ae	8b e5		 mov	 esp, ebp
  005b0	5d		 pop	 ebp
  005b1	c3		 ret	 0
_pan_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _man_calculate_quadrants
_TEXT	SEGMENT
tv222 = -120						; size = 8
_m$ = -48						; size = 4
_iters_ptr$ = -44					; size = 4
_bmp_ptr$ = -40						; size = 4
_y$ = -36						; size = 4
_x$ = -32						; size = 4
_j$ = -28						; size = 4
_i$ = -24						; size = 4
_r$ = -20						; size = 20
_man_calculate_quadrants PROC				; COMDAT

; 2367 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2368 :    rectangle r;
; 2369 :    int i, j, x, y;
; 2370 :    unsigned *bmp_ptr, *iters_ptr;
; 2371 :    man_calc_struct *m;
; 2372 : 
; 2373 :    m = &main_man_calc_struct;

  00009	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 2374 : 
; 2375 :    iter_time = 0.0;

  00010	0f 57 c0	 xorps	 xmm0, xmm0
  00013	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _iter_time, xmm0

; 2376 : 
; 2377 :    // First calculate the update rectangles (up to 2).
; 2378 :    for (i = 0; i < 2; i++)

  0001b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00022	eb 09		 jmp	 SHORT $LN4@man_calcul
$LN2@man_calcul:
  00024	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00027	83 c0 01	 add	 eax, 1
  0002a	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@man_calcul:
  0002d	83 7d e8 02	 cmp	 DWORD PTR _i$[ebp], 2
  00031	0f 8d a2 00 00
	00		 jge	 $LN3@man_calcul

; 2379 :       if (update_rect[i].valid)

  00037	6b 45 e8 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0003b	83 b8 10 00 00
	00 00		 cmp	 DWORD PTR _update_rect[eax+16], 0
  00042	0f 84 8c 00 00
	00		 je	 $LN11@man_calcul

; 2380 :       {
; 2381 :          // To get position in (screen-mapped) image, subtract screen upper left coordinates,
; 2382 :          // Rectangles will be at one of the screen edges (left, right, top, or bottom).
; 2383 :          // Could simplify this: determined solely by pan offs_x and offs_y
; 2384 : 
; 2385 :          // Iterate on the update rectangles
; 2386 :          iter_time += man_calculate(m, update_rect[i].x[0] - screen_xpos,  // xstart

  00048	6b 45 e8 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0004c	b9 04 00 00 00	 mov	 ecx, 4
  00051	c1 e1 00	 shl	 ecx, 0
  00054	8b 94 08 08 00
	00 00		 mov	 edx, DWORD PTR _update_rect[eax+ecx+8]
  0005b	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _screen_ypos
  00061	52		 push	 edx
  00062	6b 45 e8 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00066	b9 04 00 00 00	 mov	 ecx, 4
  0006b	6b d1 00	 imul	 edx, ecx, 0
  0006e	8b 84 10 08 00
	00 00		 mov	 eax, DWORD PTR _update_rect[eax+edx+8]
  00075	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _screen_ypos
  0007b	50		 push	 eax
  0007c	6b 4d e8 14	 imul	 ecx, DWORD PTR _i$[ebp], 20
  00080	ba 04 00 00 00	 mov	 edx, 4
  00085	c1 e2 00	 shl	 edx, 0
  00088	8b 84 11 00 00
	00 00		 mov	 eax, DWORD PTR _update_rect[ecx+edx]
  0008f	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _screen_xpos
  00095	50		 push	 eax
  00096	6b 4d e8 14	 imul	 ecx, DWORD PTR _i$[ebp], 20
  0009a	ba 04 00 00 00	 mov	 edx, 4
  0009f	6b c2 00	 imul	 eax, edx, 0
  000a2	8b 8c 01 00 00
	00 00		 mov	 ecx, DWORD PTR _update_rect[ecx+eax]
  000a9	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _screen_xpos
  000af	51		 push	 ecx
  000b0	8b 55 d0	 mov	 edx, DWORD PTR _m$[ebp]
  000b3	52		 push	 edx
  000b4	e8 00 00 00 00	 call	 _man_calculate
  000b9	83 c4 14	 add	 esp, 20			; 00000014H
  000bc	dd 5d 88	 fstp	 QWORD PTR tv222[ebp]
  000bf	f2 0f 10 45 88	 movsd	 xmm0, QWORD PTR tv222[ebp]
  000c4	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR _iter_time
  000cc	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _iter_time, xmm0
$LN11@man_calcul:

; 2387 :                                        update_rect[i].x[1] - screen_xpos,  // xend
; 2388 :                                        update_rect[i].y[0] - screen_ypos,  // ystart
; 2389 :                                        update_rect[i].y[1] - screen_ypos); // yend
; 2390 :       }

  000d4	e9 4b ff ff ff	 jmp	 $LN2@man_calcul
$LN3@man_calcul:

; 2391 : 
; 2392 :    // Now palette-map the update rectangles into their quadrants. Each rectangle can
; 2393 :    // occupy 1-4 quadrants.
; 2394 : 
; 2395 :    for (i = 0; i < 4; i++)

  000d9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e0	eb 09		 jmp	 SHORT $LN7@man_calcul
$LN5@man_calcul:
  000e2	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000e5	83 c0 01	 add	 eax, 1
  000e8	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@man_calcul:
  000eb	83 7d e8 04	 cmp	 DWORD PTR _i$[ebp], 4
  000ef	0f 8d 5f 01 00
	00		 jge	 $LN6@man_calcul

; 2396 :       for (j = 0; j < 2; j++)

  000f5	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000fc	eb 09		 jmp	 SHORT $LN10@man_calcul
$LN8@man_calcul:
  000fe	8b 45 e4	 mov	 eax, DWORD PTR _j$[ebp]
  00101	83 c0 01	 add	 eax, 1
  00104	89 45 e4	 mov	 DWORD PTR _j$[ebp], eax
$LN10@man_calcul:
  00107	83 7d e4 02	 cmp	 DWORD PTR _j$[ebp], 2
  0010b	0f 8d 3e 01 00
	00		 jge	 $LN9@man_calcul

; 2397 :          if (update_rect[j].valid)

  00111	6b 45 e4 14	 imul	 eax, DWORD PTR _j$[ebp], 20
  00115	83 b8 10 00 00
	00 00		 cmp	 DWORD PTR _update_rect[eax+16], 0
  0011c	0f 84 28 01 00
	00		 je	 $LN13@man_calcul

; 2398 :             if (intersect_rect(&r, &quad[i].quad_rect, &update_rect[j]))

  00122	6b 45 e4 14	 imul	 eax, DWORD PTR _j$[ebp], 20
  00126	05 00 00 00 00	 add	 eax, OFFSET _update_rect
  0012b	50		 push	 eax
  0012c	6b 4d e8 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  00130	81 c1 08 00 00
	00		 add	 ecx, OFFSET _quad+8
  00136	51		 push	 ecx
  00137	8d 55 ec	 lea	 edx, DWORD PTR _r$[ebp]
  0013a	52		 push	 edx
  0013b	e8 00 00 00 00	 call	 _intersect_rect
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH
  00143	85 c0		 test	 eax, eax
  00145	0f 84 ff 00 00
	00		 je	 $LN13@man_calcul

; 2399 :             {
; 2400 :                // Subtract upper left coordinates of this quadrant from upper left
; 2401 :                // coords of intersection rect to get the x, y offset of the
; 2402 :                // bitmap data in this quadrant
; 2403 : 
; 2404 :                x = r.x[0] - quad[i].quad_rect.x[0];

  0014b	b8 04 00 00 00	 mov	 eax, 4
  00150	6b c8 00	 imul	 ecx, eax, 0
  00153	6b 55 e8 38	 imul	 edx, DWORD PTR _i$[ebp], 56
  00157	b8 04 00 00 00	 mov	 eax, 4
  0015c	6b c0 00	 imul	 eax, eax, 0
  0015f	8b 4c 0d ec	 mov	 ecx, DWORD PTR _r$[ebp+ecx]
  00163	2b 8c 02 08 00
	00 00		 sub	 ecx, DWORD PTR _quad[edx+eax+8]
  0016a	89 4d e0	 mov	 DWORD PTR _x$[ebp], ecx

; 2405 :                y = r.y[0] - quad[i].quad_rect.y[0];

  0016d	b8 04 00 00 00	 mov	 eax, 4
  00172	6b c8 00	 imul	 ecx, eax, 0
  00175	6b 55 e8 38	 imul	 edx, DWORD PTR _i$[ebp], 56
  00179	b8 04 00 00 00	 mov	 eax, 4
  0017e	6b c0 00	 imul	 eax, eax, 0
  00181	8b 4c 0d f4	 mov	 ecx, DWORD PTR _r$[ebp+ecx+8]
  00185	2b 8c 02 10 00
	00 00		 sub	 ecx, DWORD PTR _quad[edx+eax+16]
  0018c	89 4d dc	 mov	 DWORD PTR _y$[ebp], ecx

; 2406 :                bmp_ptr = quad[i].bitmap_data + y * m->xsize + x; // get pointer to bitmap data

  0018f	6b 45 e8 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  00193	8b 4d d0	 mov	 ecx, DWORD PTR _m$[ebp]
  00196	8b 55 dc	 mov	 edx, DWORD PTR _y$[ebp]
  00199	0f af 91 88 8d
	00 00		 imul	 edx, DWORD PTR [ecx+36232]
  001a0	8b 80 1c 00 00
	00		 mov	 eax, DWORD PTR _quad[eax+28]
  001a6	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  001a9	8b 55 e0	 mov	 edx, DWORD PTR _x$[ebp]
  001ac	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  001af	89 45 d8	 mov	 DWORD PTR _bmp_ptr$[ebp], eax

; 2407 : 
; 2408 :                // Subtract upper left coords of screen pos from upper left coords
; 2409 :                // of intersection rect to get iter data offset
; 2410 : 
; 2411 :                x = r.x[0] - screen_xpos;

  001b2	b8 04 00 00 00	 mov	 eax, 4
  001b7	6b c8 00	 imul	 ecx, eax, 0
  001ba	8b 54 0d ec	 mov	 edx, DWORD PTR _r$[ebp+ecx]
  001be	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _screen_xpos
  001c4	89 55 e0	 mov	 DWORD PTR _x$[ebp], edx

; 2412 :                y = r.y[0] - screen_ypos;

  001c7	b8 04 00 00 00	 mov	 eax, 4
  001cc	6b c8 00	 imul	 ecx, eax, 0
  001cf	8b 54 0d f4	 mov	 edx, DWORD PTR _r$[ebp+ecx+8]
  001d3	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _screen_ypos
  001d9	89 55 dc	 mov	 DWORD PTR _y$[ebp], edx

; 2413 :                iters_ptr = m->iter_data + y * m->iter_data_line_size + x; // get pointer to iter data to be mapped

  001dc	8b 45 d0	 mov	 eax, DWORD PTR _m$[ebp]
  001df	8b 4d dc	 mov	 ecx, DWORD PTR _y$[ebp]
  001e2	0f af 88 e4 8d
	00 00		 imul	 ecx, DWORD PTR [eax+36324]
  001e9	8b 55 d0	 mov	 edx, DWORD PTR _m$[ebp]
  001ec	8b 82 e0 8d 00
	00		 mov	 eax, DWORD PTR [edx+36320]
  001f2	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  001f5	8b 55 e0	 mov	 edx, DWORD PTR _x$[ebp]
  001f8	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  001fb	89 45 d4	 mov	 DWORD PTR _iters_ptr$[ebp], eax

; 2414 : 
; 2415 :                // Xsize, ysize = rectangle edge lengths
; 2416 :                apply_palette(m, bmp_ptr, iters_ptr, r.x[1] - r.x[0] + 1, r.y[1] - r.y[0] + 1);

  001fe	b8 04 00 00 00	 mov	 eax, 4
  00203	c1 e0 00	 shl	 eax, 0
  00206	b9 04 00 00 00	 mov	 ecx, 4
  0020b	6b d1 00	 imul	 edx, ecx, 0
  0020e	8b 44 05 f4	 mov	 eax, DWORD PTR _r$[ebp+eax+8]
  00212	2b 44 15 f4	 sub	 eax, DWORD PTR _r$[ebp+edx+8]
  00216	83 c0 01	 add	 eax, 1
  00219	50		 push	 eax
  0021a	b9 04 00 00 00	 mov	 ecx, 4
  0021f	c1 e1 00	 shl	 ecx, 0
  00222	ba 04 00 00 00	 mov	 edx, 4
  00227	6b c2 00	 imul	 eax, edx, 0
  0022a	8b 4c 0d ec	 mov	 ecx, DWORD PTR _r$[ebp+ecx]
  0022e	2b 4c 05 ec	 sub	 ecx, DWORD PTR _r$[ebp+eax]
  00232	83 c1 01	 add	 ecx, 1
  00235	51		 push	 ecx
  00236	8b 55 d4	 mov	 edx, DWORD PTR _iters_ptr$[ebp]
  00239	52		 push	 edx
  0023a	8b 45 d8	 mov	 eax, DWORD PTR _bmp_ptr$[ebp]
  0023d	50		 push	 eax
  0023e	8b 4d d0	 mov	 ecx, DWORD PTR _m$[ebp]
  00241	51		 push	 ecx
  00242	e8 00 00 00 00	 call	 _apply_palette
  00247	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@man_calcul:

; 2417 :             }

  0024a	e9 af fe ff ff	 jmp	 $LN8@man_calcul
$LN9@man_calcul:

; 2418 : }

  0024f	e9 8e fe ff ff	 jmp	 $LN5@man_calcul
$LN6@man_calcul:
  00254	5f		 pop	 edi
  00255	5e		 pop	 esi
  00256	5b		 pop	 ebx
  00257	8b e5		 mov	 esp, ebp
  00259	5d		 pop	 ebp
  0025a	c3		 ret	 0
_man_calculate_quadrants ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _intersect_rect
_TEXT	SEGMENT
tv191 = -68						; size = 4
tv174 = -68						; size = 4
tv157 = -68						; size = 4
tv140 = -68						; size = 4
_rdest$ = 8						; size = 4
_r1$ = 12						; size = 4
_r2$ = 16						; size = 4
_intersect_rect PROC					; COMDAT

; 2350 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2351 :    // Check if one lies outside the bounds of the other; return 0 if so
; 2352 :    if (r1->x[0] > r2->x[1] || r1->x[1] < r2->x[0] ||
; 2353 :        r1->y[0] > r2->y[1] || r1->y[1] < r2->y[0])

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	6b c8 00	 imul	 ecx, eax, 0
  00011	ba 04 00 00 00	 mov	 edx, 4
  00016	c1 e2 00	 shl	 edx, 0
  00019	8b 45 0c	 mov	 eax, DWORD PTR _r1$[ebp]
  0001c	8b 75 10	 mov	 esi, DWORD PTR _r2$[ebp]
  0001f	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00022	3b 0c 16	 cmp	 ecx, DWORD PTR [esi+edx]
  00025	7f 5e		 jg	 SHORT $LN3@intersect_
  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	c1 e0 00	 shl	 eax, 0
  0002f	b9 04 00 00 00	 mov	 ecx, 4
  00034	6b d1 00	 imul	 edx, ecx, 0
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _r1$[ebp]
  0003a	8b 75 10	 mov	 esi, DWORD PTR _r2$[ebp]
  0003d	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00040	3b 04 16	 cmp	 eax, DWORD PTR [esi+edx]
  00043	7c 40		 jl	 SHORT $LN3@intersect_
  00045	b8 04 00 00 00	 mov	 eax, 4
  0004a	6b c8 00	 imul	 ecx, eax, 0
  0004d	ba 04 00 00 00	 mov	 edx, 4
  00052	c1 e2 00	 shl	 edx, 0
  00055	8b 45 0c	 mov	 eax, DWORD PTR _r1$[ebp]
  00058	8b 75 10	 mov	 esi, DWORD PTR _r2$[ebp]
  0005b	8b 4c 08 08	 mov	 ecx, DWORD PTR [eax+ecx+8]
  0005f	3b 4c 16 08	 cmp	 ecx, DWORD PTR [esi+edx+8]
  00063	7f 20		 jg	 SHORT $LN3@intersect_
  00065	b8 04 00 00 00	 mov	 eax, 4
  0006a	c1 e0 00	 shl	 eax, 0
  0006d	b9 04 00 00 00	 mov	 ecx, 4
  00072	6b d1 00	 imul	 edx, ecx, 0
  00075	8b 4d 0c	 mov	 ecx, DWORD PTR _r1$[ebp]
  00078	8b 75 10	 mov	 esi, DWORD PTR _r2$[ebp]
  0007b	8b 44 01 08	 mov	 eax, DWORD PTR [ecx+eax+8]
  0007f	3b 44 16 08	 cmp	 eax, DWORD PTR [esi+edx+8]
  00083	7d 07		 jge	 SHORT $LN2@intersect_
$LN3@intersect_:

; 2354 :       return 0;

  00085	33 c0		 xor	 eax, eax
  00087	e9 5b 01 00 00	 jmp	 $LN1@intersect_
$LN2@intersect_:

; 2355 : 
; 2356 :    // Get max/min coordinates to get intersection
; 2357 :    rdest->x[0] = r1->x[0] > r2->x[0] ? r1->x[0] : r2->x[0];

  0008c	b8 04 00 00 00	 mov	 eax, 4
  00091	6b c8 00	 imul	 ecx, eax, 0
  00094	ba 04 00 00 00	 mov	 edx, 4
  00099	6b c2 00	 imul	 eax, edx, 0
  0009c	8b 55 0c	 mov	 edx, DWORD PTR _r1$[ebp]
  0009f	8b 75 10	 mov	 esi, DWORD PTR _r2$[ebp]
  000a2	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  000a5	3b 0c 06	 cmp	 ecx, DWORD PTR [esi+eax]
  000a8	7e 13		 jle	 SHORT $LN5@intersect_
  000aa	ba 04 00 00 00	 mov	 edx, 4
  000af	6b c2 00	 imul	 eax, edx, 0
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _r1$[ebp]
  000b5	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000b8	89 55 bc	 mov	 DWORD PTR tv140[ebp], edx
  000bb	eb 11		 jmp	 SHORT $LN6@intersect_
$LN5@intersect_:
  000bd	b8 04 00 00 00	 mov	 eax, 4
  000c2	6b c8 00	 imul	 ecx, eax, 0
  000c5	8b 55 10	 mov	 edx, DWORD PTR _r2$[ebp]
  000c8	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  000cb	89 45 bc	 mov	 DWORD PTR tv140[ebp], eax
$LN6@intersect_:
  000ce	b9 04 00 00 00	 mov	 ecx, 4
  000d3	6b d1 00	 imul	 edx, ecx, 0
  000d6	8b 45 08	 mov	 eax, DWORD PTR _rdest$[ebp]
  000d9	8b 4d bc	 mov	 ecx, DWORD PTR tv140[ebp]
  000dc	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 2358 :    rdest->x[1] = r1->x[1] < r2->x[1] ? r1->x[1] : r2->x[1];

  000df	b8 04 00 00 00	 mov	 eax, 4
  000e4	c1 e0 00	 shl	 eax, 0
  000e7	b9 04 00 00 00	 mov	 ecx, 4
  000ec	c1 e1 00	 shl	 ecx, 0
  000ef	8b 55 0c	 mov	 edx, DWORD PTR _r1$[ebp]
  000f2	8b 75 10	 mov	 esi, DWORD PTR _r2$[ebp]
  000f5	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000f8	3b 04 0e	 cmp	 eax, DWORD PTR [esi+ecx]
  000fb	7d 13		 jge	 SHORT $LN7@intersect_
  000fd	b9 04 00 00 00	 mov	 ecx, 4
  00102	c1 e1 00	 shl	 ecx, 0
  00105	8b 55 0c	 mov	 edx, DWORD PTR _r1$[ebp]
  00108	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0010b	89 45 bc	 mov	 DWORD PTR tv157[ebp], eax
  0010e	eb 11		 jmp	 SHORT $LN8@intersect_
$LN7@intersect_:
  00110	b9 04 00 00 00	 mov	 ecx, 4
  00115	c1 e1 00	 shl	 ecx, 0
  00118	8b 55 10	 mov	 edx, DWORD PTR _r2$[ebp]
  0011b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0011e	89 45 bc	 mov	 DWORD PTR tv157[ebp], eax
$LN8@intersect_:
  00121	b9 04 00 00 00	 mov	 ecx, 4
  00126	c1 e1 00	 shl	 ecx, 0
  00129	8b 55 08	 mov	 edx, DWORD PTR _rdest$[ebp]
  0012c	8b 45 bc	 mov	 eax, DWORD PTR tv157[ebp]
  0012f	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 2359 :    rdest->y[0] = r1->y[0] > r2->y[0] ? r1->y[0] : r2->y[0];

  00132	b8 04 00 00 00	 mov	 eax, 4
  00137	6b c8 00	 imul	 ecx, eax, 0
  0013a	ba 04 00 00 00	 mov	 edx, 4
  0013f	6b c2 00	 imul	 eax, edx, 0
  00142	8b 55 0c	 mov	 edx, DWORD PTR _r1$[ebp]
  00145	8b 75 10	 mov	 esi, DWORD PTR _r2$[ebp]
  00148	8b 4c 0a 08	 mov	 ecx, DWORD PTR [edx+ecx+8]
  0014c	3b 4c 06 08	 cmp	 ecx, DWORD PTR [esi+eax+8]
  00150	7e 14		 jle	 SHORT $LN9@intersect_
  00152	ba 04 00 00 00	 mov	 edx, 4
  00157	6b c2 00	 imul	 eax, edx, 0
  0015a	8b 4d 0c	 mov	 ecx, DWORD PTR _r1$[ebp]
  0015d	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00161	89 55 bc	 mov	 DWORD PTR tv174[ebp], edx
  00164	eb 12		 jmp	 SHORT $LN10@intersect_
$LN9@intersect_:
  00166	b8 04 00 00 00	 mov	 eax, 4
  0016b	6b c8 00	 imul	 ecx, eax, 0
  0016e	8b 55 10	 mov	 edx, DWORD PTR _r2$[ebp]
  00171	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  00175	89 45 bc	 mov	 DWORD PTR tv174[ebp], eax
$LN10@intersect_:
  00178	b9 04 00 00 00	 mov	 ecx, 4
  0017d	6b d1 00	 imul	 edx, ecx, 0
  00180	8b 45 08	 mov	 eax, DWORD PTR _rdest$[ebp]
  00183	8b 4d bc	 mov	 ecx, DWORD PTR tv174[ebp]
  00186	89 4c 10 08	 mov	 DWORD PTR [eax+edx+8], ecx

; 2360 :    rdest->y[1] = r1->y[1] < r2->y[1] ? r1->y[1] : r2->y[1];

  0018a	b8 04 00 00 00	 mov	 eax, 4
  0018f	c1 e0 00	 shl	 eax, 0
  00192	b9 04 00 00 00	 mov	 ecx, 4
  00197	c1 e1 00	 shl	 ecx, 0
  0019a	8b 55 0c	 mov	 edx, DWORD PTR _r1$[ebp]
  0019d	8b 75 10	 mov	 esi, DWORD PTR _r2$[ebp]
  001a0	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  001a4	3b 44 0e 08	 cmp	 eax, DWORD PTR [esi+ecx+8]
  001a8	7d 14		 jge	 SHORT $LN11@intersect_
  001aa	b9 04 00 00 00	 mov	 ecx, 4
  001af	c1 e1 00	 shl	 ecx, 0
  001b2	8b 55 0c	 mov	 edx, DWORD PTR _r1$[ebp]
  001b5	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  001b9	89 45 bc	 mov	 DWORD PTR tv191[ebp], eax
  001bc	eb 12		 jmp	 SHORT $LN12@intersect_
$LN11@intersect_:
  001be	b9 04 00 00 00	 mov	 ecx, 4
  001c3	c1 e1 00	 shl	 ecx, 0
  001c6	8b 55 10	 mov	 edx, DWORD PTR _r2$[ebp]
  001c9	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  001cd	89 45 bc	 mov	 DWORD PTR tv191[ebp], eax
$LN12@intersect_:
  001d0	b9 04 00 00 00	 mov	 ecx, 4
  001d5	c1 e1 00	 shl	 ecx, 0
  001d8	8b 55 08	 mov	 edx, DWORD PTR _rdest$[ebp]
  001db	8b 45 bc	 mov	 eax, DWORD PTR tv191[ebp]
  001de	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 2361 :    return 1;

  001e2	b8 01 00 00 00	 mov	 eax, 1
$LN1@intersect_:

; 2362 : }

  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx
  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c3		 ret	 0
_intersect_rect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _reset_quadrants
_TEXT	SEGMENT
_m$ = -16						; size = 4
_q$ = -12						; size = 4
_ysize$ = -8						; size = 4
_xsize$ = -4						; size = 4
_reset_quadrants PROC					; COMDAT

; 2290 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2291 :    int xsize, ysize;
; 2292 :    quadrant *q;
; 2293 :    man_calc_struct *m;
; 2294 : 
; 2295 :    m = &main_man_calc_struct;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 2296 : 
; 2297 :    xsize = m->xsize;

  00010	8b 45 f0	 mov	 eax, DWORD PTR _m$[ebp]
  00013	8b 88 88 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36232]
  00019	89 4d fc	 mov	 DWORD PTR _xsize$[ebp], ecx

; 2298 :    ysize = m->ysize;

  0001c	8b 45 f0	 mov	 eax, DWORD PTR _m$[ebp]
  0001f	8b 88 8c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36236]
  00025	89 4d f8	 mov	 DWORD PTR _ysize$[ebp], ecx

; 2299 : 
; 2300 :    q = &quad[UL];                         // upper left

  00028	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	81 c1 00 00 00
	00		 add	 ecx, OFFSET _quad
  00036	89 4d f4	 mov	 DWORD PTR _q$[ebp], ecx

; 2301 :    q->status = QSTAT_DO_BLIT;             // needs blit

  00039	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  0003c	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 2302 :    q->src_xoffs = 0;                      // src and dest offsets all 0

  00042	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  00045	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 2303 :    q->src_yoffs = 0;

  0004c	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  0004f	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 2304 :    q->dest_xoffs = 0;

  00056	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  00059	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 2305 :    q->dest_yoffs = 0;

  00060	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  00063	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 2306 :    q->blit_xsize = xsize;                 // blit sizes = screen size

  0006a	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _xsize$[ebp]
  00070	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 2307 :    q->blit_ysize = ysize;

  00073	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  00076	8b 4d f8	 mov	 ecx, DWORD PTR _ysize$[ebp]
  00079	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 2308 :    q->quad_rect.x[0] = 0;                 // rectangle coordinates

  0007c	b8 04 00 00 00	 mov	 eax, 4
  00081	6b c8 00	 imul	 ecx, eax, 0
  00084	8b 55 f4	 mov	 edx, DWORD PTR _q$[ebp]
  00087	c7 44 0a 08 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+8], 0

; 2309 :    q->quad_rect.y[0] = 0;

  0008f	b8 04 00 00 00	 mov	 eax, 4
  00094	6b c8 00	 imul	 ecx, eax, 0
  00097	8b 55 f4	 mov	 edx, DWORD PTR _q$[ebp]
  0009a	c7 44 0a 10 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+16], 0

; 2310 :    q->quad_rect.x[1] = xsize - 1;

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  000a5	83 e8 01	 sub	 eax, 1
  000a8	b9 04 00 00 00	 mov	 ecx, 4
  000ad	c1 e1 00	 shl	 ecx, 0
  000b0	8b 55 f4	 mov	 edx, DWORD PTR _q$[ebp]
  000b3	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 2311 :    q->quad_rect.y[1] = ysize - 1;

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  000ba	83 e8 01	 sub	 eax, 1
  000bd	b9 04 00 00 00	 mov	 ecx, 4
  000c2	c1 e1 00	 shl	 ecx, 0
  000c5	8b 55 f4	 mov	 edx, DWORD PTR _q$[ebp]
  000c8	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 2312 : 
; 2313 :    q = &quad[UR];                         // upper right

  000cc	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  000d1	c1 e0 00	 shl	 eax, 0
  000d4	05 00 00 00 00	 add	 eax, OFFSET _quad
  000d9	89 45 f4	 mov	 DWORD PTR _q$[ebp], eax

; 2314 :    q->status = 0;                         // inactive

  000dc	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  000df	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2315 :    q->quad_rect.x[0] = xsize;             // rectangle coordinates

  000e5	b8 04 00 00 00	 mov	 eax, 4
  000ea	6b c8 00	 imul	 ecx, eax, 0
  000ed	8b 55 f4	 mov	 edx, DWORD PTR _q$[ebp]
  000f0	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  000f3	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 2316 :    q->quad_rect.y[0] = 0;

  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 55 f4	 mov	 edx, DWORD PTR _q$[ebp]
  00102	c7 44 0a 10 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+16], 0

; 2317 :    q->quad_rect.x[1] = (xsize << 1) - 1;

  0010a	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  0010d	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  00111	ba 04 00 00 00	 mov	 edx, 4
  00116	c1 e2 00	 shl	 edx, 0
  00119	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  0011c	89 4c 10 08	 mov	 DWORD PTR [eax+edx+8], ecx

; 2318 :    q->quad_rect.y[1] = ysize - 1;

  00120	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  00123	83 e8 01	 sub	 eax, 1
  00126	b9 04 00 00 00	 mov	 ecx, 4
  0012b	c1 e1 00	 shl	 ecx, 0
  0012e	8b 55 f4	 mov	 edx, DWORD PTR _q$[ebp]
  00131	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 2319 : 
; 2320 :    q = &quad[LL];                         // lower left

  00135	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  0013a	d1 e0		 shl	 eax, 1
  0013c	05 00 00 00 00	 add	 eax, OFFSET _quad
  00141	89 45 f4	 mov	 DWORD PTR _q$[ebp], eax

; 2321 :    q->status = 0;                         // inactive

  00144	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  00147	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2322 :    q->quad_rect.x[0] = 0;                 // rectangle coordinates

  0014d	b8 04 00 00 00	 mov	 eax, 4
  00152	6b c8 00	 imul	 ecx, eax, 0
  00155	8b 55 f4	 mov	 edx, DWORD PTR _q$[ebp]
  00158	c7 44 0a 08 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+8], 0

; 2323 :    q->quad_rect.y[0] = ysize;

  00160	b8 04 00 00 00	 mov	 eax, 4
  00165	6b c8 00	 imul	 ecx, eax, 0
  00168	8b 55 f4	 mov	 edx, DWORD PTR _q$[ebp]
  0016b	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  0016e	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 2324 :    q->quad_rect.x[1] = xsize - 1;

  00172	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  00175	83 e8 01	 sub	 eax, 1
  00178	b9 04 00 00 00	 mov	 ecx, 4
  0017d	c1 e1 00	 shl	 ecx, 0
  00180	8b 55 f4	 mov	 edx, DWORD PTR _q$[ebp]
  00183	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 2325 :    q->quad_rect.y[1] = (ysize << 1) - 1;

  00187	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  0018a	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  0018e	ba 04 00 00 00	 mov	 edx, 4
  00193	c1 e2 00	 shl	 edx, 0
  00196	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  00199	89 4c 10 10	 mov	 DWORD PTR [eax+edx+16], ecx

; 2326 : 
; 2327 :    q = &quad[LR];                         // lower right

  0019d	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  001a2	6b c8 03	 imul	 ecx, eax, 3
  001a5	81 c1 00 00 00
	00		 add	 ecx, OFFSET _quad
  001ab	89 4d f4	 mov	 DWORD PTR _q$[ebp], ecx

; 2328 :    q->status = 0;                         // inactive

  001ae	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  001b1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2329 :    q->quad_rect.x[0] = xsize;             // rectangle coordinates

  001b7	b8 04 00 00 00	 mov	 eax, 4
  001bc	6b c8 00	 imul	 ecx, eax, 0
  001bf	8b 55 f4	 mov	 edx, DWORD PTR _q$[ebp]
  001c2	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  001c5	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 2330 :    q->quad_rect.y[0] = ysize;

  001c9	b8 04 00 00 00	 mov	 eax, 4
  001ce	6b c8 00	 imul	 ecx, eax, 0
  001d1	8b 55 f4	 mov	 edx, DWORD PTR _q$[ebp]
  001d4	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  001d7	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 2331 :    q->quad_rect.x[1] = (xsize << 1) - 1;

  001db	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  001de	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  001e2	ba 04 00 00 00	 mov	 edx, 4
  001e7	c1 e2 00	 shl	 edx, 0
  001ea	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  001ed	89 4c 10 08	 mov	 DWORD PTR [eax+edx+8], ecx

; 2332 :    q->quad_rect.y[1] = (ysize << 1) - 1;

  001f1	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  001f4	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  001f8	ba 04 00 00 00	 mov	 edx, 4
  001fd	c1 e2 00	 shl	 edx, 0
  00200	8b 45 f4	 mov	 eax, DWORD PTR _q$[ebp]
  00203	89 4c 10 10	 mov	 DWORD PTR [eax+edx+16], ecx

; 2333 : 
; 2334 :    // Update rectangles
; 2335 :    update_rect[0].valid = 1;              // 1st update rect valid; equals whole quadrant

  00207	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0020c	6b c8 00	 imul	 ecx, eax, 0
  0020f	c7 81 10 00 00
	00 01 00 00 00	 mov	 DWORD PTR _update_rect[ecx+16], 1

; 2336 :    update_rect[0].x[0] = 0;

  00219	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0021e	6b c8 00	 imul	 ecx, eax, 0
  00221	ba 04 00 00 00	 mov	 edx, 4
  00226	6b c2 00	 imul	 eax, edx, 0
  00229	c7 84 01 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _update_rect[ecx+eax], 0

; 2337 :    update_rect[0].x[1] = xsize - 1;

  00234	8b 45 fc	 mov	 eax, DWORD PTR _xsize$[ebp]
  00237	83 e8 01	 sub	 eax, 1
  0023a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0023f	6b d1 00	 imul	 edx, ecx, 0
  00242	b9 04 00 00 00	 mov	 ecx, 4
  00247	c1 e1 00	 shl	 ecx, 0
  0024a	89 84 0a 00 00
	00 00		 mov	 DWORD PTR _update_rect[edx+ecx], eax

; 2338 :    update_rect[0].y[0] = 0;

  00251	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00256	6b c8 00	 imul	 ecx, eax, 0
  00259	ba 04 00 00 00	 mov	 edx, 4
  0025e	6b c2 00	 imul	 eax, edx, 0
  00261	c7 84 01 08 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _update_rect[ecx+eax+8], 0

; 2339 :    update_rect[0].y[1] = ysize - 1;

  0026c	8b 45 f8	 mov	 eax, DWORD PTR _ysize$[ebp]
  0026f	83 e8 01	 sub	 eax, 1
  00272	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00277	6b d1 00	 imul	 edx, ecx, 0
  0027a	b9 04 00 00 00	 mov	 ecx, 4
  0027f	c1 e1 00	 shl	 ecx, 0
  00282	89 84 0a 08 00
	00 00		 mov	 DWORD PTR _update_rect[edx+ecx+8], eax

; 2340 :    update_rect[1].valid = 0;              // 2nd update rect invalid

  00289	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0028e	c1 e0 00	 shl	 eax, 0
  00291	c7 80 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _update_rect[eax+16], 0

; 2341 : 
; 2342 :    screen_xpos = 0;                       // reset screen window to cover UL quadrant only

  0029b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _screen_xpos, 0

; 2343 :    screen_ypos = 0;

  002a5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _screen_ypos, 0

; 2344 : }

  002af	5f		 pop	 edi
  002b0	5e		 pop	 esi
  002b1	5b		 pop	 ebx
  002b2	8b e5		 mov	 esp, ebp
  002b4	5d		 pop	 ebp
  002b5	c3		 ret	 0
_reset_quadrants ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _swap_quadrants
_TEXT	SEGMENT
_tmp_handle$ = -8					; size = 4
_tmp_data$ = -4						; size = 4
_q1$ = 8						; size = 4
_q2$ = 12						; size = 4
_swap_quadrants PROC					; COMDAT

; 2270 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2271 :    unsigned *tmp_data;
; 2272 :    HBITMAP tmp_handle;
; 2273 : 
; 2274 :    tmp_data = q1->bitmap_data;

  00009	8b 45 08	 mov	 eax, DWORD PTR _q1$[ebp]
  0000c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000f	89 4d fc	 mov	 DWORD PTR _tmp_data$[ebp], ecx

; 2275 :    tmp_handle = q1->handle;

  00012	8b 45 08	 mov	 eax, DWORD PTR _q1$[ebp]
  00015	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00018	89 4d f8	 mov	 DWORD PTR _tmp_handle$[ebp], ecx

; 2276 : 
; 2277 :    q1->bitmap_data = q2->bitmap_data;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _q1$[ebp]
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _q2$[ebp]
  00021	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00024	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 2278 :    q1->handle = q2->handle;

  00027	8b 45 08	 mov	 eax, DWORD PTR _q1$[ebp]
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _q2$[ebp]
  0002d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00030	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2279 : 
; 2280 :    q2->bitmap_data = tmp_data;

  00033	8b 45 0c	 mov	 eax, DWORD PTR _q2$[ebp]
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _tmp_data$[ebp]
  00039	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 2281 :    q2->handle = tmp_handle;

  0003c	8b 45 0c	 mov	 eax, DWORD PTR _q2$[ebp]
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _tmp_handle$[ebp]
  00042	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 2282 : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_swap_quadrants ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _man_calculate
_TEXT	SEGMENT
_s$ = -56						; size = 4
_this_step$ = -52					; size = 4
_frac_step$ = -48					; size = 4
_frac$ = -44						; size = 4
_num_stripes$ = -40					; size = 4
_stripe_ind$ = -36					; size = 4
_thread_ind$ = -32					; size = 4
_step$ = -28						; size = 4
_ysize$ = -24						; size = 4
_xsize$ = -20						; size = 4
_i$ = -16						; size = 4
_iteration_time$ = -12					; size = 8
_start_time$ = -4					; size = 4
_m$ = 8							; size = 4
_xstart$ = 12						; size = 4
_xend$ = 16						; size = 4
_ystart$ = 20						; size = 4
_yend$ = 24						; size = 4
_man_calculate PROC					; COMDAT

; 2089 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2090 :    TIME_UNIT start_time;
; 2091 :    double iteration_time;
; 2092 :    int i, xsize, ysize, step, thread_ind, stripe_ind, num_stripes, frac, frac_step, this_step;
; 2093 :    stripe *s;
; 2094 : 
; 2095 :    all_recalculated = 0;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _all_recalculated, 0

; 2096 :    if (status & STAT_NEED_RECALC) // if need recalculation, recalculate all. No effect for saving

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  00018	83 e0 01	 and	 eax, 1
  0001b	74 43		 je	 SHORT $LN14@man_calcul

; 2097 :    {
; 2098 :       xstart = 0;                 // reset rectangle to full screen

  0001d	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _xstart$[ebp], 0

; 2099 :       xend = m->xsize - 1;

  00024	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00027	8b 88 88 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36232]
  0002d	83 e9 01	 sub	 ecx, 1
  00030	89 4d 10	 mov	 DWORD PTR _xend$[ebp], ecx

; 2100 :       ystart = 0;

  00033	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _ystart$[ebp], 0

; 2101 :       yend = m->ysize - 1;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0003d	8b 88 8c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36236]
  00043	83 e9 01	 sub	 ecx, 1
  00046	89 4d 18	 mov	 DWORD PTR _yend$[ebp], ecx

; 2102 :       status &= ~STAT_NEED_RECALC;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  0004e	83 e0 fe	 and	 eax, -2			; fffffffeH
  00051	a3 00 00 00 00	 mov	 DWORD PTR _status, eax

; 2103 :       all_recalculated = 1;

  00056	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _all_recalculated, 1
$LN14@man_calcul:

; 2104 :    }
; 2105 : 
; 2106 :    man_setup(m, xstart, xend, ystart, yend);

  00060	8b 45 18	 mov	 eax, DWORD PTR _yend$[ebp]
  00063	50		 push	 eax
  00064	8b 4d 14	 mov	 ecx, DWORD PTR _ystart$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 10	 mov	 edx, DWORD PTR _xend$[ebp]
  0006b	52		 push	 edx
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _xstart$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 _man_setup
  00079	83 c4 14	 add	 esp, 20			; 00000014H

; 2107 : 
; 2108 :    xsize = xend - xstart + 1;

  0007c	8b 45 10	 mov	 eax, DWORD PTR _xend$[ebp]
  0007f	2b 45 0c	 sub	 eax, DWORD PTR _xstart$[ebp]
  00082	83 c0 01	 add	 eax, 1
  00085	89 45 ec	 mov	 DWORD PTR _xsize$[ebp], eax

; 2109 :    ysize = yend - ystart + 1;

  00088	8b 45 18	 mov	 eax, DWORD PTR _yend$[ebp]
  0008b	2b 45 14	 sub	 eax, DWORD PTR _ystart$[ebp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 45 e8	 mov	 DWORD PTR _ysize$[ebp], eax

; 2110 : 
; 2111 :    // Get the number of stripes per thread based on number of threads (extract bits 3-0
; 2112 :    // for 1 thread, 7-4 for two threads, etc).
; 2113 :    num_stripes = (cfg_settings.stripes_per_thread.val >> (num_threads_ind << 2)) & 0xF;

  00094	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _num_threads_ind
  0009a	c1 e1 02	 shl	 ecx, 2
  0009d	a1 b8 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+184
  000a2	d3 f8		 sar	 eax, cl
  000a4	83 e0 0f	 and	 eax, 15			; 0000000fH
  000a7	89 45 d8	 mov	 DWORD PTR _num_stripes$[ebp], eax

; 2114 : 
; 2115 :    // Need to check min/max here (couldn't be checked automatically by log-reading function)
; 2116 :    if (num_stripes < 1)

  000aa	83 7d d8 01	 cmp	 DWORD PTR _num_stripes$[ebp], 1
  000ae	7d 07		 jge	 SHORT $LN15@man_calcul

; 2117 :       num_stripes = 1;

  000b0	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _num_stripes$[ebp], 1
$LN15@man_calcul:

; 2118 :    if (num_stripes > MAX_STRIPES)

  000b7	83 7d d8 08	 cmp	 DWORD PTR _num_stripes$[ebp], 8
  000bb	7e 07		 jle	 SHORT $LN16@man_calcul

; 2119 :       num_stripes = MAX_STRIPES;

  000bd	c7 45 d8 08 00
	00 00		 mov	 DWORD PTR _num_stripes$[ebp], 8
$LN16@man_calcul:

; 2120 : 
; 2121 :    // Now multiply by num_threads to get total number of stripes for the image.
; 2122 :    num_stripes <<= num_threads_ind;

  000c4	8b 45 d8	 mov	 eax, DWORD PTR _num_stripes$[ebp]
  000c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _num_threads_ind
  000cd	d3 e0		 shl	 eax, cl
  000cf	89 45 d8	 mov	 DWORD PTR _num_stripes$[ebp], eax

; 2123 : 
; 2124 :    // With pathologically small images, some threads may not calculate anything.
; 2125 :    for (i = 0; i < num_threads; i++)

  000d2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000d9	eb 09		 jmp	 SHORT $LN4@man_calcul
$LN2@man_calcul:
  000db	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000de	83 c0 01	 add	 eax, 1
  000e1	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@man_calcul:
  000e4	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000e7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _num_threads
  000ed	7d 17		 jge	 SHORT $LN3@man_calcul

; 2126 :       m->thread_states[i].num_stripes = 0;

  000ef	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 168
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  000f9	c7 84 01 90 78
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+30864], 0
  00104	eb d5		 jmp	 SHORT $LN2@man_calcul
$LN3@man_calcul:

; 2127 : 
; 2128 :    // Start at the last thread, so that thread 0 gets any leftovers at the end. Thread 0 is
; 2129 :    // the master and doesn't suffer the overhead of being spawned, so it should get the extra work.
; 2130 : 
; 2131 :    thread_ind = num_threads - 1;

  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_threads
  0010b	83 e8 01	 sub	 eax, 1
  0010e	89 45 e0	 mov	 DWORD PTR _thread_ind$[ebp], eax

; 2132 :    stripe_ind = 0;

  00111	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _stripe_ind$[ebp], 0

; 2133 : 
; 2134 :    // Divide along the y axis if stripe height is >= 8 (see above), or ysize is >= xsize
; 2135 : 
; 2136 :    if ((ysize >= (num_stripes << 3)) || (ysize >= xsize))

  00118	8b 45 d8	 mov	 eax, DWORD PTR _num_stripes$[ebp]
  0011b	c1 e0 03	 shl	 eax, 3
  0011e	39 45 e8	 cmp	 DWORD PTR _ysize$[ebp], eax
  00121	7d 0c		 jge	 SHORT $LN19@man_calcul
  00123	8b 45 e8	 mov	 eax, DWORD PTR _ysize$[ebp]
  00126	3b 45 ec	 cmp	 eax, DWORD PTR _xsize$[ebp]
  00129	0f 8c 27 01 00
	00		 jl	 $LN17@man_calcul
$LN19@man_calcul:

; 2137 :    {
; 2138 :       if (!(step = ysize / num_stripes))  // step size (height of each stripe)

  0012f	8b 45 e8	 mov	 eax, DWORD PTR _ysize$[ebp]
  00132	99		 cdq
  00133	f7 7d d8	 idiv	 DWORD PTR _num_stripes$[ebp]
  00136	89 45 e4	 mov	 DWORD PTR _step$[ebp], eax
  00139	83 7d e4 00	 cmp	 DWORD PTR _step$[ebp], 0
  0013d	75 0d		 jne	 SHORT $LN20@man_calcul

; 2139 :       {
; 2140 :          num_stripes = ysize;             // if more stripes than pixels of height,

  0013f	8b 45 e8	 mov	 eax, DWORD PTR _ysize$[ebp]
  00142	89 45 d8	 mov	 DWORD PTR _num_stripes$[ebp], eax

; 2141 :          step = 1;                        // limit stripes and threads

  00145	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _step$[ebp], 1
$LN20@man_calcul:

; 2142 :       }
; 2143 : 
; 2144 :       // Use fractional steps to get the threads as evenly balanced as possible. For each
; 2145 :       // thread, the stripe height could either be step or step + 1 (they all get the
; 2146 :       // same step as a group).
; 2147 :       //
; 2148 :       // Dual Opteron 280, Double, Fast, 4 threads, 4 stripes/thread, tune.log:
; 2149 :       // With fractional steps      :  4.788s, efficiency 97.8%
; 2150 :       // Without fractional steps   :  4.980s, efficiency 94.1%
; 2151 : 
; 2152 :       frac = frac_step = ysize - (num_stripes * step);

  0014c	8b 45 d8	 mov	 eax, DWORD PTR _num_stripes$[ebp]
  0014f	0f af 45 e4	 imul	 eax, DWORD PTR _step$[ebp]
  00153	8b 4d e8	 mov	 ecx, DWORD PTR _ysize$[ebp]
  00156	2b c8		 sub	 ecx, eax
  00158	89 4d d0	 mov	 DWORD PTR _frac_step$[ebp], ecx
  0015b	8b 55 d0	 mov	 edx, DWORD PTR _frac_step$[ebp]
  0015e	89 55 d4	 mov	 DWORD PTR _frac$[ebp], edx

; 2153 :       this_step = step;

  00161	8b 45 e4	 mov	 eax, DWORD PTR _step$[ebp]
  00164	89 45 cc	 mov	 DWORD PTR _this_step$[ebp], eax

; 2154 : 
; 2155 :       for (i = 0; i < num_stripes; i++)

  00167	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0016e	eb 09		 jmp	 SHORT $LN7@man_calcul
$LN5@man_calcul:
  00170	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00173	83 c0 01	 add	 eax, 1
  00176	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN7@man_calcul:
  00179	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0017c	3b 45 d8	 cmp	 eax, DWORD PTR _num_stripes$[ebp]
  0017f	0f 8d c3 00 00
	00		 jge	 $LN6@man_calcul

; 2156 :       {
; 2157 :          m->thread_states[thread_ind].num_stripes++;

  00185	69 45 e0 a8 00
	00 00		 imul	 eax, DWORD PTR _thread_ind$[ebp], 168
  0018c	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0018f	8b 94 01 90 78
	00 00		 mov	 edx, DWORD PTR [ecx+eax+30864]
  00196	83 c2 01	 add	 edx, 1
  00199	69 45 e0 a8 00
	00 00		 imul	 eax, DWORD PTR _thread_ind$[ebp], 168
  001a0	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  001a3	89 94 01 90 78
	00 00		 mov	 DWORD PTR [ecx+eax+30864], edx

; 2158 :          s = &m->thread_states[thread_ind].stripes[stripe_ind];

  001aa	69 45 e0 a8 00
	00 00		 imul	 eax, DWORD PTR _thread_ind$[ebp], 168
  001b1	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  001b4	8d 94 01 08 78
	00 00		 lea	 edx, DWORD PTR [ecx+eax+30728]
  001bb	8b 45 dc	 mov	 eax, DWORD PTR _stripe_ind$[ebp]
  001be	c1 e0 04	 shl	 eax, 4
  001c1	8d 4c 02 08	 lea	 ecx, DWORD PTR [edx+eax+8]
  001c5	89 4d c8	 mov	 DWORD PTR _s$[ebp], ecx

; 2159 :          s->xstart = xstart;

  001c8	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  001cb	8b 4d 0c	 mov	 ecx, DWORD PTR _xstart$[ebp]
  001ce	89 08		 mov	 DWORD PTR [eax], ecx

; 2160 :          s->xend = xend;

  001d0	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  001d3	8b 4d 10	 mov	 ecx, DWORD PTR _xend$[ebp]
  001d6	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 2161 :          s->ystart = ystart;

  001d9	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  001dc	8b 4d 14	 mov	 ecx, DWORD PTR _ystart$[ebp]
  001df	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 2162 :          s->yend = ystart + this_step - 1;

  001e2	8b 45 cc	 mov	 eax, DWORD PTR _this_step$[ebp]
  001e5	8b 4d 14	 mov	 ecx, DWORD PTR _ystart$[ebp]
  001e8	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  001ec	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  001ef	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 2163 :          ystart += this_step;

  001f2	8b 45 14	 mov	 eax, DWORD PTR _ystart$[ebp]
  001f5	03 45 cc	 add	 eax, DWORD PTR _this_step$[ebp]
  001f8	89 45 14	 mov	 DWORD PTR _ystart$[ebp], eax

; 2164 : 
; 2165 :          // Next stripe goes to next thread. If it wraps, reset and increment each thread's stripe index.
; 2166 :          if (--thread_ind < 0)

  001fb	8b 45 e0	 mov	 eax, DWORD PTR _thread_ind$[ebp]
  001fe	83 e8 01	 sub	 eax, 1
  00201	89 45 e0	 mov	 DWORD PTR _thread_ind$[ebp], eax
  00204	79 3d		 jns	 SHORT $LN22@man_calcul

; 2167 :          {
; 2168 :             thread_ind = num_threads - 1;

  00206	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_threads
  0020b	83 e8 01	 sub	 eax, 1
  0020e	89 45 e0	 mov	 DWORD PTR _thread_ind$[ebp], eax

; 2169 :             stripe_ind++;

  00211	8b 45 dc	 mov	 eax, DWORD PTR _stripe_ind$[ebp]
  00214	83 c0 01	 add	 eax, 1
  00217	89 45 dc	 mov	 DWORD PTR _stripe_ind$[ebp], eax

; 2170 : 
; 2171 :             // Now that each thread has a stripe, update the fraction, and if it wraps
; 2172 :             // increase the stripe height for the next group by 1.
; 2173 :             this_step = step;

  0021a	8b 45 e4	 mov	 eax, DWORD PTR _step$[ebp]
  0021d	89 45 cc	 mov	 DWORD PTR _this_step$[ebp], eax

; 2174 :             if ((frac += frac_step) >= num_stripes)

  00220	8b 45 d4	 mov	 eax, DWORD PTR _frac$[ebp]
  00223	03 45 d0	 add	 eax, DWORD PTR _frac_step$[ebp]
  00226	89 45 d4	 mov	 DWORD PTR _frac$[ebp], eax
  00229	8b 4d d4	 mov	 ecx, DWORD PTR _frac$[ebp]
  0022c	3b 4d d8	 cmp	 ecx, DWORD PTR _num_stripes$[ebp]
  0022f	7c 12		 jl	 SHORT $LN22@man_calcul

; 2175 :             {
; 2176 :                frac -= num_stripes;

  00231	8b 45 d4	 mov	 eax, DWORD PTR _frac$[ebp]
  00234	2b 45 d8	 sub	 eax, DWORD PTR _num_stripes$[ebp]
  00237	89 45 d4	 mov	 DWORD PTR _frac$[ebp], eax

; 2177 :                this_step++;   // comment this out to compare efficiencies without fractional steps

  0023a	8b 45 cc	 mov	 eax, DWORD PTR _this_step$[ebp]
  0023d	83 c0 01	 add	 eax, 1
  00240	89 45 cc	 mov	 DWORD PTR _this_step$[ebp], eax
$LN22@man_calcul:

; 2178 :             }
; 2179 :          }
; 2180 :       }

  00243	e9 28 ff ff ff	 jmp	 $LN5@man_calcul
$LN6@man_calcul:

; 2181 :       // Give thread 0 any leftovers.
; 2182 :       s->yend = yend;

  00248	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  0024b	8b 4d 18	 mov	 ecx, DWORD PTR _yend$[ebp]
  0024e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 2183 :    }

  00251	e9 22 01 00 00	 jmp	 $LN18@man_calcul
$LN17@man_calcul:

; 2184 :    else // Similar code to above for dividing along the x axis
; 2185 :    {
; 2186 :       if (!(step = xsize / num_stripes))

  00256	8b 45 ec	 mov	 eax, DWORD PTR _xsize$[ebp]
  00259	99		 cdq
  0025a	f7 7d d8	 idiv	 DWORD PTR _num_stripes$[ebp]
  0025d	89 45 e4	 mov	 DWORD PTR _step$[ebp], eax
  00260	83 7d e4 00	 cmp	 DWORD PTR _step$[ebp], 0
  00264	75 0d		 jne	 SHORT $LN23@man_calcul

; 2187 :       {
; 2188 :          num_stripes = xsize;

  00266	8b 45 ec	 mov	 eax, DWORD PTR _xsize$[ebp]
  00269	89 45 d8	 mov	 DWORD PTR _num_stripes$[ebp], eax

; 2189 :          step = 1;

  0026c	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _step$[ebp], 1
$LN23@man_calcul:

; 2190 :       }
; 2191 :       frac = frac_step = xsize - (num_stripes * step);

  00273	8b 45 d8	 mov	 eax, DWORD PTR _num_stripes$[ebp]
  00276	0f af 45 e4	 imul	 eax, DWORD PTR _step$[ebp]
  0027a	8b 4d ec	 mov	 ecx, DWORD PTR _xsize$[ebp]
  0027d	2b c8		 sub	 ecx, eax
  0027f	89 4d d0	 mov	 DWORD PTR _frac_step$[ebp], ecx
  00282	8b 55 d0	 mov	 edx, DWORD PTR _frac_step$[ebp]
  00285	89 55 d4	 mov	 DWORD PTR _frac$[ebp], edx

; 2192 :       this_step = step;

  00288	8b 45 e4	 mov	 eax, DWORD PTR _step$[ebp]
  0028b	89 45 cc	 mov	 DWORD PTR _this_step$[ebp], eax

; 2193 : 
; 2194 :       for (i = 0; i < num_stripes; i++)

  0028e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00295	eb 09		 jmp	 SHORT $LN10@man_calcul
$LN8@man_calcul:
  00297	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0029a	83 c0 01	 add	 eax, 1
  0029d	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN10@man_calcul:
  002a0	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  002a3	3b 45 d8	 cmp	 eax, DWORD PTR _num_stripes$[ebp]
  002a6	0f 8d c3 00 00
	00		 jge	 $LN9@man_calcul

; 2195 :       {
; 2196 :          m->thread_states[thread_ind].num_stripes++;

  002ac	69 45 e0 a8 00
	00 00		 imul	 eax, DWORD PTR _thread_ind$[ebp], 168
  002b3	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  002b6	8b 94 01 90 78
	00 00		 mov	 edx, DWORD PTR [ecx+eax+30864]
  002bd	83 c2 01	 add	 edx, 1
  002c0	69 45 e0 a8 00
	00 00		 imul	 eax, DWORD PTR _thread_ind$[ebp], 168
  002c7	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  002ca	89 94 01 90 78
	00 00		 mov	 DWORD PTR [ecx+eax+30864], edx

; 2197 :          s = &m->thread_states[thread_ind].stripes[stripe_ind];

  002d1	69 45 e0 a8 00
	00 00		 imul	 eax, DWORD PTR _thread_ind$[ebp], 168
  002d8	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  002db	8d 94 01 08 78
	00 00		 lea	 edx, DWORD PTR [ecx+eax+30728]
  002e2	8b 45 dc	 mov	 eax, DWORD PTR _stripe_ind$[ebp]
  002e5	c1 e0 04	 shl	 eax, 4
  002e8	8d 4c 02 08	 lea	 ecx, DWORD PTR [edx+eax+8]
  002ec	89 4d c8	 mov	 DWORD PTR _s$[ebp], ecx

; 2198 :          s->xstart = xstart;

  002ef	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  002f2	8b 4d 0c	 mov	 ecx, DWORD PTR _xstart$[ebp]
  002f5	89 08		 mov	 DWORD PTR [eax], ecx

; 2199 :          s->xend = xstart + this_step - 1;

  002f7	8b 45 cc	 mov	 eax, DWORD PTR _this_step$[ebp]
  002fa	8b 4d 0c	 mov	 ecx, DWORD PTR _xstart$[ebp]
  002fd	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  00301	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  00304	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2200 :          s->ystart = ystart;

  00307	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  0030a	8b 4d 14	 mov	 ecx, DWORD PTR _ystart$[ebp]
  0030d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 2201 :          s->yend = yend;

  00310	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  00313	8b 4d 18	 mov	 ecx, DWORD PTR _yend$[ebp]
  00316	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 2202 :          xstart += this_step;

  00319	8b 45 0c	 mov	 eax, DWORD PTR _xstart$[ebp]
  0031c	03 45 cc	 add	 eax, DWORD PTR _this_step$[ebp]
  0031f	89 45 0c	 mov	 DWORD PTR _xstart$[ebp], eax

; 2203 : 
; 2204 :          if (--thread_ind < 0)

  00322	8b 45 e0	 mov	 eax, DWORD PTR _thread_ind$[ebp]
  00325	83 e8 01	 sub	 eax, 1
  00328	89 45 e0	 mov	 DWORD PTR _thread_ind$[ebp], eax
  0032b	79 3d		 jns	 SHORT $LN25@man_calcul

; 2205 :          {
; 2206 :             thread_ind = num_threads - 1;

  0032d	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_threads
  00332	83 e8 01	 sub	 eax, 1
  00335	89 45 e0	 mov	 DWORD PTR _thread_ind$[ebp], eax

; 2207 :             stripe_ind++;

  00338	8b 45 dc	 mov	 eax, DWORD PTR _stripe_ind$[ebp]
  0033b	83 c0 01	 add	 eax, 1
  0033e	89 45 dc	 mov	 DWORD PTR _stripe_ind$[ebp], eax

; 2208 :             this_step = step;

  00341	8b 45 e4	 mov	 eax, DWORD PTR _step$[ebp]
  00344	89 45 cc	 mov	 DWORD PTR _this_step$[ebp], eax

; 2209 :             if ((frac += frac_step) >= num_stripes)

  00347	8b 45 d4	 mov	 eax, DWORD PTR _frac$[ebp]
  0034a	03 45 d0	 add	 eax, DWORD PTR _frac_step$[ebp]
  0034d	89 45 d4	 mov	 DWORD PTR _frac$[ebp], eax
  00350	8b 4d d4	 mov	 ecx, DWORD PTR _frac$[ebp]
  00353	3b 4d d8	 cmp	 ecx, DWORD PTR _num_stripes$[ebp]
  00356	7c 12		 jl	 SHORT $LN25@man_calcul

; 2210 :             {
; 2211 :                frac -= num_stripes;

  00358	8b 45 d4	 mov	 eax, DWORD PTR _frac$[ebp]
  0035b	2b 45 d8	 sub	 eax, DWORD PTR _num_stripes$[ebp]
  0035e	89 45 d4	 mov	 DWORD PTR _frac$[ebp], eax

; 2212 :                this_step++;

  00361	8b 45 cc	 mov	 eax, DWORD PTR _this_step$[ebp]
  00364	83 c0 01	 add	 eax, 1
  00367	89 45 cc	 mov	 DWORD PTR _this_step$[ebp], eax
$LN25@man_calcul:

; 2213 :             }
; 2214 :          }
; 2215 :       }

  0036a	e9 28 ff ff ff	 jmp	 $LN8@man_calcul
$LN9@man_calcul:

; 2216 :       s->xend = xend;

  0036f	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  00372	8b 4d 10	 mov	 ecx, DWORD PTR _xend$[ebp]
  00375	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN18@man_calcul:

; 2217 :    }
; 2218 : 
; 2219 :    // Run the threads on the stripes calculated above.
; 2220 :    // These threading functions are slow. Benchmarks on an Athlon 64 4000+ 2.4 GHz:
; 2221 :    //                                                                                   Equivalent SSE2
; 2222 :    // Functions (tested with 4 threads)                             uS   Clock Cycles   iters (per core)
; 2223 :    // --------------------------------------------------------------------------------------------------
; 2224 :    // 4 CreateThread + WaitForMultipleObjects + 4 CloseHandle     173.0     415200      83040
; 2225 :    // 4 _beginthreadex + WaitForMultipleObjects + 4 CloseHandle   224.0     537600      107520
; 2226 :    // 4 QueueUserWorkItem + 4 SetEvent + WaitForMultipleObjects     7.6      18240      3648
; 2227 :    // 4 SetEvent                                                    1.0       2400      480
; 2228 :    // 4 Null (loop overhead + mandel function call only)            0.01        24      4
; 2229 :    //
; 2230 :    // The QueueUserWorkItem method is probably fast enough. The first two are usually on par with
; 2231 :    // the iteration time while panning, negating any multi-core advantage (for panning).
; 2232 : 
; 2233 :    // Don't call C library routines in threads. 4K stack size is more than enough
; 2234 : 
; 2235 :    start_time = get_timer();

  00378	e8 00 00 00 00	 call	 _get_timer
  0037d	89 45 fc	 mov	 DWORD PTR _start_time$[ebp], eax

; 2236 : 
; 2237 :    // Using WT_EXECUTEINPERSISTENTTHREAD is 50% slower than without.
; 2238 :    // Leaving out WT_EXECUTELONGFUNCTION makes the initial run twice as slow, then same speed.
; 2239 : 
; 2240 :    // Use the master thread (here) to do some of the work. Queue any other threads. Saves some
; 2241 :    // overhead, and doesn't spawn any new threads at all if there's only one thread.
; 2242 : 
; 2243 :    for (i = 1; i < num_threads; i++)

  00380	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00387	eb 09		 jmp	 SHORT $LN13@man_calcul
$LN11@man_calcul:
  00389	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0038c	83 c0 01	 add	 eax, 1
  0038f	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN13@man_calcul:
  00392	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00395	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _num_threads
  0039b	7d 24		 jge	 SHORT $LN12@man_calcul

; 2244 :       QueueUserWorkItem(man_calculate_threaded, &m->thread_states[i],

  0039d	68 10 00 43 00	 push	 4390928			; 00430010H
  003a2	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 168
  003a9	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  003ac	8d 94 01 08 78
	00 00		 lea	 edx, DWORD PTR [ecx+eax+30728]
  003b3	52		 push	 edx
  003b4	68 00 00 00 00	 push	 OFFSET _man_calculate_threaded@4
  003b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueueUserWorkItem@12
  003bf	eb c8		 jmp	 SHORT $LN11@man_calcul
$LN12@man_calcul:

; 2245 :                         WT_EXECUTELONGFUNCTION | (MAX_QUEUE_THREADS << 16));
; 2246 : 
; 2247 :    // Could also queue thread 0 too, then have this master thread display the progress if
; 2248 :    // the calculation is really slow...
; 2249 :    man_calculate_threaded(&m->thread_states[0]);

  003c1	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  003c6	6b c8 00	 imul	 ecx, eax, 0
  003c9	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  003cc	8d 84 0a 08 78
	00 00		 lea	 eax, DWORD PTR [edx+ecx+30728]
  003d3	50		 push	 eax
  003d4	e8 00 00 00 00	 call	 _man_calculate_threaded@4

; 2250 : 
; 2251 :    if (num_threads > 1)

  003d9	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _num_threads, 1
  003e0	7e 26		 jle	 SHORT $LN26@man_calcul

; 2252 :       WaitForMultipleObjects(num_threads - 1, &m->thread_done_events[1], TRUE, INFINITE); // wait till all threads are done

  003e2	6a ff		 push	 -1
  003e4	6a 01		 push	 1
  003e6	b8 04 00 00 00	 mov	 eax, 4
  003eb	c1 e0 00	 shl	 eax, 0
  003ee	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  003f1	8d 94 01 08 8d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+36104]
  003f8	52		 push	 edx
  003f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_threads
  003fe	83 e8 01	 sub	 eax, 1
  00401	50		 push	 eax
  00402	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForMultipleObjects@16
$LN26@man_calcul:

; 2253 : 
; 2254 :    if (!(m->flags & FLAG_IS_SAVE)) // don't update these if doing save

  00408	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0040b	8b 88 0c 93 02
	00		 mov	 ecx, DWORD PTR [eax+168716]
  00411	83 e1 01	 and	 ecx, 1
  00414	75 2b		 jne	 SHORT $LN27@man_calcul

; 2255 :    {
; 2256 :       iteration_time = get_seconds_elapsed(start_time);

  00416	8b 45 fc	 mov	 eax, DWORD PTR _start_time$[ebp]
  00419	50		 push	 eax
  0041a	e8 00 00 00 00	 call	 _get_seconds_elapsed
  0041f	83 c4 04	 add	 esp, 4
  00422	dd 5d f4	 fstp	 QWORD PTR _iteration_time$[ebp]

; 2257 :       file_tot_time += iteration_time;

  00425	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _file_tot_time
  0042d	f2 0f 58 45 f4	 addsd	 xmm0, QWORD PTR _iteration_time$[ebp]
  00432	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _file_tot_time, xmm0

; 2258 :       return iteration_time;

  0043a	dd 45 f4	 fld	 QWORD PTR _iteration_time$[ebp]
  0043d	eb 04		 jmp	 SHORT $LN28@man_calcul

; 2259 :    }

  0043f	eb 02		 jmp	 SHORT $LN28@man_calcul
$LN27@man_calcul:

; 2260 :    else
; 2261 :       return 0.0;

  00441	d9 ee		 fldz
$LN28@man_calcul:

; 2262 : }

  00443	5f		 pop	 edi
  00444	5e		 pop	 esi
  00445	5b		 pop	 ebx
  00446	8b e5		 mov	 esp, ebp
  00448	5d		 pop	 ebp
  00449	c3		 ret	 0
_man_calculate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _man_setup
_TEXT	SEGMENT
tv296 = -124						; size = 8
tv254 = -124						; size = 8
tv148 = -116						; size = 8
tv88 = -116						; size = 8
tv200 = -112						; size = 4
tv194 = -112						; size = 4
tv167 = -112						; size = 4
_ps_ptr$ = -44						; size = 4
_flags$ = -40						; size = 4
_queue_init$ = -36					; size = 4
_step$ = -32						; size = 8
_ploss$ = -24						; size = 4
_ysize$ = -20						; size = 4
_xsize$ = -16						; size = 4
_y$ = -12						; size = 4
_x$ = -8						; size = 4
_i$ = -4						; size = 4
_m$ = 8							; size = 4
_xstart$ = 12						; size = 4
_xend$ = 16						; size = 4
_ystart$ = 20						; size = 4
_yend$ = 24						; size = 4
_man_setup PROC						; COMDAT

; 1937 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1938 :    int i, x, y, xsize, ysize, ploss;
; 1939 :    long long step;
; 1940 :    unsigned queue_init, flags;
; 1941 :    man_pointstruct *ps_ptr;
; 1942 : 
; 1943 :    m->max_iters &= ~1;     // make max iters even- required by optimized alg

  00009	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0000c	8b 88 c0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36288]
  00012	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00015	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00018	89 8a c0 8d 00
	00		 mov	 DWORD PTR [edx+36288], ecx

; 1944 :    xsize = m->xsize;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00021	8b 88 88 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36232]
  00027	89 4d f0	 mov	 DWORD PTR _xsize$[ebp], ecx

; 1945 :    ysize = m->ysize;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0002d	8b 88 8c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36236]
  00033	89 4d ec	 mov	 DWORD PTR _ysize$[ebp], ecx

; 1946 :    flags = m->flags;

  00036	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00039	8b 88 0c 93 02
	00		 mov	 ecx, DWORD PTR [eax+168716]
  0003f	89 4d d8	 mov	 DWORD PTR _flags$[ebp], ecx

; 1947 : 
; 1948 :    // Make re/im arrays, to avoid doing xsize * ysize flops in the main loop.
; 1949 :    // Also check for precision loss (two consecutive values equal or differing only in the lsb)
; 1950 : 
; 1951 :    // Cut overhead by only going from start to end - not whole image size
; 1952 :    // Need to do more than 1 point to detect precision loss... otherwise auto mode won't work.
; 1953 :    // To be safe use at least 4 (allocate 4 extra).
; 1954 : 
; 1955 :    // Updated to use offsets (pan_xoffs and pan_yoffs) for panning, rather than updating re/im
; 1956 :    // on every pan. These are added in below. See comments at top (bug fix)
; 1957 : 
; 1958 :    // If saving, don't check precision loss, and don't recalculate the re array
; 1959 :    // after the first row.
; 1960 : 
; 1961 :    if (!(flags & FLAG_IS_SAVE))

  00042	8b 45 d8	 mov	 eax, DWORD PTR _flags$[ebp]
  00045	83 e0 01	 and	 eax, 1
  00048	75 12		 jne	 SHORT $LN13@man_setup

; 1962 :    {
; 1963 :       xend += 4;  // only need these for non-save (precision loss checking)

  0004a	8b 45 10	 mov	 eax, DWORD PTR _xend$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 10	 mov	 DWORD PTR _xend$[ebp], eax

; 1964 :       yend += 4;

  00053	8b 45 18	 mov	 eax, DWORD PTR _yend$[ebp]
  00056	83 c0 04	 add	 eax, 4
  00059	89 45 18	 mov	 DWORD PTR _yend$[ebp], eax
$LN13@man_setup:

; 1965 :    }
; 1966 : 
; 1967 :    if (flags & FLAG_CALC_RE_ARRAY) // this flag should be 1 for main calculation

  0005c	8b 45 d8	 mov	 eax, DWORD PTR _flags$[ebp]
  0005f	83 e0 02	 and	 eax, 2
  00062	0f 84 c7 00 00
	00		 je	 $LN3@man_setup

; 1968 :    {
; 1969 :       ploss = 0;

  00068	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ploss$[ebp], 0

; 1970 :       x = xstart;

  0006f	8b 45 0c	 mov	 eax, DWORD PTR _xstart$[ebp]
  00072	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax

; 1971 :       step = -(xsize >> 1) + xstart + m->pan_xoffs;

  00075	8b 45 f0	 mov	 eax, DWORD PTR _xsize$[ebp]
  00078	d1 f8		 sar	 eax, 1
  0007a	f7 d8		 neg	 eax
  0007c	03 45 0c	 add	 eax, DWORD PTR _xstart$[ebp]
  0007f	99		 cdq
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  00083	03 81 98 8d 00
	00		 add	 eax, DWORD PTR [ecx+36248]
  00089	13 91 9c 8d 00
	00		 adc	 edx, DWORD PTR [ecx+36252]
  0008f	89 45 e0	 mov	 DWORD PTR _step$[ebp], eax
  00092	89 55 e4	 mov	 DWORD PTR _step$[ebp+4], edx
$LN4@man_setup:

; 1972 :       do
; 1973 :       {
; 1974 :          m->img_re[x] = m->re + get_re_im_offs(m, step++);

  00095	8b 45 e0	 mov	 eax, DWORD PTR _step$[ebp]
  00098	89 45 8c	 mov	 DWORD PTR tv88[ebp], eax
  0009b	8b 4d e4	 mov	 ecx, DWORD PTR _step$[ebp+4]
  0009e	89 4d 90	 mov	 DWORD PTR tv88[ebp+4], ecx
  000a1	8b 55 90	 mov	 edx, DWORD PTR tv88[ebp+4]
  000a4	52		 push	 edx
  000a5	8b 45 8c	 mov	 eax, DWORD PTR tv88[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 _get_re_im_offs
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b5	dd 5d 84	 fstp	 QWORD PTR tv254[ebp]
  000b8	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  000bb	f2 0f 10 45 84	 movsd	 xmm0, QWORD PTR tv254[ebp]
  000c0	f2 0f 58 82 a8
	8d 00 00	 addsd	 xmm0, QWORD PTR [edx+36264]
  000c8	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  000cb	8b 88 d4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36308]
  000d1	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  000d4	f2 0f 11 04 d1	 movsd	 QWORD PTR [ecx+edx*8], xmm0
  000d9	8b 45 e0	 mov	 eax, DWORD PTR _step$[ebp]
  000dc	83 c0 01	 add	 eax, 1
  000df	8b 4d e4	 mov	 ecx, DWORD PTR _step$[ebp+4]
  000e2	83 d1 00	 adc	 ecx, 0
  000e5	89 45 e0	 mov	 DWORD PTR _step$[ebp], eax
  000e8	89 4d e4	 mov	 DWORD PTR _step$[ebp+4], ecx

; 1975 :          if (!(flags & FLAG_IS_SAVE) && x > xstart)

  000eb	8b 45 d8	 mov	 eax, DWORD PTR _flags$[ebp]
  000ee	83 e0 01	 and	 eax, 1
  000f1	75 27		 jne	 SHORT $LN15@man_setup
  000f3	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  000f6	3b 45 0c	 cmp	 eax, DWORD PTR _xstart$[ebp]
  000f9	7e 1f		 jle	 SHORT $LN15@man_setup

; 1976 :             ploss |= check_precision_loss(&m->img_re[x - 1]);

  000fb	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  000fe	8b 88 d4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36308]
  00104	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  00107	8d 44 d1 f8	 lea	 eax, DWORD PTR [ecx+edx*8-8]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _check_precision_loss
  00111	83 c4 04	 add	 esp, 4
  00114	0b 45 e8	 or	 eax, DWORD PTR _ploss$[ebp]
  00117	89 45 e8	 mov	 DWORD PTR _ploss$[ebp], eax
$LN15@man_setup:

; 1977 :       }
; 1978 :       while (++x <= xend);

  0011a	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  0011d	83 c0 01	 add	 eax, 1
  00120	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax
  00123	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  00126	3b 4d 10	 cmp	 ecx, DWORD PTR _xend$[ebp]
  00129	0f 8e 66 ff ff
	ff		 jle	 $LN4@man_setup
$LN3@man_setup:

; 1979 :    }
; 1980 : 
; 1981 :    step = -(ysize >> 1) + ystart + m->pan_yoffs;

  0012f	8b 45 ec	 mov	 eax, DWORD PTR _ysize$[ebp]
  00132	d1 f8		 sar	 eax, 1
  00134	f7 d8		 neg	 eax
  00136	03 45 14	 add	 eax, DWORD PTR _ystart$[ebp]
  00139	99		 cdq
  0013a	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0013d	03 81 a0 8d 00
	00		 add	 eax, DWORD PTR [ecx+36256]
  00143	13 91 a4 8d 00
	00		 adc	 edx, DWORD PTR [ecx+36260]
  00149	89 45 e0	 mov	 DWORD PTR _step$[ebp], eax
  0014c	89 55 e4	 mov	 DWORD PTR _step$[ebp+4], edx

; 1982 :    y = ystart;

  0014f	8b 45 14	 mov	 eax, DWORD PTR _ystart$[ebp]
  00152	89 45 f4	 mov	 DWORD PTR _y$[ebp], eax
$LN7@man_setup:

; 1983 :    do
; 1984 :    {
; 1985 :       m->img_im[y] = m->im - get_re_im_offs(m, step++);

  00155	8b 45 e0	 mov	 eax, DWORD PTR _step$[ebp]
  00158	89 45 8c	 mov	 DWORD PTR tv148[ebp], eax
  0015b	8b 4d e4	 mov	 ecx, DWORD PTR _step$[ebp+4]
  0015e	89 4d 90	 mov	 DWORD PTR tv148[ebp+4], ecx
  00161	8b 55 90	 mov	 edx, DWORD PTR tv148[ebp+4]
  00164	52		 push	 edx
  00165	8b 45 8c	 mov	 eax, DWORD PTR tv148[ebp]
  00168	50		 push	 eax
  00169	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 _get_re_im_offs
  00172	83 c4 0c	 add	 esp, 12			; 0000000cH
  00175	dd 5d 84	 fstp	 QWORD PTR tv296[ebp]
  00178	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  0017b	f2 0f 10 82 b0
	8d 00 00	 movsd	 xmm0, QWORD PTR [edx+36272]
  00183	f2 0f 5c 45 84	 subsd	 xmm0, QWORD PTR tv296[ebp]
  00188	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0018b	8b 88 d8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36312]
  00191	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  00194	f2 0f 11 04 d1	 movsd	 QWORD PTR [ecx+edx*8], xmm0
  00199	8b 45 e0	 mov	 eax, DWORD PTR _step$[ebp]
  0019c	83 c0 01	 add	 eax, 1
  0019f	8b 4d e4	 mov	 ecx, DWORD PTR _step$[ebp+4]
  001a2	83 d1 00	 adc	 ecx, 0
  001a5	89 45 e0	 mov	 DWORD PTR _step$[ebp], eax
  001a8	89 4d e4	 mov	 DWORD PTR _step$[ebp+4], ecx

; 1986 :       if (!(flags & FLAG_IS_SAVE) && y > ystart)

  001ab	8b 45 d8	 mov	 eax, DWORD PTR _flags$[ebp]
  001ae	83 e0 01	 and	 eax, 1
  001b1	75 27		 jne	 SHORT $LN16@man_setup
  001b3	8b 45 f4	 mov	 eax, DWORD PTR _y$[ebp]
  001b6	3b 45 14	 cmp	 eax, DWORD PTR _ystart$[ebp]
  001b9	7e 1f		 jle	 SHORT $LN16@man_setup

; 1987 :          ploss |= check_precision_loss(&m->img_im[y - 1]);

  001bb	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  001be	8b 88 d8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36312]
  001c4	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  001c7	8d 44 d1 f8	 lea	 eax, DWORD PTR [ecx+edx*8-8]
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 _check_precision_loss
  001d1	83 c4 04	 add	 esp, 4
  001d4	0b 45 e8	 or	 eax, DWORD PTR _ploss$[ebp]
  001d7	89 45 e8	 mov	 DWORD PTR _ploss$[ebp], eax
$LN16@man_setup:

; 1988 :    }
; 1989 :    while (++y <= yend);

  001da	8b 45 f4	 mov	 eax, DWORD PTR _y$[ebp]
  001dd	83 c0 01	 add	 eax, 1
  001e0	89 45 f4	 mov	 DWORD PTR _y$[ebp], eax
  001e3	8b 4d f4	 mov	 ecx, DWORD PTR _y$[ebp]
  001e6	3b 4d 18	 cmp	 ecx, DWORD PTR _yend$[ebp]
  001e9	0f 8e 66 ff ff
	ff		 jle	 $LN7@man_setup

; 1990 : 
; 1991 :    if (!(flags & FLAG_IS_SAVE)) // only do auto precision if not saving

  001ef	8b 45 d8	 mov	 eax, DWORD PTR _flags$[ebp]
  001f2	83 e0 01	 and	 eax, 1
  001f5	75 72		 jne	 SHORT $LN8@man_setup

; 1992 :    {
; 1993 :       precision_loss = 0;

  001f7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _precision_loss, 0

; 1994 : 
; 1995 :       // Set precision loss flag. If in auto precision mode, set single or double calculation
; 1996 :       // precision based on loss detection.
; 1997 :       switch (m->precision)

  00201	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00204	8b 88 d0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36304]
  0020a	89 4d 90	 mov	 DWORD PTR tv167[ebp], ecx
  0020d	83 7d 90 00	 cmp	 DWORD PTR tv167[ebp], 0
  00211	74 0e		 je	 SHORT $LN18@man_setup
  00213	83 7d 90 01	 cmp	 DWORD PTR tv167[ebp], 1
  00217	74 3e		 je	 SHORT $LN22@man_setup
  00219	83 7d 90 02	 cmp	 DWORD PTR tv167[ebp], 2
  0021d	74 24		 je	 SHORT $LN19@man_setup
  0021f	eb 48		 jmp	 SHORT $LN24@man_setup
$LN18@man_setup:

; 1998 :       {
; 1999 :          case PRECISION_AUTO:
; 2000 :             m->precision = PRECISION_SINGLE;

  00221	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00224	c7 80 d0 8d 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+36304], 1

; 2001 :             if (ploss & PLOSS_FLOAT)

  0022e	8b 45 e8	 mov	 eax, DWORD PTR _ploss$[ebp]
  00231	83 e0 01	 and	 eax, 1
  00234	74 0d		 je	 SHORT $LN19@man_setup

; 2002 :                m->precision = PRECISION_DOUBLE; // deliberate fallthrough

  00236	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00239	c7 80 d0 8d 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+36304], 2
$LN19@man_setup:

; 2003 :          case PRECISION_DOUBLE:
; 2004 :             if (ploss & PLOSS_DOUBLE)

  00243	8b 45 e8	 mov	 eax, DWORD PTR _ploss$[ebp]
  00246	83 e0 02	 and	 eax, 2
  00249	74 0a		 je	 SHORT $LN21@man_setup

; 2005 :                precision_loss = 1;

  0024b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _precision_loss, 1
$LN21@man_setup:

; 2006 :             break;

  00255	eb 12		 jmp	 SHORT $LN8@man_setup
$LN22@man_setup:

; 2007 :          case PRECISION_SINGLE:
; 2008 :             if (ploss & PLOSS_FLOAT)

  00257	8b 45 e8	 mov	 eax, DWORD PTR _ploss$[ebp]
  0025a	83 e0 01	 and	 eax, 1
  0025d	74 0a		 je	 SHORT $LN23@man_setup

; 2009 :                precision_loss = 1;

  0025f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _precision_loss, 1
$LN23@man_setup:
$LN24@man_setup:
$LN8@man_setup:

; 2010 :             break;
; 2011 :          default: // should never get here (x87 is suppressed until implemented)
; 2012 :             break;
; 2013 :       }
; 2014 :    }
; 2015 : 
; 2016 :    // Set iteration and queue_point function pointers and initialize queues
; 2017 : 
; 2018 :    // Alg will always be C if no sse support.
; 2019 :    // Should change algorithm in dialog box if it's reset to C here.
; 2020 :    if (((m->alg & ALG_C) || (sse_support < 2 && m->precision == PRECISION_DOUBLE)))

  00269	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0026c	8b 88 c8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36296]
  00272	83 e1 04	 and	 ecx, 4
  00275	75 15		 jne	 SHORT $LN27@man_setup
  00277	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _sse_support, 2
  0027e	7d 2b		 jge	 SHORT $LN25@man_setup
  00280	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00283	83 b8 d0 8d 00
	00 02		 cmp	 DWORD PTR [eax+36304], 2
  0028a	75 1f		 jne	 SHORT $LN25@man_setup
$LN27@man_setup:

; 2021 :    {
; 2022 :       m->queue_point = queue_point_c;

  0028c	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0028f	c7 80 00 78 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+30720], OFFSET @queue_point_c@12

; 2023 :       m->mandel_iterate = iterate_c; // Unoptimized C algorithm

  00299	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0029c	c7 80 04 78 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+30724], OFFSET _iterate_c

; 2024 :    }

  002a6	e9 8a 00 00 00	 jmp	 $LN29@man_setup
$LN25@man_setup:

; 2025 :    else
; 2026 :    {
; 2027 :       if (m->precision == PRECISION_DOUBLE)

  002ab	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  002ae	83 b8 d0 8d 00
	00 02		 cmp	 DWORD PTR [eax+36304], 2
  002b5	75 40		 jne	 SHORT $LN28@man_setup

; 2028 :       {
; 2029 :          queue_init = (QUEUE_FULL << 12) | (3 << 9) | (2 << 6) | (1 << 3) | 0;

  002b7	c7 45 dc 88 f6
	00 00		 mov	 DWORD PTR _queue_init$[ebp], 63112 ; 0000f688H

; 2030 :          m->queue_point = queue_4point_sse2;

  002be	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  002c1	c7 80 00 78 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+30720], OFFSET @queue_4point_sse2@12

; 2031 :          m->mandel_iterate = (m->alg & ALG_INTEL) ? iterate_intel_sse2 : iterate_amd_sse2;

  002cb	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  002ce	8b 88 c8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36296]
  002d4	83 e1 02	 and	 ecx, 2
  002d7	74 09		 je	 SHORT $LN31@man_setup
  002d9	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv194[ebp], OFFSET _iterate_intel_sse2
  002e0	eb 07		 jmp	 SHORT $LN32@man_setup
$LN31@man_setup:
  002e2	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv194[ebp], OFFSET _iterate_amd_sse2
$LN32@man_setup:
  002e9	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  002ec	8b 45 90	 mov	 eax, DWORD PTR tv194[ebp]
  002ef	89 82 04 78 00
	00		 mov	 DWORD PTR [edx+30724], eax

; 2032 :       }

  002f5	eb 3e		 jmp	 SHORT $LN29@man_setup
$LN28@man_setup:

; 2033 :       else
; 2034 :       {
; 2035 :          queue_init = (QUEUE_FULL << 24) | (7 << 21) | (6 << 18) | (5 << 15) |

  002f7	c7 45 dc 88 c6
	fa 0f		 mov	 DWORD PTR _queue_init$[ebp], 268093064 ; 0ffac688H

; 2036 :                                            (4 << 12) | (3 << 9) | (2 << 6) | (1 << 3) | 0;
; 2037 :          m->queue_point = queue_8point_sse;

  002fe	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00301	c7 80 00 78 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+30720], OFFSET @queue_8point_sse@12

; 2038 :          m->mandel_iterate = (m->alg & ALG_INTEL) ? iterate_intel_sse : iterate_amd_sse;

  0030b	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0030e	8b 88 c8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36296]
  00314	83 e1 02	 and	 ecx, 2
  00317	74 09		 je	 SHORT $LN33@man_setup
  00319	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv200[ebp], OFFSET _iterate_intel_sse
  00320	eb 07		 jmp	 SHORT $LN34@man_setup
$LN33@man_setup:
  00322	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv200[ebp], OFFSET _iterate_amd_sse
$LN34@man_setup:
  00329	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  0032c	8b 45 90	 mov	 eax, DWORD PTR tv200[ebp]
  0032f	89 82 04 78 00
	00		 mov	 DWORD PTR [edx+30724], eax
$LN29@man_setup:

; 2039 :       }
; 2040 :    }
; 2041 : 
; 2042 :    // Set pointstruct initial values
; 2043 :    for (i = 0; i < num_threads; i++)

  00335	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0033c	eb 09		 jmp	 SHORT $LN12@man_setup
$LN10@man_setup:
  0033e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00341	83 c0 01	 add	 eax, 1
  00344	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN12@man_setup:
  00347	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0034a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _num_threads
  00350	7d 4b		 jge	 SHORT $LN11@man_setup

; 2044 :    {
; 2045 :       ps_ptr = m->thread_states[i].ps_ptr;

  00352	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 168
  00359	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0035c	8b 94 01 0c 78
	00 00		 mov	 edx, DWORD PTR [ecx+eax+30732]
  00363	89 55 d4	 mov	 DWORD PTR _ps_ptr$[ebp], edx

; 2046 :       ps_ptr->queue_status = queue_init;

  00366	8b 45 d4	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  00369	8b 4d dc	 mov	 ecx, DWORD PTR _queue_init$[ebp]
  0036c	89 88 9c 03 00
	00		 mov	 DWORD PTR [eax+924], ecx

; 2047 :       ps_ptr->cur_max_iters = m->max_iters;

  00372	8b 45 d4	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  00375	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  00378	8b 91 c0 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36288]
  0037e	89 90 98 03 00
	00		 mov	 DWORD PTR [eax+920], edx

; 2048 :       ps_ptr->iterctr = 0;

  00384	8b 45 d4	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  00387	c7 80 80 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+896], 0
  00391	c7 80 84 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+900], 0

; 2049 :    }

  0039b	eb a1		 jmp	 SHORT $LN10@man_setup
$LN11@man_setup:

; 2050 : }

  0039d	5f		 pop	 edi
  0039e	5e		 pop	 esi
  0039f	5b		 pop	 ebx
  003a0	8b e5		 mov	 esp, ebp
  003a2	5d		 pop	 ebp
  003a3	c3		 ret	 0
_man_setup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _check_precision_loss
_TEXT	SEGMENT
_i1$ = -24						; size = 8
_i0$ = -16						; size = 8
_f$ = -8						; size = 8
_ptest$ = 8						; size = 4
_check_precision_loss PROC				; COMDAT

; 1903 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1904 :    float f[2];
; 1905 :    int i0[2], i1[2];
; 1906 : 
; 1907 :    // Check double loss
; 1908 :    i0[0] = *((int *) &ptest[0]) & ~1;  // get low dword of 1st double; mask off lsb

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	6b c8 00	 imul	 ecx, eax, 0
  00011	8b 55 08	 mov	 edx, DWORD PTR _ptest$[ebp]
  00014	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00017	83 e0 fe	 and	 eax, -2			; fffffffeH
  0001a	b9 04 00 00 00	 mov	 ecx, 4
  0001f	6b d1 00	 imul	 edx, ecx, 0
  00022	89 44 15 f0	 mov	 DWORD PTR _i0$[ebp+edx], eax

; 1909 :    i0[1] = *((int *) &ptest[0] + 1);   // get high dword

  00026	b8 08 00 00 00	 mov	 eax, 8
  0002b	6b c8 00	 imul	 ecx, eax, 0
  0002e	ba 04 00 00 00	 mov	 edx, 4
  00033	c1 e2 00	 shl	 edx, 0
  00036	8b 45 08	 mov	 eax, DWORD PTR _ptest$[ebp]
  00039	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  0003d	89 4c 15 f0	 mov	 DWORD PTR _i0$[ebp+edx], ecx

; 1910 : 
; 1911 :    i1[0] = *((int *) &ptest[1]) & ~1;  // get low dword of 2nd double; mask off lsb

  00041	b8 08 00 00 00	 mov	 eax, 8
  00046	c1 e0 00	 shl	 eax, 0
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _ptest$[ebp]
  0004c	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0004f	83 e2 fe	 and	 edx, -2			; fffffffeH
  00052	b8 04 00 00 00	 mov	 eax, 4
  00057	6b c8 00	 imul	 ecx, eax, 0
  0005a	89 54 0d e8	 mov	 DWORD PTR _i1$[ebp+ecx], edx

; 1912 :    i1[1] = *((int *) &ptest[1] + 1);   // get high dword

  0005e	b8 08 00 00 00	 mov	 eax, 8
  00063	c1 e0 00	 shl	 eax, 0
  00066	b9 04 00 00 00	 mov	 ecx, 4
  0006b	c1 e1 00	 shl	 ecx, 0
  0006e	8b 55 08	 mov	 edx, DWORD PTR _ptest$[ebp]
  00071	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00075	89 44 0d e8	 mov	 DWORD PTR _i1$[ebp+ecx], eax

; 1913 : 
; 1914 :    if ((i0[1] == i1[1]) && (i0[0] == i1[0]))

  00079	b8 04 00 00 00	 mov	 eax, 4
  0007e	c1 e0 00	 shl	 eax, 0
  00081	b9 04 00 00 00	 mov	 ecx, 4
  00086	c1 e1 00	 shl	 ecx, 0
  00089	8b 54 05 f0	 mov	 edx, DWORD PTR _i0$[ebp+eax]
  0008d	3b 54 0d e8	 cmp	 edx, DWORD PTR _i1$[ebp+ecx]
  00091	75 24		 jne	 SHORT $LN2@check_prec
  00093	b8 04 00 00 00	 mov	 eax, 4
  00098	6b c8 00	 imul	 ecx, eax, 0
  0009b	ba 04 00 00 00	 mov	 edx, 4
  000a0	6b c2 00	 imul	 eax, edx, 0
  000a3	8b 4c 0d f0	 mov	 ecx, DWORD PTR _i0$[ebp+ecx]
  000a7	3b 4c 05 e8	 cmp	 ecx, DWORD PTR _i1$[ebp+eax]
  000ab	75 0a		 jne	 SHORT $LN2@check_prec

; 1915 :       return PLOSS_DOUBLE | PLOSS_FLOAT; // double loss is also float loss

  000ad	b8 03 00 00 00	 mov	 eax, 3
  000b2	e9 95 00 00 00	 jmp	 $LN1@check_prec
$LN2@check_prec:

; 1916 : 
; 1917 :    // Check float loss
; 1918 :    f[0] = (float) ptest[0];            // convert doubles to floats

  000b7	b8 08 00 00 00	 mov	 eax, 8
  000bc	6b c8 00	 imul	 ecx, eax, 0
  000bf	8b 55 08	 mov	 edx, DWORD PTR _ptest$[ebp]
  000c2	f2 0f 5a 04 0a	 cvtsd2ss xmm0, QWORD PTR [edx+ecx]
  000c7	b8 04 00 00 00	 mov	 eax, 4
  000cc	6b c8 00	 imul	 ecx, eax, 0
  000cf	f3 0f 11 44 0d
	f8		 movss	 DWORD PTR _f$[ebp+ecx], xmm0

; 1919 :    f[1] = (float) ptest[1];

  000d5	b8 08 00 00 00	 mov	 eax, 8
  000da	c1 e0 00	 shl	 eax, 0
  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _ptest$[ebp]
  000e0	f2 0f 5a 04 01	 cvtsd2ss xmm0, QWORD PTR [ecx+eax]
  000e5	ba 04 00 00 00	 mov	 edx, 4
  000ea	c1 e2 00	 shl	 edx, 0
  000ed	f3 0f 11 44 15
	f8		 movss	 DWORD PTR _f$[ebp+edx], xmm0

; 1920 : 
; 1921 :    i0[0] = *((int *) &f[0]) & ~1;      // get 1st float; mask off lsb

  000f3	b8 04 00 00 00	 mov	 eax, 4
  000f8	6b c8 00	 imul	 ecx, eax, 0
  000fb	8b 54 0d f8	 mov	 edx, DWORD PTR _f$[ebp+ecx]
  000ff	83 e2 fe	 and	 edx, -2			; fffffffeH
  00102	b8 04 00 00 00	 mov	 eax, 4
  00107	6b c8 00	 imul	 ecx, eax, 0
  0010a	89 54 0d f0	 mov	 DWORD PTR _i0$[ebp+ecx], edx

; 1922 :    i1[0] = *((int *) &f[1]) & ~1;      // get 2nd float; mask off lsb

  0010e	b8 04 00 00 00	 mov	 eax, 4
  00113	c1 e0 00	 shl	 eax, 0
  00116	8b 4c 05 f8	 mov	 ecx, DWORD PTR _f$[ebp+eax]
  0011a	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0011d	ba 04 00 00 00	 mov	 edx, 4
  00122	6b c2 00	 imul	 eax, edx, 0
  00125	89 4c 05 e8	 mov	 DWORD PTR _i1$[ebp+eax], ecx

; 1923 : 
; 1924 :    if (i0[0] == i1[0])

  00129	b8 04 00 00 00	 mov	 eax, 4
  0012e	6b c8 00	 imul	 ecx, eax, 0
  00131	ba 04 00 00 00	 mov	 edx, 4
  00136	6b c2 00	 imul	 eax, edx, 0
  00139	8b 4c 0d f0	 mov	 ecx, DWORD PTR _i0$[ebp+ecx]
  0013d	3b 4c 05 e8	 cmp	 ecx, DWORD PTR _i1$[ebp+eax]
  00141	75 07		 jne	 SHORT $LN3@check_prec

; 1925 :       return PLOSS_FLOAT;

  00143	b8 01 00 00 00	 mov	 eax, 1
  00148	eb 02		 jmp	 SHORT $LN1@check_prec
$LN3@check_prec:

; 1926 : 
; 1927 :    return 0;

  0014a	33 c0		 xor	 eax, eax
$LN1@check_prec:

; 1928 : }

  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c3		 ret	 0
_check_precision_loss ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _man_calculate_threaded@4
_TEXT	SEGMENT
tv265 = -172						; size = 4
tv262 = -172						; size = 4
tv139 = -172						; size = 4
_offs3$1 = -104						; size = 4
_offs2$2 = -100						; size = 4
_offs1$3 = -96						; size = 4
_offs0$4 = -92						; size = 4
_p3$5 = -88						; size = 4
_p2$6 = -84						; size = 4
_p1$7 = -80						; size = 4
_p0$8 = -76						; size = 4
_inc$9 = -72						; size = 4
_xoffs$10 = -68						; size = 4
_wave$11 = -64						; size = 4
_m$ = -60						; size = 4
_s$ = -56						; size = 4
_t$ = -52						; size = 4
_ps_ptr$ = -48						; size = 4
_iters_ptr$ = -44					; size = 4
_points_guessed$ = -40					; size = 4
_line_size$ = -36					; size = 4
_yend$ = -32						; size = 4
_ystart$ = -28						; size = 4
_xend$ = -24						; size = 4
_xstart$ = -20						; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_n$ = -8						; size = 4
_i$ = -4						; size = 4
_param$ = 8						; size = 4
_man_calculate_threaded@4 PROC				; COMDAT

; 1713 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1714 :    int i, n, x, y, xstart, xend, ystart, yend, line_size, points_guessed;
; 1715 :    unsigned *iters_ptr;
; 1716 :    man_pointstruct *ps_ptr;
; 1717 :    thread_state *t;
; 1718 :    stripe *s;
; 1719 :    man_calc_struct *m;
; 1720 : 
; 1721 :    t = (thread_state *) param;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  0000f	89 45 cc	 mov	 DWORD PTR _t$[ebp], eax

; 1722 :    s = t->stripes;

  00012	8b 45 cc	 mov	 eax, DWORD PTR _t$[ebp]
  00015	83 c0 08	 add	 eax, 8
  00018	89 45 c8	 mov	 DWORD PTR _s$[ebp], eax

; 1723 :    n = t->num_stripes;

  0001b	8b 45 cc	 mov	 eax, DWORD PTR _t$[ebp]
  0001e	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00024	89 4d f8	 mov	 DWORD PTR _n$[ebp], ecx

; 1724 :    ps_ptr = t->ps_ptr;

  00027	8b 45 cc	 mov	 eax, DWORD PTR _t$[ebp]
  0002a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002d	89 4d d0	 mov	 DWORD PTR _ps_ptr$[ebp], ecx

; 1725 :    m = (man_calc_struct *) t->calc_struct;

  00030	8b 45 cc	 mov	 eax, DWORD PTR _t$[ebp]
  00033	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00039	89 4d c4	 mov	 DWORD PTR _m$[ebp], ecx

; 1726 : 
; 1727 :    line_size = m->iter_data_line_size;

  0003c	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  0003f	8b 88 e4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36324]
  00045	89 4d dc	 mov	 DWORD PTR _line_size$[ebp], ecx

; 1728 :    points_guessed = 0;

  00048	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _points_guessed$[ebp], 0

; 1729 : 
; 1730 :    // Calculate all the stripes. Needs to handle num_stripes == 0
; 1731 :    for (i = 0; i < n; i++)

  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00056	eb 09		 jmp	 SHORT $LN4@man_calcul
$LN2@man_calcul:
  00058	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0005b	83 c0 01	 add	 eax, 1
  0005e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@man_calcul:
  00061	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00064	3b 45 f8	 cmp	 eax, DWORD PTR _n$[ebp]
  00067	0f 8d f1 03 00
	00		 jge	 $LN3@man_calcul

; 1732 :    {
; 1733 :       // Use these for benchmarking thread creation/execution overhead
; 1734 :       // return 0;                  // for CreateThread method
; 1735 :       // SetEvent(t->done_event);   // for QueueUserWorkItem method
; 1736 :       // return 0;
; 1737 : 
; 1738 :       xstart = s->xstart;

  0006d	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	89 4d ec	 mov	 DWORD PTR _xstart$[ebp], ecx

; 1739 :       xend = s->xend;

  00075	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	89 4d e8	 mov	 DWORD PTR _xend$[ebp], ecx

; 1740 :       ystart = s->ystart;

  0007e	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  00081	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00084	89 4d e4	 mov	 DWORD PTR _ystart$[ebp], ecx

; 1741 :       yend = s->yend;

  00087	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  0008a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0008d	89 4d e0	 mov	 DWORD PTR _yend$[ebp], ecx

; 1742 : 
; 1743 :       // Optimization for panning: set alg to exact mode for very thin regions. Due to the
; 1744 :       // Fast algorithm's 4x4 cell size it often computes more pixels than Exact for these
; 1745 :       // regions. Effect is most apparent with high iter count images.
; 1746 : 
; 1747 :       #define FE_SWITCHOVER_THRESH  2 // only do it for 1-pixel wide regions for now. best value TBD...
; 1748 : 
; 1749 :       m->cur_alg = m->alg;

  00090	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  00093	8b 4d c4	 mov	 ecx, DWORD PTR _m$[ebp]
  00096	8b 91 c8 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36296]
  0009c	89 90 cc 8d 00
	00		 mov	 DWORD PTR [eax+36300], edx

; 1750 :       if ((xend - xstart) < FE_SWITCHOVER_THRESH || (yend - ystart) < FE_SWITCHOVER_THRESH )

  000a2	8b 45 e8	 mov	 eax, DWORD PTR _xend$[ebp]
  000a5	2b 45 ec	 sub	 eax, DWORD PTR _xstart$[ebp]
  000a8	83 f8 02	 cmp	 eax, 2
  000ab	7c 0b		 jl	 SHORT $LN29@man_calcul
  000ad	8b 45 e0	 mov	 eax, DWORD PTR _yend$[ebp]
  000b0	2b 45 e4	 sub	 eax, DWORD PTR _ystart$[ebp]
  000b3	83 f8 02	 cmp	 eax, 2
  000b6	7d 15		 jge	 SHORT $LN28@man_calcul
$LN29@man_calcul:

; 1751 :          m->cur_alg |= ALG_EXACT;

  000b8	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  000bb	8b 88 cc 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36300]
  000c1	83 c9 01	 or	 ecx, 1
  000c4	8b 55 c4	 mov	 edx, DWORD PTR _m$[ebp]
  000c7	89 8a cc 8d 00
	00		 mov	 DWORD PTR [edx+36300], ecx
$LN28@man_calcul:

; 1752 : 
; 1753 :       // Main loop. Queue each point in the image for iteration. Queue_point will return
; 1754 :       // immediately if its queue isn't full (needs 4 points for the asm version), otherwise
; 1755 :       // it will iterate on all the points in the queue.
; 1756 : 
; 1757 :       if (m->cur_alg & ALG_EXACT) // Exact algorithm: calculates every pixel

  000cd	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  000d0	8b 88 cc 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36300]
  000d6	83 e1 01	 and	 ecx, 1
  000d9	0f 84 c7 00 00
	00		 je	 $LN30@man_calcul

; 1758 :       {
; 1759 :          y = ystart;

  000df	8b 45 e4	 mov	 eax, DWORD PTR _ystart$[ebp]
  000e2	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
$LN7@man_calcul:

; 1760 :          do
; 1761 :          {
; 1762 :             x = xstart;

  000e5	8b 45 ec	 mov	 eax, DWORD PTR _xstart$[ebp]
  000e8	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax

; 1763 :             ps_ptr->ab_in[1] = m->img_im[y];    // Load IM coordinate from the array

  000eb	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  000ee	8b 88 d8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36312]
  000f4	ba 08 00 00 00	 mov	 edx, 8
  000f9	c1 e2 00	 shl	 edx, 0
  000fc	8b 45 d0	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  000ff	8b 75 f0	 mov	 esi, DWORD PTR _y$[ebp]
  00102	f2 0f 10 04 f1	 movsd	 xmm0, QWORD PTR [ecx+esi*8]
  00107	f2 0f 11 84 10
	88 03 00 00	 movsd	 QWORD PTR [eax+edx+904], xmm0

; 1764 :             iters_ptr = m->iter_data + y * line_size + x;

  00110	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00113	0f af 45 dc	 imul	 eax, DWORD PTR _line_size$[ebp]
  00117	8b 4d c4	 mov	 ecx, DWORD PTR _m$[ebp]
  0011a	8b 91 e0 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36320]
  00120	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  00123	8b 4d f4	 mov	 ecx, DWORD PTR _x$[ebp]
  00126	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00129	89 55 d4	 mov	 DWORD PTR _iters_ptr$[ebp], edx
$LN10@man_calcul:

; 1765 :             do
; 1766 :             {
; 1767 :                ps_ptr->ab_in[0] = m->img_re[x]; // Load RE coordinate from the array

  0012c	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  0012f	8b 88 d4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36308]
  00135	ba 08 00 00 00	 mov	 edx, 8
  0013a	6b c2 00	 imul	 eax, edx, 0
  0013d	8b 55 d0	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  00140	8b 75 f4	 mov	 esi, DWORD PTR _x$[ebp]
  00143	f2 0f 10 04 f1	 movsd	 xmm0, QWORD PTR [ecx+esi*8]
  00148	f2 0f 11 84 02
	88 03 00 00	 movsd	 QWORD PTR [edx+eax+904], xmm0

; 1768 :                m->queue_point(m, ps_ptr, iters_ptr++);

  00151	8b 45 d4	 mov	 eax, DWORD PTR _iters_ptr$[ebp]
  00154	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv139[ebp], eax
  0015a	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv139[ebp]
  00160	51		 push	 ecx
  00161	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  00164	8b 55 d0	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  00167	8b 4d c4	 mov	 ecx, DWORD PTR _m$[ebp]
  0016a	8b 80 00 78 00
	00		 mov	 eax, DWORD PTR [eax+30720]
  00170	ff d0		 call	 eax
  00172	8b 4d d4	 mov	 ecx, DWORD PTR _iters_ptr$[ebp]
  00175	83 c1 04	 add	 ecx, 4
  00178	89 4d d4	 mov	 DWORD PTR _iters_ptr$[ebp], ecx

; 1769 :             }
; 1770 :             while (++x <= xend);

  0017b	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  0017e	83 c0 01	 add	 eax, 1
  00181	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax
  00184	8b 4d f4	 mov	 ecx, DWORD PTR _x$[ebp]
  00187	3b 4d e8	 cmp	 ecx, DWORD PTR _xend$[ebp]
  0018a	7e a0		 jle	 SHORT $LN10@man_calcul

; 1771 :          }
; 1772 :          while (++y <= yend);

  0018c	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  0018f	83 c0 01	 add	 eax, 1
  00192	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
  00195	8b 4d f0	 mov	 ecx, DWORD PTR _y$[ebp]
  00198	3b 4d e0	 cmp	 ecx, DWORD PTR _yend$[ebp]
  0019b	0f 8e 44 ff ff
	ff		 jle	 $LN7@man_calcul

; 1773 :       }

  001a1	e9 aa 02 00 00	 jmp	 $LN12@man_calcul
$LN30@man_calcul:

; 1774 :       else // Fast "wave" algorithm from old code: guesses pixels.
; 1775 :       {
; 1776 :          int wave, xoffs, inc, p0, p1, p2, p3, offs0, offs1, offs2, offs3;
; 1777 : 
; 1778 :          // Doing the full calculation (all waves) on horizontal chunks to improve cache locality
; 1779 :          // gives no speedup (tested before realtime zooming was implemented- maybe should test again).
; 1780 : 
; 1781 :          for (wave = 0; wave < 7; wave++)

  001a6	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _wave$11[ebp], 0
  001ad	eb 09		 jmp	 SHORT $LN13@man_calcul
$LN11@man_calcul:
  001af	8b 45 c0	 mov	 eax, DWORD PTR _wave$11[ebp]
  001b2	83 c0 01	 add	 eax, 1
  001b5	89 45 c0	 mov	 DWORD PTR _wave$11[ebp], eax
$LN13@man_calcul:
  001b8	83 7d c0 07	 cmp	 DWORD PTR _wave$11[ebp], 7
  001bc	0f 8d 8e 02 00
	00		 jge	 $LN12@man_calcul

; 1782 :          {
; 1783 :             inc = wave_inc[wave];

  001c2	8b 45 c0	 mov	 eax, DWORD PTR _wave$11[ebp]
  001c5	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wave_inc[eax*4]
  001cc	89 4d b8	 mov	 DWORD PTR _inc$9[ebp], ecx

; 1784 :             y = wave_ystart[wave] + ystart;

  001cf	8b 45 c0	 mov	 eax, DWORD PTR _wave$11[ebp]
  001d2	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wave_ystart[eax*4]
  001d9	03 4d e4	 add	 ecx, DWORD PTR _ystart$[ebp]
  001dc	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 1785 : 
; 1786 :             // Special case for wave 0 (always calculates all pixels). Makes realtime
; 1787 :             // zooming measurably faster. X starts at xstart for wave 0, so can use do-while.
; 1788 :             // For Y, need to calculate all waves even if out of range, because subsequent
; 1789 :             // waves look forward to pixels calculated in previous waves (wave 0 starts at y = 3)
; 1790 : 
; 1791 :             if (!wave) // it's faster with the special case inside the wave loop than outside

  001df	83 7d c0 00	 cmp	 DWORD PTR _wave$11[ebp], 0
  001e3	0f 85 b8 00 00
	00		 jne	 $LN32@man_calcul
$LN16@man_calcul:

; 1792 :             {
; 1793 :                do
; 1794 :                {
; 1795 :                   x = xstart;

  001e9	8b 45 ec	 mov	 eax, DWORD PTR _xstart$[ebp]
  001ec	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax

; 1796 :                   ps_ptr->ab_in[1] = m->img_im[y];    // Load IM coordinate from the array

  001ef	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  001f2	8b 88 d8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36312]
  001f8	ba 08 00 00 00	 mov	 edx, 8
  001fd	c1 e2 00	 shl	 edx, 0
  00200	8b 45 d0	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  00203	8b 75 f0	 mov	 esi, DWORD PTR _y$[ebp]
  00206	f2 0f 10 04 f1	 movsd	 xmm0, QWORD PTR [ecx+esi*8]
  0020b	f2 0f 11 84 10
	88 03 00 00	 movsd	 QWORD PTR [eax+edx+904], xmm0

; 1797 :                   iters_ptr = m->iter_data + y * line_size + x; // adding a line to the ptr every y loop is slower

  00214	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00217	0f af 45 dc	 imul	 eax, DWORD PTR _line_size$[ebp]
  0021b	8b 4d c4	 mov	 ecx, DWORD PTR _m$[ebp]
  0021e	8b 91 e0 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36320]
  00224	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  00227	8b 4d f4	 mov	 ecx, DWORD PTR _x$[ebp]
  0022a	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  0022d	89 55 d4	 mov	 DWORD PTR _iters_ptr$[ebp], edx
$LN19@man_calcul:

; 1798 :                   do
; 1799 :                   {
; 1800 :                      ps_ptr->ab_in[0] = m->img_re[x]; // Load RE coordinate from the array

  00230	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  00233	8b 88 d4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36308]
  00239	ba 08 00 00 00	 mov	 edx, 8
  0023e	6b c2 00	 imul	 eax, edx, 0
  00241	8b 55 d0	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  00244	8b 75 f4	 mov	 esi, DWORD PTR _x$[ebp]
  00247	f2 0f 10 04 f1	 movsd	 xmm0, QWORD PTR [ecx+esi*8]
  0024c	f2 0f 11 84 02
	88 03 00 00	 movsd	 QWORD PTR [edx+eax+904], xmm0

; 1801 :                      m->queue_point(m, ps_ptr, iters_ptr);

  00255	8b 45 d4	 mov	 eax, DWORD PTR _iters_ptr$[ebp]
  00258	50		 push	 eax
  00259	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  0025c	8b 55 d0	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  0025f	8b 4d c4	 mov	 ecx, DWORD PTR _m$[ebp]
  00262	8b 80 00 78 00
	00		 mov	 eax, DWORD PTR [eax+30720]
  00268	ff d0		 call	 eax

; 1802 :                      iters_ptr += inc;

  0026a	8b 45 b8	 mov	 eax, DWORD PTR _inc$9[ebp]
  0026d	8b 4d d4	 mov	 ecx, DWORD PTR _iters_ptr$[ebp]
  00270	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00273	89 55 d4	 mov	 DWORD PTR _iters_ptr$[ebp], edx

; 1803 :                      x += inc;

  00276	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  00279	03 45 b8	 add	 eax, DWORD PTR _inc$9[ebp]
  0027c	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax

; 1804 :                   }
; 1805 :                   while (x <= xend);

  0027f	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  00282	3b 45 e8	 cmp	 eax, DWORD PTR _xend$[ebp]
  00285	7e a9		 jle	 SHORT $LN19@man_calcul

; 1806 :                }
; 1807 :                while ((y += inc) <= yend);

  00287	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  0028a	03 45 b8	 add	 eax, DWORD PTR _inc$9[ebp]
  0028d	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
  00290	8b 4d f0	 mov	 ecx, DWORD PTR _y$[ebp]
  00293	3b 4d e0	 cmp	 ecx, DWORD PTR _yend$[ebp]
  00296	0f 8e 4d ff ff
	ff		 jle	 $LN16@man_calcul

; 1808 :             }

  0029c	e9 aa 01 00 00	 jmp	 $LN21@man_calcul
$LN32@man_calcul:

; 1809 :             else  // waves 1-6 check neighboring pixels
; 1810 :             {
; 1811 :                offs0 = wave_ptr_offs[wave][0]; // pointer offsets of neighboring pixels

  002a1	8b 45 c0	 mov	 eax, DWORD PTR _wave$11[ebp]
  002a4	c1 e0 04	 shl	 eax, 4
  002a7	b9 04 00 00 00	 mov	 ecx, 4
  002ac	6b d1 00	 imul	 edx, ecx, 0
  002af	8b 84 10 00 00
	00 00		 mov	 eax, DWORD PTR _wave_ptr_offs[eax+edx]
  002b6	89 45 a4	 mov	 DWORD PTR _offs0$4[ebp], eax

; 1812 :                offs1 = wave_ptr_offs[wave][1];

  002b9	8b 45 c0	 mov	 eax, DWORD PTR _wave$11[ebp]
  002bc	c1 e0 04	 shl	 eax, 4
  002bf	b9 04 00 00 00	 mov	 ecx, 4
  002c4	c1 e1 00	 shl	 ecx, 0
  002c7	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR _wave_ptr_offs[eax+ecx]
  002ce	89 55 a0	 mov	 DWORD PTR _offs1$3[ebp], edx

; 1813 :                offs2 = wave_ptr_offs[wave][2];

  002d1	8b 45 c0	 mov	 eax, DWORD PTR _wave$11[ebp]
  002d4	c1 e0 04	 shl	 eax, 4
  002d7	b9 04 00 00 00	 mov	 ecx, 4
  002dc	d1 e1		 shl	 ecx, 1
  002de	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR _wave_ptr_offs[eax+ecx]
  002e5	89 55 9c	 mov	 DWORD PTR _offs2$2[ebp], edx

; 1814 :                offs3 = wave_ptr_offs[wave][3];

  002e8	8b 45 c0	 mov	 eax, DWORD PTR _wave$11[ebp]
  002eb	c1 e0 04	 shl	 eax, 4
  002ee	b9 04 00 00 00	 mov	 ecx, 4
  002f3	6b d1 03	 imul	 edx, ecx, 3
  002f6	8b 84 10 00 00
	00 00		 mov	 eax, DWORD PTR _wave_ptr_offs[eax+edx]
  002fd	89 45 98	 mov	 DWORD PTR _offs3$1[ebp], eax

; 1815 : 
; 1816 :                xoffs = wave_xstart[wave] + xstart;

  00300	8b 45 c0	 mov	 eax, DWORD PTR _wave$11[ebp]
  00303	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wave_xstart[eax*4]
  0030a	03 4d ec	 add	 ecx, DWORD PTR _xstart$[ebp]
  0030d	89 4d bc	 mov	 DWORD PTR _xoffs$10[ebp], ecx
$LN22@man_calcul:

; 1817 : 
; 1818 :                do
; 1819 :                {
; 1820 :                   x = xoffs;

  00310	8b 45 bc	 mov	 eax, DWORD PTR _xoffs$10[ebp]
  00313	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax

; 1821 :                   ps_ptr->ab_in[1] = m->img_im[y];

  00316	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  00319	8b 88 d8 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36312]
  0031f	ba 08 00 00 00	 mov	 edx, 8
  00324	c1 e2 00	 shl	 edx, 0
  00327	8b 45 d0	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  0032a	8b 75 f0	 mov	 esi, DWORD PTR _y$[ebp]
  0032d	f2 0f 10 04 f1	 movsd	 xmm0, QWORD PTR [ecx+esi*8]
  00332	f2 0f 11 84 10
	88 03 00 00	 movsd	 QWORD PTR [eax+edx+904], xmm0

; 1822 :                   iters_ptr = m->iter_data + y * line_size + x;

  0033b	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  0033e	0f af 45 dc	 imul	 eax, DWORD PTR _line_size$[ebp]
  00342	8b 4d c4	 mov	 ecx, DWORD PTR _m$[ebp]
  00345	8b 91 e0 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36320]
  0034b	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  0034e	8b 4d f4	 mov	 ecx, DWORD PTR _x$[ebp]
  00351	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00354	89 55 d4	 mov	 DWORD PTR _iters_ptr$[ebp], edx
$LN23@man_calcul:

; 1823 : 
; 1824 :                   // No faster to have a special case for waves 1 and 4 that loads only 2 pixels/loop
; 1825 :                   while (x <= xend)

  00357	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  0035a	3b 45 e8	 cmp	 eax, DWORD PTR _xend$[ebp]
  0035d	0f 8f d3 00 00
	00		 jg	 $LN24@man_calcul

; 1826 :                   {
; 1827 :                      // If all 4 neighboring pixels (p0 - p3) are the same, set this pixel to
; 1828 :                      // their value, else iterate.
; 1829 : 
; 1830 :                      p0 = iters_ptr[offs0];

  00363	8b 45 a4	 mov	 eax, DWORD PTR _offs0$4[ebp]
  00366	8b 4d d4	 mov	 ecx, DWORD PTR _iters_ptr$[ebp]
  00369	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0036c	89 55 b4	 mov	 DWORD PTR _p0$8[ebp], edx

; 1831 :                      p1 = iters_ptr[offs1];

  0036f	8b 45 a0	 mov	 eax, DWORD PTR _offs1$3[ebp]
  00372	8b 4d d4	 mov	 ecx, DWORD PTR _iters_ptr$[ebp]
  00375	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00378	89 55 b0	 mov	 DWORD PTR _p1$7[ebp], edx

; 1832 :                      p2 = iters_ptr[offs2];

  0037b	8b 45 9c	 mov	 eax, DWORD PTR _offs2$2[ebp]
  0037e	8b 4d d4	 mov	 ecx, DWORD PTR _iters_ptr$[ebp]
  00381	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00384	89 55 ac	 mov	 DWORD PTR _p2$6[ebp], edx

; 1833 :                      p3 = iters_ptr[offs3];

  00387	8b 45 98	 mov	 eax, DWORD PTR _offs3$1[ebp]
  0038a	8b 4d d4	 mov	 ecx, DWORD PTR _iters_ptr$[ebp]
  0038d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00390	89 55 a8	 mov	 DWORD PTR _p3$5[ebp], edx

; 1834 : 
; 1835 :                      if (p0 == p1 && p0 == p2 && p0 == p3) // can't use sum compares here (causes corrupted pixels)

  00393	8b 45 b4	 mov	 eax, DWORD PTR _p0$8[ebp]
  00396	3b 45 b0	 cmp	 eax, DWORD PTR _p1$7[ebp]
  00399	75 47		 jne	 SHORT $LN34@man_calcul
  0039b	8b 45 b4	 mov	 eax, DWORD PTR _p0$8[ebp]
  0039e	3b 45 ac	 cmp	 eax, DWORD PTR _p2$6[ebp]
  003a1	75 3f		 jne	 SHORT $LN34@man_calcul
  003a3	8b 45 b4	 mov	 eax, DWORD PTR _p0$8[ebp]
  003a6	3b 45 a8	 cmp	 eax, DWORD PTR _p3$5[ebp]
  003a9	75 37		 jne	 SHORT $LN34@man_calcul

; 1836 :                      {
; 1837 :                         // aargh... compiler (or AMD CPU) generates different performance on
; 1838 :                         // zoomtest depending on which point is stored here. They're all the same...
; 1839 :                         // p3: 18.5s  p2: 18.3s  p1: 18.7s  p0: 19.2s  (+/- 0.1s repeatability)
; 1840 : 
; 1841 :                         *iters_ptr = p2;

  003ab	8b 45 d4	 mov	 eax, DWORD PTR _iters_ptr$[ebp]
  003ae	8b 4d ac	 mov	 ecx, DWORD PTR _p2$6[ebp]
  003b1	89 08		 mov	 DWORD PTR [eax], ecx

; 1842 : 
; 1843 :                         // This works suprisingly well- degradation is really only noticeable
; 1844 :                         // at high frequency transitions (e.g. with striped palettes).
; 1845 :                         // Maybe average the mags at the 4 offsets to make it better
; 1846 : 
; 1847 :                         // The mag store causes about a 7.5% slowdown on zoomtest.
; 1848 :                         MAG(m, iters_ptr) = MAG(m, &iters_ptr[offs2]);

  003b3	8b 45 9c	 mov	 eax, DWORD PTR _offs2$2[ebp]
  003b6	8b 4d d4	 mov	 ecx, DWORD PTR _iters_ptr$[ebp]
  003b9	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  003bc	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  003bf	8b 88 ec 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36332]
  003c5	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  003c8	8b 80 ec 8d 00
	00		 mov	 eax, DWORD PTR [eax+36332]
  003ce	8b 75 d4	 mov	 esi, DWORD PTR _iters_ptr$[ebp]
  003d1	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  003d4	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx

; 1849 : 
; 1850 :                         points_guessed++; // this adds no measureable overhead

  003d7	8b 45 d8	 mov	 eax, DWORD PTR _points_guessed$[ebp]
  003da	83 c0 01	 add	 eax, 1
  003dd	89 45 d8	 mov	 DWORD PTR _points_guessed$[ebp], eax

; 1851 :                      }

  003e0	eb 3a		 jmp	 SHORT $LN35@man_calcul
$LN34@man_calcul:

; 1852 :                      else
; 1853 :                      {
; 1854 :                         ps_ptr->ab_in[0] = m->img_re[x]; // Load RE coordinate from the array

  003e2	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  003e5	8b 88 d4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36308]
  003eb	ba 08 00 00 00	 mov	 edx, 8
  003f0	6b c2 00	 imul	 eax, edx, 0
  003f3	8b 55 d0	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  003f6	8b 75 f4	 mov	 esi, DWORD PTR _x$[ebp]
  003f9	f2 0f 10 04 f1	 movsd	 xmm0, QWORD PTR [ecx+esi*8]
  003fe	f2 0f 11 84 02
	88 03 00 00	 movsd	 QWORD PTR [edx+eax+904], xmm0

; 1855 :                         m->queue_point(m, ps_ptr, iters_ptr);

  00407	8b 45 d4	 mov	 eax, DWORD PTR _iters_ptr$[ebp]
  0040a	50		 push	 eax
  0040b	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  0040e	8b 55 d0	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  00411	8b 4d c4	 mov	 ecx, DWORD PTR _m$[ebp]
  00414	8b 80 00 78 00
	00		 mov	 eax, DWORD PTR [eax+30720]
  0041a	ff d0		 call	 eax
$LN35@man_calcul:

; 1856 :                      }
; 1857 :                      iters_ptr += inc;

  0041c	8b 45 b8	 mov	 eax, DWORD PTR _inc$9[ebp]
  0041f	8b 4d d4	 mov	 ecx, DWORD PTR _iters_ptr$[ebp]
  00422	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00425	89 55 d4	 mov	 DWORD PTR _iters_ptr$[ebp], edx

; 1858 :                      x += inc;

  00428	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  0042b	03 45 b8	 add	 eax, DWORD PTR _inc$9[ebp]
  0042e	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax

; 1859 :                   }

  00431	e9 21 ff ff ff	 jmp	 $LN23@man_calcul
$LN24@man_calcul:

; 1860 :                }
; 1861 :                while ((y += inc) <= yend);

  00436	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00439	03 45 b8	 add	 eax, DWORD PTR _inc$9[ebp]
  0043c	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
  0043f	8b 4d f0	 mov	 ecx, DWORD PTR _y$[ebp]
  00442	3b 4d e0	 cmp	 ecx, DWORD PTR _yend$[ebp]
  00445	0f 8e c5 fe ff
	ff		 jle	 $LN22@man_calcul
$LN21@man_calcul:

; 1862 :             }
; 1863 :             // really should flush at the end of each wave, but any errors should have no visual effect
; 1864 :          }  // end of wave loop

  0044b	e9 5f fd ff ff	 jmp	 $LN11@man_calcul
$LN12@man_calcul:

; 1865 :       }
; 1866 :       s++;  // go to next stripe

  00450	8b 45 c8	 mov	 eax, DWORD PTR _s$[ebp]
  00453	83 c0 10	 add	 eax, 16			; 00000010H
  00456	89 45 c8	 mov	 DWORD PTR _s$[ebp], eax

; 1867 :    }        // end of stripe loop

  00459	e9 fa fb ff ff	 jmp	 $LN2@man_calcul
$LN3@man_calcul:

; 1868 : 
; 1869 :    t->total_iters += ps_ptr->iterctr;   // accumulate iters, for thread load balance measurement

  0045e	8b 45 cc	 mov	 eax, DWORD PTR _t$[ebp]
  00461	8b 4d d0	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00464	8b 90 98 00 00
	00		 mov	 edx, DWORD PTR [eax+152]
  0046a	03 91 80 03 00
	00		 add	 edx, DWORD PTR [ecx+896]
  00470	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [eax+156]
  00476	13 81 84 03 00
	00		 adc	 eax, DWORD PTR [ecx+900]
  0047c	8b 4d cc	 mov	 ecx, DWORD PTR _t$[ebp]
  0047f	89 91 98 00 00
	00		 mov	 DWORD PTR [ecx+152], edx
  00485	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 1870 :    t->points_guessed = points_guessed;

  0048b	8b 45 cc	 mov	 eax, DWORD PTR _t$[ebp]
  0048e	8b 4d d8	 mov	 ecx, DWORD PTR _points_guessed$[ebp]
  00491	89 88 a0 00 00
	00		 mov	 DWORD PTR [eax+160], ecx

; 1871 : 
; 1872 :    // Up to 4 points could be left in the queue (or 8 for SSE). Queue non-diverging dummy points
; 1873 :    // to flush them out. This is tricky. Be careful changing it... can cause corrupted pixel bugs.
; 1874 :    // Turns out that 4 more points (8 for SSE) must always be queued. They could be stored
; 1875 :    // to the dummy value if all points left in the queue still have max_iters remaining.
; 1876 : 
; 1877 :    ps_ptr->ab_in[0] = 0.0;

  00497	b8 08 00 00 00	 mov	 eax, 8
  0049c	6b c8 00	 imul	 ecx, eax, 0
  0049f	8b 55 d0	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  004a2	0f 57 c0	 xorps	 xmm0, xmm0
  004a5	f2 0f 11 84 0a
	88 03 00 00	 movsd	 QWORD PTR [edx+ecx+904], xmm0

; 1878 :    ps_ptr->ab_in[1] = 0.0;

  004ae	b8 08 00 00 00	 mov	 eax, 8
  004b3	c1 e0 00	 shl	 eax, 0
  004b6	8b 4d d0	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  004b9	0f 57 c0	 xorps	 xmm0, xmm0
  004bc	f2 0f 11 84 01
	88 03 00 00	 movsd	 QWORD PTR [ecx+eax+904], xmm0

; 1879 : 
; 1880 :    // Add some extra logic here to get the exact iteration count (i.e, exclude dummy iterations).
; 1881 :    // It's actually pretty tough to calculate
; 1882 :    for (i = m->precision == PRECISION_SINGLE ? 8 : 4; i--;)

  004c5	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  004c8	83 b8 d0 8d 00
	00 01		 cmp	 DWORD PTR [eax+36304], 1
  004cf	75 0c		 jne	 SHORT $LN38@man_calcul
  004d1	c7 85 54 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv262[ebp], 8
  004db	eb 0a		 jmp	 SHORT $LN39@man_calcul
$LN38@man_calcul:
  004dd	c7 85 54 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR tv262[ebp], 4
$LN39@man_calcul:
  004e7	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv262[ebp]
  004ed	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN25@man_calcul:
  004f0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  004f3	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv265[ebp], eax
  004f9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  004fc	83 e9 01	 sub	 ecx, 1
  004ff	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00502	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR tv265[ebp], 0
  00509	74 29		 je	 SHORT $LN26@man_calcul

; 1883 :       m->queue_point(m, ps_ptr, m->iter_data + m->image_size);

  0050b	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  0050e	8b 88 94 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36244]
  00514	8b 55 c4	 mov	 edx, DWORD PTR _m$[ebp]
  00517	8b 82 e0 8d 00
	00		 mov	 eax, DWORD PTR [edx+36320]
  0051d	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00520	51		 push	 ecx
  00521	8b 45 c4	 mov	 eax, DWORD PTR _m$[ebp]
  00524	8b 55 d0	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  00527	8b 4d c4	 mov	 ecx, DWORD PTR _m$[ebp]
  0052a	8b 80 00 78 00
	00		 mov	 eax, DWORD PTR [eax+30720]
  00530	ff d0		 call	 eax
  00532	eb bc		 jmp	 SHORT $LN25@man_calcul
$LN26@man_calcul:

; 1884 : 
; 1885 :    // Thread 0 always runs in the master thread, so doesn't need to signal. Save overhead.
; 1886 :    if (t->thread_num)

  00534	8b 45 cc	 mov	 eax, DWORD PTR _t$[ebp]
  00537	83 38 00	 cmp	 DWORD PTR [eax], 0
  0053a	74 10		 je	 SHORT $LN36@man_calcul

; 1887 :       SetEvent(t->done_event); // For other threads, signal master thread that we're done

  0053c	8b 45 cc	 mov	 eax, DWORD PTR _t$[ebp]
  0053f	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00545	51		 push	 ecx
  00546	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$LN36@man_calcul:

; 1888 : 
; 1889 :    return 0;

  0054c	33 c0		 xor	 eax, eax

; 1890 : }

  0054e	5f		 pop	 edi
  0054f	5e		 pop	 esi
  00550	5b		 pop	 ebx
  00551	8b e5		 mov	 esp, ebp
  00553	5d		 pop	 ebp
  00554	c2 04 00	 ret	 4
_man_calculate_threaded@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT @queue_8point_sse@12
_TEXT	SEGMENT
_m$ = -32						; size = 4
_ptr$ = -28						; size = 4
_queue_status$ = -24					; size = 4
_max$ = -20						; size = 4
_iters$ = -16						; size = 4
_i$ = -12						; size = 4
_ps_ptr$ = -8						; size = 4
_calc_struct$ = -4					; size = 4
_iters_ptr$ = 8						; size = 4
@queue_8point_sse@12 PROC				; COMDAT
; _calc_struct$ = ecx
; _ps_ptr$ = edx

; 1648 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 55 f8	 mov	 DWORD PTR _ps_ptr$[ebp], edx
  0000c	89 4d fc	 mov	 DWORD PTR _calc_struct$[ebp], ecx

; 1649 :    unsigned i, iters, max, queue_status, *ptr;
; 1650 :    man_calc_struct *m;
; 1651 : 
; 1652 :    m = (man_calc_struct *) calc_struct;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _calc_struct$[ebp]
  00012	89 45 e0	 mov	 DWORD PTR _m$[ebp], eax

; 1653 :    queue_status = ps_ptr->queue_status;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  00018	8b 88 9c 03 00
	00		 mov	 ecx, DWORD PTR [eax+924]
  0001e	89 4d e8	 mov	 DWORD PTR _queue_status$[ebp], ecx

; 1654 : 
; 1655 :    if (queue_status == QUEUE_FULL)

  00021	83 7d e8 0f	 cmp	 DWORD PTR _queue_status$[ebp], 15 ; 0000000fH
  00025	0f 85 2c 01 00
	00		 jne	 $LN5@

; 1656 :    {
; 1657 :       m->mandel_iterate(ps_ptr);

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d e0	 mov	 ecx, DWORD PTR _m$[ebp]
  00032	8b 91 04 78 00
	00		 mov	 edx, DWORD PTR [ecx+30724]
  00038	ff d2		 call	 edx
  0003a	83 c4 04	 add	 esp, 4

; 1658 : 
; 1659 :       max = 0;

  0003d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _max$[ebp], 0

; 1660 :       for (i = 0; i < 8; i++)

  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004b	eb 09		 jmp	 SHORT $LN4@
$LN2@:
  0004d	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@:
  00056	83 7d f4 08	 cmp	 DWORD PTR _i$[ebp], 8
  0005a	0f 83 e2 00 00
	00		 jae	 $LN3@

; 1661 :       {
; 1662 :          iters = ps_ptr->iters[i];

  00060	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00066	8b 94 81 c0 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+704]
  0006d	89 55 f0	 mov	 DWORD PTR _iters$[ebp], edx

; 1663 :          if (DIVERGED_S(ps_ptr, i))

  00070	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00076	81 bc 81 40 01
	00 00 00 00 80
	41		 cmp	 DWORD PTR [ecx+eax*4+320], 1098907648 ; 41800000H
  00081	7c 7e		 jl	 SHORT $LN6@

; 1664 :          {
; 1665 :             // *ps_ptr->iters_ptr[i] = iters - DIVERGED_PREV_S(ps_ptr, i);
; 1666 : 
; 1667 :             ptr = ps_ptr->iters_ptr[i];

  00083	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00086	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00089	8b 94 81 00 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+768]
  00090	89 55 e4	 mov	 DWORD PTR _ptr$[ebp], edx

; 1668 :             if (DIVERGED_PREV_S(ps_ptr, i))

  00093	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00099	81 bc 81 80 01
	00 00 00 00 80
	41		 cmp	 DWORD PTR [ecx+eax*4+384], 1098907648 ; 41800000H
  000a4	7c 29		 jl	 SHORT $LN8@

; 1669 :             {
; 1670 :                *ptr = iters - 1;

  000a6	8b 45 f0	 mov	 eax, DWORD PTR _iters$[ebp]
  000a9	83 e8 01	 sub	 eax, 1
  000ac	8b 4d e4	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000af	89 01		 mov	 DWORD PTR [ecx], eax

; 1671 :                MAG(m, ptr) = ((float *) ps_ptr->magprev)[i];

  000b1	8b 45 e0	 mov	 eax, DWORD PTR _m$[ebp]
  000b4	8b 88 ec 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36332]
  000ba	8b 55 e4	 mov	 edx, DWORD PTR _ptr$[ebp]
  000bd	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000c0	8b 75 f8	 mov	 esi, DWORD PTR _ps_ptr$[ebp]
  000c3	8b 84 86 80 01
	00 00		 mov	 eax, DWORD PTR [esi+eax*4+384]
  000ca	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 1672 :             }

  000cd	eb 24		 jmp	 SHORT $LN9@
$LN8@:

; 1673 :             else
; 1674 :             {
; 1675 :                *ptr = iters;

  000cf	8b 45 e4	 mov	 eax, DWORD PTR _ptr$[ebp]
  000d2	8b 4d f0	 mov	 ecx, DWORD PTR _iters$[ebp]
  000d5	89 08		 mov	 DWORD PTR [eax], ecx

; 1676 :                MAG(m, ptr) = ((float *) ps_ptr->mag)[i];

  000d7	8b 45 e0	 mov	 eax, DWORD PTR _m$[ebp]
  000da	8b 88 ec 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36332]
  000e0	8b 55 e4	 mov	 edx, DWORD PTR _ptr$[ebp]
  000e3	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000e6	8b 75 f8	 mov	 esi, DWORD PTR _ps_ptr$[ebp]
  000e9	8b 84 86 40 01
	00 00		 mov	 eax, DWORD PTR [esi+eax*4+320]
  000f0	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax
$LN9@:

; 1677 :             }
; 1678 :             queue_status = queue_status * 8 + i;

  000f3	8b 45 e8	 mov	 eax, DWORD PTR _queue_status$[ebp]
  000f6	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000f9	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  000fc	89 55 e8	 mov	 DWORD PTR _queue_status$[ebp], edx

; 1679 :          }

  000ff	eb 3c		 jmp	 SHORT $LN12@
$LN6@:

; 1680 :          else
; 1681 :             if (iters >= max)

  00101	8b 45 f0	 mov	 eax, DWORD PTR _iters$[ebp]
  00104	3b 45 ec	 cmp	 eax, DWORD PTR _max$[ebp]
  00107	72 34		 jb	 SHORT $LN12@

; 1682 :                if (iters == m->max_iters)

  00109	8b 45 e0	 mov	 eax, DWORD PTR _m$[ebp]
  0010c	8b 4d f0	 mov	 ecx, DWORD PTR _iters$[ebp]
  0010f	3b 88 c0 8d 00
	00		 cmp	 ecx, DWORD PTR [eax+36288]
  00115	75 20		 jne	 SHORT $LN11@

; 1683 :                {
; 1684 :                   *ps_ptr->iters_ptr[i] = iters;

  00117	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  0011d	8b 94 81 00 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+768]
  00124	8b 45 f0	 mov	 eax, DWORD PTR _iters$[ebp]
  00127	89 02		 mov	 DWORD PTR [edx], eax

; 1685 :                   queue_status = queue_status * 8 + i;

  00129	8b 45 e8	 mov	 eax, DWORD PTR _queue_status$[ebp]
  0012c	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0012f	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00132	89 55 e8	 mov	 DWORD PTR _queue_status$[ebp], edx

; 1686 :                }

  00135	eb 06		 jmp	 SHORT $LN12@
$LN11@:

; 1687 :                else
; 1688 :                   max = iters;

  00137	8b 45 f0	 mov	 eax, DWORD PTR _iters$[ebp]
  0013a	89 45 ec	 mov	 DWORD PTR _max$[ebp], eax
$LN12@:

; 1689 :       }

  0013d	e9 0b ff ff ff	 jmp	 $LN2@
$LN3@:

; 1690 :       ps_ptr->cur_max_iters = m->max_iters - max;

  00142	8b 45 e0	 mov	 eax, DWORD PTR _m$[ebp]
  00145	8b 88 c0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36288]
  0014b	2b 4d ec	 sub	 ecx, DWORD PTR _max$[ebp]
  0014e	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  00151	89 8a 98 03 00
	00		 mov	 DWORD PTR [edx+920], ecx
$LN5@:

; 1691 :    }
; 1692 : 
; 1693 :    i = queue_status & 7;

  00157	8b 45 e8	 mov	 eax, DWORD PTR _queue_status$[ebp]
  0015a	83 e0 07	 and	 eax, 7
  0015d	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax

; 1694 :    ps_ptr->queue_status = queue_status >> 3;

  00160	8b 45 e8	 mov	 eax, DWORD PTR _queue_status$[ebp]
  00163	c1 e8 03	 shr	 eax, 3
  00166	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00169	89 81 9c 03 00
	00		 mov	 DWORD PTR [ecx+924], eax

; 1695 : 
; 1696 :    // Initialize pointstruct fields as packed 32-bit floats
; 1697 :    ((float *) ps_ptr->a)[i] = (float) ps_ptr->ab_in[0];  // Set input point- convert from doubles

  0016f	b8 08 00 00 00	 mov	 eax, 8
  00174	6b c8 00	 imul	 ecx, eax, 0
  00177	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  0017a	f2 0f 5a 84 0a
	88 03 00 00	 cvtsd2ss xmm0, QWORD PTR [edx+ecx+904]
  00183	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00186	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00189	f3 0f 11 84 81
	c0 00 00 00	 movss	 DWORD PTR [ecx+eax*4+192], xmm0

; 1698 :    ((float *) ps_ptr->b)[i] = (float) ps_ptr->ab_in[1];  // generated by the main loop

  00192	b8 08 00 00 00	 mov	 eax, 8
  00197	c1 e0 00	 shl	 eax, 0
  0019a	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  0019d	f2 0f 5a 84 01
	88 03 00 00	 cvtsd2ss xmm0, QWORD PTR [ecx+eax+904]
  001a6	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  001a9	8b 45 f8	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  001ac	f3 0f 11 84 90
	00 01 00 00	 movss	 DWORD PTR [eax+edx*4+256], xmm0

; 1699 :    ((float *) ps_ptr->y)[i] = 0.0;                       // Set initial conditions

  001b5	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001b8	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  001bb	0f 57 c0	 xorps	 xmm0, xmm0
  001be	f3 0f 11 44 81
	40		 movss	 DWORD PTR [ecx+eax*4+64], xmm0

; 1700 :    ((float *) ps_ptr->x)[i] = 0.0;

  001c4	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001c7	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  001ca	0f 57 c0	 xorps	 xmm0, xmm0
  001cd	f3 0f 11 04 81	 movss	 DWORD PTR [ecx+eax*4], xmm0

; 1701 :    ((float *) ps_ptr->yy)[i] = 0.0;

  001d2	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001d5	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  001d8	0f 57 c0	 xorps	 xmm0, xmm0
  001db	f3 0f 11 84 81
	80 00 00 00	 movss	 DWORD PTR [ecx+eax*4+128], xmm0

; 1702 :    ps_ptr->iters[i] = 0;

  001e4	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001e7	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  001ea	c7 84 81 c0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+704], 0

; 1703 :    ps_ptr->iters_ptr[i] = iters_ptr;

  001f5	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001f8	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  001fb	8b 55 08	 mov	 edx, DWORD PTR _iters_ptr$[ebp]
  001fe	89 94 81 00 03
	00 00		 mov	 DWORD PTR [ecx+eax*4+768], edx

; 1704 : }

  00205	5f		 pop	 edi
  00206	5e		 pop	 esi
  00207	5b		 pop	 ebx
  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c2 04 00	 ret	 4
@queue_8point_sse@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT @queue_4point_sse2@12
_TEXT	SEGMENT
_m$ = -32						; size = 4
_ptr$ = -28						; size = 4
_queue_status$ = -24					; size = 4
_max$ = -20						; size = 4
_iters$ = -16						; size = 4
_i$ = -12						; size = 4
_ps_ptr$ = -8						; size = 4
_calc_struct$ = -4					; size = 4
_iters_ptr$ = 8						; size = 4
@queue_4point_sse2@12 PROC				; COMDAT
; _calc_struct$ = ecx
; _ps_ptr$ = edx

; 1566 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 55 f8	 mov	 DWORD PTR _ps_ptr$[ebp], edx
  0000c	89 4d fc	 mov	 DWORD PTR _calc_struct$[ebp], ecx

; 1567 :    unsigned i, iters, max, queue_status, *ptr;
; 1568 :    man_calc_struct *m;
; 1569 : 
; 1570 :    m = (man_calc_struct *) calc_struct;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _calc_struct$[ebp]
  00012	89 45 e0	 mov	 DWORD PTR _m$[ebp], eax

; 1571 : 
; 1572 :    queue_status = ps_ptr->queue_status;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  00018	8b 88 9c 03 00
	00		 mov	 ecx, DWORD PTR [eax+924]
  0001e	89 4d e8	 mov	 DWORD PTR _queue_status$[ebp], ecx

; 1573 : 
; 1574 :    if (queue_status == QUEUE_FULL) // If all points in use, iterate to clear at least one point first

  00021	83 7d e8 0f	 cmp	 DWORD PTR _queue_status$[ebp], 15 ; 0000000fH
  00025	0f 85 3c 01 00
	00		 jne	 $LN5@

; 1575 :    {
; 1576 :       m->mandel_iterate(ps_ptr);    // Returns (iters done) if any point hit max iterations, or diverged

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d e0	 mov	 ecx, DWORD PTR _m$[ebp]
  00032	8b 91 04 78 00
	00		 mov	 edx, DWORD PTR [ecx+30724]
  00038	ff d2		 call	 edx
  0003a	83 c4 04	 add	 esp, 4

; 1577 :       max = 0;

  0003d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _max$[ebp], 0

; 1578 :       for (i = 0; i < 4; i++) // compiler fully unrolls this

  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004b	eb 09		 jmp	 SHORT $LN4@
$LN2@:
  0004d	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@:
  00056	83 7d f4 04	 cmp	 DWORD PTR _i$[ebp], 4
  0005a	0f 83 f2 00 00
	00		 jae	 $LN3@

; 1579 :       {
; 1580 :          // Find which point(s) are done and retire them (store iteration count to array).
; 1581 :          // Iteration counts will later be mapped to colors using the current palette.
; 1582 :          // Timing test: removing array stores results in NO time savings on bmark.log.
; 1583 : 
; 1584 :          iters = ps_ptr->iters[i];

  00060	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00066	8b 94 81 c0 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+704]
  0006d	89 55 f0	 mov	 DWORD PTR _iters$[ebp], edx

; 1585 :          if (DIVERGED(ps_ptr, i))

  00070	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00073	d1 e0		 shl	 eax, 1
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00078	81 bc 81 44 01
	00 00 00 00 30
	40		 cmp	 DWORD PTR [ecx+eax*4+324], 1076887552 ; 40300000H
  00083	0f 8c 88 00 00
	00		 jl	 $LN6@

; 1586 :          {
; 1587 :             // If actually diverged on previous iteration, dec iters.
; 1588 :             // *ps_ptr->iters_ptr[i] = iters - DIVERGED_PREV(ps_ptr, i);
; 1589 : 
; 1590 :             // This is about 3% slower (with the branch and extra stores) than the old code (above).
; 1591 :             // Needed to get the correct magnitude for the normalized iteration count algorithm.
; 1592 : 
; 1593 :             ptr = ps_ptr->iters_ptr[i];

  00089	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  0008f	8b 94 81 00 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+768]
  00096	89 55 e4	 mov	 DWORD PTR _ptr$[ebp], edx

; 1594 :             if (DIVERGED_PREV(ps_ptr, i))

  00099	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0009c	d1 e0		 shl	 eax, 1
  0009e	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  000a1	81 bc 81 84 01
	00 00 00 00 30
	40		 cmp	 DWORD PTR [ecx+eax*4+388], 1076887552 ; 40300000H
  000ac	7c 2d		 jl	 SHORT $LN8@

; 1595 :             {
; 1596 :                *ptr = iters - 1;

  000ae	8b 45 f0	 mov	 eax, DWORD PTR _iters$[ebp]
  000b1	83 e8 01	 sub	 eax, 1
  000b4	8b 4d e4	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000b7	89 01		 mov	 DWORD PTR [ecx], eax

; 1597 :                MAG(m, ptr) = (float) ps_ptr->magprev[i];

  000b9	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000bc	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  000bf	f2 0f 5a 84 c1
	80 01 00 00	 cvtsd2ss xmm0, QWORD PTR [ecx+eax*8+384]
  000c8	8b 55 e0	 mov	 edx, DWORD PTR _m$[ebp]
  000cb	8b 82 ec 8d 00
	00		 mov	 eax, DWORD PTR [edx+36332]
  000d1	8b 4d e4	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000d4	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1598 :             }

  000d9	eb 28		 jmp	 SHORT $LN9@
$LN8@:

; 1599 :             else
; 1600 :             {
; 1601 :                *ptr = iters;

  000db	8b 45 e4	 mov	 eax, DWORD PTR _ptr$[ebp]
  000de	8b 4d f0	 mov	 ecx, DWORD PTR _iters$[ebp]
  000e1	89 08		 mov	 DWORD PTR [eax], ecx

; 1602 :                MAG(m, ptr) = (float) ps_ptr->mag[i];

  000e3	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000e6	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  000e9	f2 0f 5a 84 c1
	40 01 00 00	 cvtsd2ss xmm0, QWORD PTR [ecx+eax*8+320]
  000f2	8b 55 e0	 mov	 edx, DWORD PTR _m$[ebp]
  000f5	8b 82 ec 8d 00
	00		 mov	 eax, DWORD PTR [edx+36332]
  000fb	8b 4d e4	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000fe	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
$LN9@:

; 1603 :             }
; 1604 : 
; 1605 :             // Push free slot. Use this form to allow compiler to use the lea instruction
; 1606 :             queue_status = queue_status * 8 + i;

  00103	8b 45 e8	 mov	 eax, DWORD PTR _queue_status$[ebp]
  00106	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00109	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  0010c	89 55 e8	 mov	 DWORD PTR _queue_status$[ebp], edx

; 1607 :          }

  0010f	eb 3c		 jmp	 SHORT $LN12@
$LN6@:

; 1608 :          // Gets here most often. See if this point has the most accumulated iterations.
; 1609 :          // Also check if point reached max iters and retire if so. Definite overhead
; 1610 :          // improvement to combine the max iters check with the max check- measurable with
; 1611 :          // small max_iters (e.g., when realtime zooming)
; 1612 :          else
; 1613 :             if (iters >= max)

  00111	8b 45 f0	 mov	 eax, DWORD PTR _iters$[ebp]
  00114	3b 45 ec	 cmp	 eax, DWORD PTR _max$[ebp]
  00117	72 34		 jb	 SHORT $LN12@

; 1614 :                if (iters == m->max_iters)

  00119	8b 45 e0	 mov	 eax, DWORD PTR _m$[ebp]
  0011c	8b 4d f0	 mov	 ecx, DWORD PTR _iters$[ebp]
  0011f	3b 88 c0 8d 00
	00		 cmp	 ecx, DWORD PTR [eax+36288]
  00125	75 20		 jne	 SHORT $LN11@

; 1615 :                {
; 1616 :                   *ps_ptr->iters_ptr[i] = iters;         // don't need mag store for max_iters

  00127	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0012a	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  0012d	8b 94 81 00 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+768]
  00134	8b 45 f0	 mov	 eax, DWORD PTR _iters$[ebp]
  00137	89 02		 mov	 DWORD PTR [edx], eax

; 1617 :                   queue_status = queue_status * 8 + i;   // Push free slot

  00139	8b 45 e8	 mov	 eax, DWORD PTR _queue_status$[ebp]
  0013c	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0013f	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00142	89 55 e8	 mov	 DWORD PTR _queue_status$[ebp], edx

; 1618 :                }

  00145	eb 06		 jmp	 SHORT $LN12@
$LN11@:

; 1619 :                else
; 1620 :                   max = iters;

  00147	8b 45 f0	 mov	 eax, DWORD PTR _iters$[ebp]
  0014a	89 45 ec	 mov	 DWORD PTR _max$[ebp], eax
$LN12@:

; 1621 : 
; 1622 :       }

  0014d	e9 fb fe ff ff	 jmp	 $LN2@
$LN3@:

; 1623 :       // Set the maximum iterations to do next loop: max iters - iters already done.
; 1624 :       // The next loop must break if the point with the most accumulated iterations (max)
; 1625 :       // reaches max_iters.
; 1626 :       ps_ptr->cur_max_iters = m->max_iters - max;

  00152	8b 45 e0	 mov	 eax, DWORD PTR _m$[ebp]
  00155	8b 88 c0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36288]
  0015b	2b 4d ec	 sub	 ecx, DWORD PTR _max$[ebp]
  0015e	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  00161	89 8a 98 03 00
	00		 mov	 DWORD PTR [edx+920], ecx
$LN5@:

; 1627 : 
; 1628 :       // Most common case: comes here with one point free. Retiring multiple points only
; 1629 :       // happens about 1-5% of the time for complex images. For images with vast areas
; 1630 :       // of a single color, can go to 50%.
; 1631 :    }
; 1632 : 
; 1633 :    i = queue_status & 3;                     // Get next free slot

  00167	8b 45 e8	 mov	 eax, DWORD PTR _queue_status$[ebp]
  0016a	83 e0 03	 and	 eax, 3
  0016d	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax

; 1634 :    ps_ptr->queue_status = queue_status >> 3; // Pop free slot

  00170	8b 45 e8	 mov	 eax, DWORD PTR _queue_status$[ebp]
  00173	c1 e8 03	 shr	 eax, 3
  00176	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00179	89 81 9c 03 00
	00		 mov	 DWORD PTR [ecx+924], eax

; 1635 : 
; 1636 :    // Initialize pointstruct fields
; 1637 :    ps_ptr->a[i] = ps_ptr->ab_in[0]; // Set input point

  0017f	b8 08 00 00 00	 mov	 eax, 8
  00184	6b c8 00	 imul	 ecx, eax, 0
  00187	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0018a	8b 45 f8	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  0018d	8b 75 f8	 mov	 esi, DWORD PTR _ps_ptr$[ebp]
  00190	f2 0f 10 84 0e
	88 03 00 00	 movsd	 xmm0, QWORD PTR [esi+ecx+904]
  00199	f2 0f 11 84 d0
	c0 00 00 00	 movsd	 QWORD PTR [eax+edx*8+192], xmm0

; 1638 :    ps_ptr->b[i] = ps_ptr->ab_in[1];

  001a2	b8 08 00 00 00	 mov	 eax, 8
  001a7	c1 e0 00	 shl	 eax, 0
  001aa	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  001ad	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  001b0	8b 75 f8	 mov	 esi, DWORD PTR _ps_ptr$[ebp]
  001b3	f2 0f 10 84 06
	88 03 00 00	 movsd	 xmm0, QWORD PTR [esi+eax+904]
  001bc	f2 0f 11 84 ca
	00 01 00 00	 movsd	 QWORD PTR [edx+ecx*8+256], xmm0

; 1639 :    ps_ptr->y[i] = 0.0;              // Set initial conditions

  001c5	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001c8	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  001cb	0f 57 c0	 xorps	 xmm0, xmm0
  001ce	f2 0f 11 44 c1
	40		 movsd	 QWORD PTR [ecx+eax*8+64], xmm0

; 1640 :    ps_ptr->x[i] = 0.0;

  001d4	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001d7	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  001da	0f 57 c0	 xorps	 xmm0, xmm0
  001dd	f2 0f 11 04 c1	 movsd	 QWORD PTR [ecx+eax*8], xmm0

; 1641 :    ps_ptr->yy[i] = 0.0;

  001e2	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001e5	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  001e8	0f 57 c0	 xorps	 xmm0, xmm0
  001eb	f2 0f 11 84 c1
	80 00 00 00	 movsd	 QWORD PTR [ecx+eax*8+128], xmm0

; 1642 :    ps_ptr->iters[i] = 0;

  001f4	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001f7	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  001fa	c7 84 81 c0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+704], 0

; 1643 :    ps_ptr->iters_ptr[i] = iters_ptr;

  00205	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00208	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  0020b	8b 55 08	 mov	 edx, DWORD PTR _iters_ptr$[ebp]
  0020e	89 94 81 00 03
	00 00		 mov	 DWORD PTR [ecx+eax*4+768], edx

; 1644 : }

  00215	5f		 pop	 edi
  00216	5e		 pop	 esi
  00217	5b		 pop	 ebx
  00218	8b e5		 mov	 esp, ebp
  0021a	5d		 pop	 ebp
  0021b	c2 04 00	 ret	 4
@queue_4point_sse2@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _iterate_intel_sse
_TEXT	SEGMENT
_ps_ptr$ = 8						; size = 4
_iterate_intel_sse PROC					; COMDAT

; 1428 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1429 :    __asm
; 1430 :    {
; 1431 :    mov      ebx,           ps_ptr      // Get pointstruct pointer

  00009	8b 5d 08	 mov	 ebx, DWORD PTR _ps_ptr$[ebp]

; 1432 :    movaps   xmm_yy03,      PS8_YY03    // Restore point states

  0000c	0f 28 93 80 00
	00 00		 movaps	 xmm2, XMMWORD PTR [ebx+128]

; 1433 :    movaps   xmm_x47,       PS8_X47

  00013	0f 28 63 10	 movaps	 xmm4, XMMWORD PTR [ebx+16]

; 1434 :    movaps   xmm_x03,       PS8_X03

  00017	0f 28 03	 movaps	 xmm0, XMMWORD PTR [ebx]

; 1435 :    movaps   xmm_two,       PS8_TWO

  0001a	0f 28 bb 00 02
	00 00		 movaps	 xmm7, XMMWORD PTR [ebx+512]

; 1436 :    movaps   xmm_y47,       PS8_Y47

  00021	0f 28 6b 50	 movaps	 xmm5, XMMWORD PTR [ebx+80]

; 1437 :    movaps   xmm_y03,       PS8_Y03

  00025	0f 28 4b 40	 movaps	 xmm1, XMMWORD PTR [ebx+64]

; 1438 :    movaps   xmm_yy47,      PS8_YY47

  00029	0f 28 b3 90 00
	00 00		 movaps	 xmm6, XMMWORD PTR [ebx+144]

; 1439 :    addps    xmm_y03,       PS8_B03     // pre-add y03 to get correct initial condition

  00030	0f 58 8b 00 01
	00 00		 addps	 xmm1, XMMWORD PTR [ebx+256]

; 1440 : 
; 1441 :    mov      eax,           2           // iteration counter (for each of the 4 points)

  00037	b8 02 00 00 00	 mov	 eax, 2

; 1442 :    jmp      skip_top

  0003c	eb 0d		 jmp	 SHORT $skip_top$3
$iter_loop$4:

; 1443 : 
; 1444 : iter_loop:                             // alignment doesn't seem to matter on Intel
; 1445 :    movaps   PS8_YY03,      xmm_yy03    // save yy03 for mag backout checking

  0003e	0f 29 93 80 00
	00 00		 movaps	 XMMWORD PTR [ebx+128], xmm2

; 1446 :    movaps   PS8_X03,       xmm_x03     // save x03 for mag backout checking; contains xx03 - yy03 here

  00045	0f 29 03	 movaps	 XMMWORD PTR [ebx], xmm0

; 1447 :    add      eax,           2           // update iteration counter

  00048	83 c0 02	 add	 eax, 2
$skip_top$3:

; 1448 : skip_top:
; 1449 :    mulps    xmm_x47,       xmm_x47     // x47 *= x47

  0004b	0f 59 e4	 mulps	 xmm4, xmm4

; 1450 :    addps    xmm_x03,       PS8_A03     // x03 += a03

  0004e	0f 58 83 c0 00
	00 00		 addps	 xmm0, XMMWORD PTR [ebx+192]

; 1451 :    addps    xmm_y47,       xmm_y47     // y47 *= 2; faster here than mulps xmm_y47, xmm_two

  00055	0f 58 ed	 addps	 xmm5, xmm5

; 1452 :    movaps   xmm_yy03,      xmm_y03     // yy03 = y03

  00058	0f 28 d1	 movaps	 xmm2, xmm1

; 1453 :    movaps   PS8_X47,       xmm_x47     // save xx47 for magnitude backout checking

  0005b	0f 29 63 10	 movaps	 XMMWORD PTR [ebx+16], xmm4

; 1454 :    mulps    xmm_yy03,      xmm_yy03    // yy03 *= yy03

  0005f	0f 59 d2	 mulps	 xmm2, xmm2

; 1455 :    subps    xmm_x47,       xmm_yy47    // x47 -= yy47

  00062	0f 5c e6	 subps	 xmm4, xmm6

; 1456 :    mulps    xmm_y03,       xmm_x03     // y03 *= x03

  00065	0f 59 c8	 mulps	 xmm1, xmm0

; 1457 :    addps    xmm_y47,       PS8_B47     // y47 += b47

  00068	0f 58 ab 10 01
	00 00		 addps	 xmm5, XMMWORD PTR [ebx+272]

; 1458 :    mulps    xmm_x03,       xmm_x03     // x03 *= x03

  0006f	0f 59 c0	 mulps	 xmm0, xmm0

; 1459 :    movaps   PS8_YY47,      xmm_yy47    // save yy47 for magnitude backout checking

  00072	0f 29 b3 90 00
	00 00		 movaps	 XMMWORD PTR [ebx+144], xmm6

; 1460 :    mulps    xmm_y03,       xmm_two     // y03 *= 2; add slower here

  00079	0f 59 cf	 mulps	 xmm1, xmm7

; 1461 :    addps    xmm_x47,       PS8_A47     // x47 += a47

  0007c	0f 58 a3 d0 00
	00 00		 addps	 xmm4, XMMWORD PTR [ebx+208]

; 1462 :    movaps   xmm_mag,       xmm_x03     // mag03 = x03

  00083	0f 28 d8	 movaps	 xmm3, xmm0

; 1463 :    movaps   xmm_yy47,      xmm_y47     // yy47 = y47

  00086	0f 28 f5	 movaps	 xmm6, xmm5

; 1464 :    subps    xmm_x03,       xmm_yy03    // x03 -= yy03

  00089	0f 5c c2	 subps	 xmm0, xmm2

; 1465 :    mulps    xmm_yy47,      xmm_yy47    // yy47 *= yy47

  0008c	0f 59 f6	 mulps	 xmm6, xmm6

; 1466 :    addps    xmm_y03,       PS8_B03     // y03 += b03

  0008f	0f 58 8b 00 01
	00 00		 addps	 xmm1, XMMWORD PTR [ebx+256]

; 1467 :    mulps    xmm_y47,       xmm_x47     // y47 *= x47

  00096	0f 59 ec	 mulps	 xmm5, xmm4

; 1468 :    // ----- Start of 2nd iteration block ------
; 1469 :    addps    xmm_mag,       xmm_yy03

  00099	0f 58 da	 addps	 xmm3, xmm2

; 1470 :    mulps    xmm_x47,       xmm_x47

  0009c	0f 59 e4	 mulps	 xmm4, xmm4

; 1471 :    addps    xmm_x03,       PS8_A03

  0009f	0f 58 83 c0 00
	00 00		 addps	 xmm0, XMMWORD PTR [ebx+192]

; 1472 :    mulps    xmm_y47,       xmm_two

  000a6	0f 59 ef	 mulps	 xmm5, xmm7

; 1473 :    movaps   xmm_yy03,      xmm_y03

  000a9	0f 28 d1	 movaps	 xmm2, xmm1

; 1474 :    movapd   PS8_MAG03,     xmm_mag     // new, mag store for normalized iteration count alg -- not much effect on speed

  000ac	66 0f 29 9b 40
	01 00 00	 movapd	 XMMWORD PTR [ebx+320], xmm3

; 1475 :    cmpnltps xmm_mag,       PS8_RAD     // compare point 0-3 magnitudes (mag >= rad): let cpu reorder these

  000b4	0f c2 9b 80 02
	00 00 05	 cmpnltps xmm3, XMMWORD PTR [ebx+640]

; 1476 :    movmskps edx,           xmm_mag     // save result in edx

  000bc	0f 50 d3	 movmskps edx, xmm3

; 1477 :    movaps   xmm_mag,       xmm_x47

  000bf	0f 28 dc	 movaps	 xmm3, xmm4

; 1478 :    mulps    xmm_yy03,      xmm_yy03

  000c2	0f 59 d2	 mulps	 xmm2, xmm2

; 1479 :    subps    xmm_x47,       xmm_yy47

  000c5	0f 5c e6	 subps	 xmm4, xmm6

; 1480 :    mulps    xmm_y03,       xmm_x03

  000c8	0f 59 c8	 mulps	 xmm1, xmm0

; 1481 :    addps    xmm_y47,       PS8_B47

  000cb	0f 58 ab 10 01
	00 00		 addps	 xmm5, XMMWORD PTR [ebx+272]

; 1482 :    mulps    xmm_x03,       xmm_x03

  000d2	0f 59 c0	 mulps	 xmm0, xmm0

; 1483 :    addps    xmm_mag,       xmm_yy47

  000d5	0f 58 de	 addps	 xmm3, xmm6

; 1484 :    mulps    xmm_y03,       xmm_two

  000d8	0f 59 cf	 mulps	 xmm1, xmm7

; 1485 :    addps    xmm_x47,       PS8_A47

  000db	0f 58 a3 d0 00
	00 00		 addps	 xmm4, XMMWORD PTR [ebx+208]

; 1486 :    shl      edx,           4           // shift point 0-3 mag compare results left 4

  000e2	c1 e2 04	 shl	 edx, 4

; 1487 :    movaps   xmm_yy47,      xmm_y47

  000e5	0f 28 f5	 movaps	 xmm6, xmm5

; 1488 :    subps    xmm_x03,       xmm_yy03

  000e8	0f 5c c2	 subps	 xmm0, xmm2

; 1489 :    movapd   PS8_MAG47,     xmm_mag     // new, mag store for normalized iteration count alg -- not much effect on speed

  000eb	66 0f 29 9b 50
	01 00 00	 movapd	 XMMWORD PTR [ebx+336], xmm3

; 1490 :    cmpnltps xmm_mag,       PS8_RAD     // compare point 4-7 magnitudes

  000f3	0f c2 9b 80 02
	00 00 05	 cmpnltps xmm3, XMMWORD PTR [ebx+640]

; 1491 :    mulps    xmm_yy47,      xmm_yy47

  000fb	0f 59 f6	 mulps	 xmm6, xmm6

; 1492 :    addps    xmm_y03,       PS8_B03

  000fe	0f 58 8b 00 01
	00 00		 addps	 xmm1, XMMWORD PTR [ebx+256]

; 1493 :    movmskps ecx,           xmm_mag

  00105	0f 50 cb	 movmskps ecx, xmm3

; 1494 :    mulps    xmm_y47,       xmm_x47

  00108	0f 59 ec	 mulps	 xmm5, xmm4

; 1495 :    or       ecx,           edx         // Continue iterating until max iters reached for this call,

  0010b	0b ca		 or	 ecx, edx

; 1496 :    jnz      done                       // or one of the points diverged.

  0010d	75 0c		 jne	 SHORT $done$5

; 1497 :    cmp      PS8_CUR_MAX_ITERS, eax     // No penalty for comparing from memory vs. register here

  0010f	39 83 98 03 00
	00		 cmp	 DWORD PTR [ebx+920], eax

; 1498 :    jne      iter_loop

  00115	0f 85 23 ff ff
	ff		 jne	 $iter_loop$4
$done$5:

; 1499 : 
; 1500 :  done:
; 1501 :    subps    xmm_y03,       PS8_B03     // subtract out pre-add (see loop top)

  0011b	0f 5c 8b 00 01
	00 00		 subps	 xmm1, XMMWORD PTR [ebx+256]

; 1502 :    movaps   PS8_Y03,       xmm_y03     // save y03 state

  00122	0f 29 4b 40	 movaps	 XMMWORD PTR [ebx+64], xmm1

; 1503 :    movaps   PS8_Y47,       xmm_y47     // save y47 state

  00126	0f 29 6b 50	 movaps	 XMMWORD PTR [ebx+80], xmm5

; 1504 : 
; 1505 :    // Get previous magnitudes. See AMD SSE2 code
; 1506 :    mulps    xmm_two,       PS8_YY03    // Use xmm_two for tmp var; tmp1 = 2 * yy03

  0012a	0f 59 bb 80 00
	00 00		 mulps	 xmm7, XMMWORD PTR [ebx+128]

; 1507 :    movaps   xmm_mag,       PS8_X47     // tmp2 = xx47

  00131	0f 28 5b 10	 movaps	 xmm3, XMMWORD PTR [ebx+16]

; 1508 :    addps    xmm_two,       PS8_X03     // get mag03 = xx03 - yy03 + 2 * yy03 = xx03 + yy03

  00135	0f 58 3b	 addps	 xmm7, XMMWORD PTR [ebx]

; 1509 :    addps    xmm_mag,       PS8_YY47    // get mag47 = xx47 + yy47

  00138	0f 58 9b 90 00
	00 00		 addps	 xmm3, XMMWORD PTR [ebx+144]

; 1510 :    movaps   PS8_MAGPREV03, xmm_two     // store prev_mag 03

  0013f	0f 29 bb 80 01
	00 00		 movaps	 XMMWORD PTR [ebx+384], xmm7

; 1511 :    movaps   PS8_MAGPREV47, xmm_mag     // store prev_mag 47

  00146	0f 29 9b 90 01
	00 00		 movaps	 XMMWORD PTR [ebx+400], xmm3

; 1512 : 
; 1513 :    xor      edx,           edx         // Get a 0

  0014d	33 d2		 xor	 edx, edx

; 1514 :    add      PS8_ITERCTR_L, eax         // Update iteration counter. Multiply by 72 to get effective flops.

  0014f	01 83 80 03 00
	00		 add	 DWORD PTR [ebx+896], eax

; 1515 :    adc      PS8_ITERCTR_H, edx         // Update iterctr high dword

  00155	11 93 84 03 00
	00		 adc	 DWORD PTR [ebx+900], edx

; 1516 : 
; 1517 :    movaps   PS8_YY03,      xmm_yy03    // save yy03 state

  0015b	0f 29 93 80 00
	00 00		 movaps	 XMMWORD PTR [ebx+128], xmm2

; 1518 :    movaps   PS8_X47,       xmm_x47     // save x47 state

  00162	0f 29 63 10	 movaps	 XMMWORD PTR [ebx+16], xmm4

; 1519 :    movaps   PS8_X03,       xmm_x03     // save x03 state

  00166	0f 29 03	 movaps	 XMMWORD PTR [ebx], xmm0

; 1520 :    movaps   PS8_YY47,      xmm_yy47    // save yy47 state

  00169	0f 29 b3 90 00
	00 00		 movaps	 XMMWORD PTR [ebx+144], xmm6

; 1521 : 
; 1522 :    add      PS8_ITERS0,    eax         // update point iteration counts

  00170	01 83 c0 02 00
	00		 add	 DWORD PTR [ebx+704], eax

; 1523 :    add      PS8_ITERS1,    eax

  00176	01 83 c4 02 00
	00		 add	 DWORD PTR [ebx+708], eax

; 1524 :    add      PS8_ITERS2,    eax

  0017c	01 83 c8 02 00
	00		 add	 DWORD PTR [ebx+712], eax

; 1525 :    add      PS8_ITERS3,    eax

  00182	01 83 cc 02 00
	00		 add	 DWORD PTR [ebx+716], eax

; 1526 :    add      PS8_ITERS4,    eax

  00188	01 83 d0 02 00
	00		 add	 DWORD PTR [ebx+720], eax

; 1527 :    add      PS8_ITERS5,    eax

  0018e	01 83 d4 02 00
	00		 add	 DWORD PTR [ebx+724], eax

; 1528 :    add      PS8_ITERS6,    eax

  00194	01 83 d8 02 00
	00		 add	 DWORD PTR [ebx+728], eax

; 1529 :    add      PS8_ITERS7,    eax

  0019a	01 83 dc 02 00
	00		 add	 DWORD PTR [ebx+732], eax

; 1530 :    }
; 1531 : }

  001a0	5f		 pop	 edi
  001a1	5e		 pop	 esi
  001a2	5b		 pop	 ebx
  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c3		 ret	 0
_iterate_intel_sse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _iterate_amd_sse
_TEXT	SEGMENT
_ps_ptr$ = 8						; size = 4
_iterate_amd_sse PROC					; COMDAT

; 1301 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1302 :    __asm
; 1303 :    {
; 1304 :    mov      ebx,           ps_ptr            // Get pointstruct pointer

  00009	8b 5d 08	 mov	 ebx, DWORD PTR _ps_ptr$[ebp]

; 1305 :    movaps   xmm_x47,       PS8_X47           // Restore point states

  0000c	0f 28 63 10	 movaps	 xmm4, XMMWORD PTR [ebx+16]

; 1306 :    movaps   xmm_x03,       PS8_X03

  00010	0f 28 03	 movaps	 xmm0, XMMWORD PTR [ebx]

; 1307 :    movaps   xmm_two,       PS8_TWO

  00013	0f 28 bb 00 02
	00 00		 movaps	 xmm7, XMMWORD PTR [ebx+512]

; 1308 :    movaps   xmm_y47,       PS8_Y47

  0001a	0f 28 6b 50	 movaps	 xmm5, XMMWORD PTR [ebx+80]

; 1309 :    movaps   xmm_y03,       PS8_Y03

  0001e	0f 28 4b 40	 movaps	 xmm1, XMMWORD PTR [ebx+64]

; 1310 :    movaps   xmm_yy47,      PS8_YY47

  00022	0f 28 b3 90 00
	00 00		 movaps	 xmm6, XMMWORD PTR [ebx+144]

; 1311 : 
; 1312 :    mov      edx,           DIV_EXP_FLOAT     // Exp for magnitude exponent comparison. Slower to compare to const directly

  00029	ba 00 00 80 41	 mov	 edx, 1098907648		; 41800000H

; 1313 :    mov      ecx,           PS8_CUR_MAX_ITERS // max iters to do this call; always even

  0002e	8b 8b 98 03 00
	00		 mov	 ecx, DWORD PTR [ebx+920]

; 1314 :    mov      eax,           0                 // Iteration counter (for each of the 4 points)

  00034	b8 00 00 00 00	 mov	 eax, 0

; 1315 :    jmp      skip_top                         // Allows removing yy03 restore above

  00039	eb 13		 jmp	 SHORT $skip_top$3

; 1316 :    nop

  0003b	90		 npad	 1

; 1317 :    nop                                       // Achieve the magic alignment...

  0003c	90		 npad	 1

; 1318 :    nop

  0003d	90		 npad	 1

; 1319 :    nop

  0003e	90		 npad	 1

; 1320 :    nop

  0003f	90		 npad	 1

; 1321 :    nop

  00040	90		 npad	 1

; 1322 :    nop

  00041	90		 npad	 1

; 1323 :    nop

  00042	90		 npad	 1

; 1324 :    nop

  00043	90		 npad	 1
$iter_loop$4:

; 1325 : 
; 1326 : iter_loop:
; 1327 :    movaps   PS8_YY03,      xmm_yy03    // save yy03 for mag backout checking

  00044	0f 29 93 80 00
	00 00		 movaps	 XMMWORD PTR [ebx+128], xmm2

; 1328 :    movaps   PS8_X03,       xmm_x03     // save x03 for mag backout checking; contains xx03 - yy03 here

  0004b	0f 29 03	 movaps	 XMMWORD PTR [ebx], xmm0
$skip_top$3:

; 1329 : skip_top:
; 1330 :    addps    xmm_y03,       PS8_B03     // y03 += b03; faster at top of loop. Initial y03 = 0

  0004e	0f 58 8b 00 01
	00 00		 addps	 xmm1, XMMWORD PTR [ebx+256]

; 1331 :    mulps    xmm_y47,       xmm_x47     // y47 *= x47; faster at top of loop.

  00055	0f 59 ec	 mulps	 xmm5, xmm4

; 1332 :    add      eax,           2           // update iteration counter; faster here than 2 insts below

  00058	83 c0 02	 add	 eax, 2

; 1333 :    mulps    xmm_x47,       xmm_x47     // x47 *= x47

  0005b	0f 59 e4	 mulps	 xmm4, xmm4

; 1334 :    addps    xmm_x03,       PS8_A03     // x03 += a03

  0005e	0f 58 83 c0 00
	00 00		 addps	 xmm0, XMMWORD PTR [ebx+192]

; 1335 :    addps    xmm_y47,       xmm_y47     // y47 *= 2; faster here than mulps xmm_y47, xmm_two

  00065	0f 58 ed	 addps	 xmm5, xmm5

; 1336 :    movaps   xmm_yy03,      xmm_y03     // yy03 = y03

  00068	0f 28 d1	 movaps	 xmm2, xmm1

; 1337 :    movaps   PS8_X47,       xmm_x47     // save xx47 for magnitude backout checking

  0006b	0f 29 63 10	 movaps	 XMMWORD PTR [ebx+16], xmm4

; 1338 :    mulps    xmm_yy03,      xmm_yy03    // yy03 *= yy03

  0006f	0f 59 d2	 mulps	 xmm2, xmm2

; 1339 :    subps    xmm_x47,       xmm_yy47    // x47 -= yy47

  00072	0f 5c e6	 subps	 xmm4, xmm6

; 1340 :    mulps    xmm_y03,       xmm_x03     // y03 *= x03

  00075	0f 59 c8	 mulps	 xmm1, xmm0

; 1341 :    addps    xmm_y47,       PS8_B47     // y47 += b47

  00078	0f 58 ab 10 01
	00 00		 addps	 xmm5, XMMWORD PTR [ebx+272]

; 1342 :    mulps    xmm_x03,       xmm_x03     // x03 *= x03

  0007f	0f 59 c0	 mulps	 xmm0, xmm0

; 1343 :    movaps   PS8_YY47,      xmm_yy47    // save yy47 for magnitude backout checking

  00082	0f 29 b3 90 00
	00 00		 movaps	 XMMWORD PTR [ebx+144], xmm6

; 1344 :    mulps    xmm_y03,       xmm_two     // y03 *= 2; add slower here; bb stall

  00089	0f 59 cf	 mulps	 xmm1, xmm7

; 1345 :    addps    xmm_x47,       PS8_A47     // x47 += a47

  0008c	0f 58 a3 d0 00
	00 00		 addps	 xmm4, XMMWORD PTR [ebx+208]

; 1346 :    movaps   xmm_mag,       xmm_x03     // mag03 = x03

  00093	0f 28 d8	 movaps	 xmm3, xmm0

; 1347 :    movaps   xmm_yy47,      xmm_y47     // yy47 = y47

  00096	0f 28 f5	 movaps	 xmm6, xmm5

; 1348 :    subps    xmm_x03,       xmm_yy03    // x03 -= yy03

  00099	0f 5c c2	 subps	 xmm0, xmm2

; 1349 :    mulps    xmm_yy47,      xmm_yy47    // yy47 *= yy47

  0009c	0f 59 f6	 mulps	 xmm6, xmm6

; 1350 :    addps    xmm_y03,       PS8_B03     // y03 += b03

  0009f	0f 58 8b 00 01
	00 00		 addps	 xmm1, XMMWORD PTR [ebx+256]

; 1351 :    mulps    xmm_y47,       xmm_x47     // y47 *= x47

  000a6	0f 59 ec	 mulps	 xmm5, xmm4

; 1352 :    // ----- Start of 2nd iteration block ------
; 1353 :    addps    xmm_mag,       xmm_yy03

  000a9	0f 58 da	 addps	 xmm3, xmm2

; 1354 :    mulps    xmm_x47,       xmm_x47

  000ac	0f 59 e4	 mulps	 xmm4, xmm4

; 1355 :    addps    xmm_x03,       PS8_A03

  000af	0f 58 83 c0 00
	00 00		 addps	 xmm0, XMMWORD PTR [ebx+192]

; 1356 :    movaps   xmm_yy03,      xmm_y03     // these 2 instrs: faster in this order than reversed (fixes y47 dep?)

  000b6	0f 28 d1	 movaps	 xmm2, xmm1

; 1357 :    mulps    xmm_y47,       xmm_two     // (yy03 is apparently just "marked" to get y03 here; doesn't cause a dep delay)

  000b9	0f 59 ef	 mulps	 xmm5, xmm7

; 1358 :    movaps   PS8_MAG03,     xmm_mag     // save point 0-3 magnitudes for comparison

  000bc	0f 29 9b 40 01
	00 00		 movaps	 XMMWORD PTR [ebx+320], xmm3

; 1359 :    movaps   xmm_mag,       xmm_x47

  000c3	0f 28 dc	 movaps	 xmm3, xmm4

; 1360 :    mulps    xmm_yy03,      xmm_yy03

  000c6	0f 59 d2	 mulps	 xmm2, xmm2

; 1361 :    subps    xmm_x47,       xmm_yy47

  000c9	0f 5c e6	 subps	 xmm4, xmm6

; 1362 :    mulps    xmm_y03,       xmm_x03

  000cc	0f 59 c8	 mulps	 xmm1, xmm0

; 1363 :    addps    xmm_y47,       PS8_B47

  000cf	0f 58 ab 10 01
	00 00		 addps	 xmm5, XMMWORD PTR [ebx+272]

; 1364 :    mulps    xmm_x03,       xmm_x03

  000d6	0f 59 c0	 mulps	 xmm0, xmm0

; 1365 :    addps    xmm_mag,       xmm_yy47

  000d9	0f 58 de	 addps	 xmm3, xmm6

; 1366 :    movaps   PS8_MAG47,     xmm_mag     // Save point 4-7 magnitudes. Best here, despite dep

  000dc	0f 29 9b 50 01
	00 00		 movaps	 XMMWORD PTR [ebx+336], xmm3

; 1367 :    cmp      PS8_MEXP0,     edx         // Compare the magnitude exponents of points 0-3

  000e3	39 93 40 01 00
	00		 cmp	 DWORD PTR [ebx+320], edx

; 1368 :    cmovge   ecx,           eax         // to the divergence threshold. AMD doesn't seem to mind

  000e9	0f 4d c8	 cmovge	 ecx, eax

; 1369 :    cmp      PS8_MEXP1,     edx         // the store fowarding issue, but Intel does.

  000ec	39 93 44 01 00
	00		 cmp	 DWORD PTR [ebx+324], edx

; 1370 :    cmovge   ecx,           eax         // Conditional moves set ecx to eax on divergence,

  000f2	0f 4d c8	 cmovge	 ecx, eax

; 1371 :    cmp      PS8_MEXP2,     edx         // breaking the loop.

  000f5	39 93 48 01 00
	00		 cmp	 DWORD PTR [ebx+328], edx

; 1372 :    cmovge   ecx,           eax

  000fb	0f 4d c8	 cmovge	 ecx, eax

; 1373 :    cmp      PS8_MEXP3,     edx

  000fe	39 93 4c 01 00
	00		 cmp	 DWORD PTR [ebx+332], edx

; 1374 :    cmovge   ecx,           eax

  00104	0f 4d c8	 cmovge	 ecx, eax

; 1375 :    mulps    xmm_y03,       xmm_two     // add y, y and mul y, two seem equal speed here

  00107	0f 59 cf	 mulps	 xmm1, xmm7

; 1376 :    addps    xmm_x47,       PS8_A47

  0010a	0f 58 a3 d0 00
	00 00		 addps	 xmm4, XMMWORD PTR [ebx+208]

; 1377 :    movaps   xmm_yy47,      xmm_y47

  00111	0f 28 f5	 movaps	 xmm6, xmm5

; 1378 :    subps    xmm_x03,       xmm_yy03

  00114	0f 5c c2	 subps	 xmm0, xmm2

; 1379 :    mulps    xmm_yy47,      xmm_yy47

  00117	0f 59 f6	 mulps	 xmm6, xmm6

; 1380 :    cmp      PS8_MEXP4,     edx         // Compare the magnitude exponents of points 4-7.

  0011a	39 93 50 01 00
	00		 cmp	 DWORD PTR [ebx+336], edx

; 1381 :    cmovge   ecx,           eax

  00120	0f 4d c8	 cmovge	 ecx, eax

; 1382 :    cmp      PS8_MEXP5,     edx

  00123	39 93 54 01 00
	00		 cmp	 DWORD PTR [ebx+340], edx

; 1383 :    cmovge   ecx,           eax

  00129	0f 4d c8	 cmovge	 ecx, eax

; 1384 :    cmp      PS8_MEXP6,     edx

  0012c	39 93 58 01 00
	00		 cmp	 DWORD PTR [ebx+344], edx

; 1385 :    cmovge   ecx,           eax

  00132	0f 4d c8	 cmovge	 ecx, eax

; 1386 :    cmp      PS8_MEXP7,     edx

  00135	39 93 5c 01 00
	00		 cmp	 DWORD PTR [ebx+348], edx

; 1387 :    //cmovge   ecx,           eax       // jge done seems a hair faster. When changing instrs, don't forget
; 1388 :    jge      done                       // to adjust nops to put jne iter_loop on a 16-byte boundary.

  0013b	7d 08		 jge	 SHORT $done$5

; 1389 :    cmp      ecx,           eax         // Continue iterating until max iters reached for this call,

  0013d	3b c8		 cmp	 ecx, eax

; 1390 :    jne      iter_loop                  // or one of the points diverged.

  0013f	0f 85 ff fe ff
	ff		 jne	 $iter_loop$4
$done$5:

; 1391 : 
; 1392 : done:
; 1393 :    // Get previous magnitudes. See AMD SSE2 code
; 1394 :    movaps   PS8_Y03,       xmm_y03     // save y03 state

  00145	0f 29 4b 40	 movaps	 XMMWORD PTR [ebx+64], xmm1

; 1395 :    movaps   PS8_Y47,       xmm_y47     // save y47 state

  00149	0f 29 6b 50	 movaps	 XMMWORD PTR [ebx+80], xmm5

; 1396 : 
; 1397 :    mulps    xmm_two,       PS8_YY03    // Use xmm_two for tmp var; tmp1 = 2 * yy03

  0014d	0f 59 bb 80 00
	00 00		 mulps	 xmm7, XMMWORD PTR [ebx+128]

; 1398 :    movaps   xmm_mag,       PS8_X47     // tmp2 = xx47

  00154	0f 28 5b 10	 movaps	 xmm3, XMMWORD PTR [ebx+16]

; 1399 :    addps    xmm_two,       PS8_X03     // get mag03 = xx03 - yy03 + 2 * yy03 = xx03 + yy03

  00158	0f 58 3b	 addps	 xmm7, XMMWORD PTR [ebx]

; 1400 :    addps    xmm_mag,       PS8_YY47    // get mag47 = xx47 + yy47

  0015b	0f 58 9b 90 00
	00 00		 addps	 xmm3, XMMWORD PTR [ebx+144]

; 1401 :    movaps   PS8_MAGPREV03, xmm_two     // store prev_mag 03

  00162	0f 29 bb 80 01
	00 00		 movaps	 XMMWORD PTR [ebx+384], xmm7

; 1402 :    movaps   PS8_MAGPREV47, xmm_mag     // store prev_mag 47

  00169	0f 29 9b 90 01
	00 00		 movaps	 XMMWORD PTR [ebx+400], xmm3

; 1403 : 
; 1404 :    xor      ecx,           ecx         // Get a 0

  00170	33 c9		 xor	 ecx, ecx

; 1405 :    add      PS8_ITERCTR_L, eax         // Update iteration counter. Multiply by 72 to get effective flops.

  00172	01 83 80 03 00
	00		 add	 DWORD PTR [ebx+896], eax

; 1406 :    adc      PS8_ITERCTR_H, ecx         // Update iterctr high dword

  00178	11 8b 84 03 00
	00		 adc	 DWORD PTR [ebx+900], ecx

; 1407 : 
; 1408 :    movaps   PS8_YY03,      xmm_yy03    // save yy03 state

  0017e	0f 29 93 80 00
	00 00		 movaps	 XMMWORD PTR [ebx+128], xmm2

; 1409 :    movaps   PS8_X47,       xmm_x47     // save x47 state

  00185	0f 29 63 10	 movaps	 XMMWORD PTR [ebx+16], xmm4

; 1410 :    movaps   PS8_X03,       xmm_x03     // save x03 state

  00189	0f 29 03	 movaps	 XMMWORD PTR [ebx], xmm0

; 1411 :    movaps   PS8_YY47,      xmm_yy47    // save yy47 state

  0018c	0f 29 b3 90 00
	00 00		 movaps	 XMMWORD PTR [ebx+144], xmm6

; 1412 : 
; 1413 :    add      PS8_ITERS0,    eax         // update point iteration counts

  00193	01 83 c0 02 00
	00		 add	 DWORD PTR [ebx+704], eax

; 1414 :    add      PS8_ITERS1,    eax

  00199	01 83 c4 02 00
	00		 add	 DWORD PTR [ebx+708], eax

; 1415 :    add      PS8_ITERS2,    eax

  0019f	01 83 c8 02 00
	00		 add	 DWORD PTR [ebx+712], eax

; 1416 :    add      PS8_ITERS3,    eax

  001a5	01 83 cc 02 00
	00		 add	 DWORD PTR [ebx+716], eax

; 1417 :    add      PS8_ITERS4,    eax

  001ab	01 83 d0 02 00
	00		 add	 DWORD PTR [ebx+720], eax

; 1418 :    add      PS8_ITERS5,    eax

  001b1	01 83 d4 02 00
	00		 add	 DWORD PTR [ebx+724], eax

; 1419 :    add      PS8_ITERS6,    eax

  001b7	01 83 d8 02 00
	00		 add	 DWORD PTR [ebx+728], eax

; 1420 :    add      PS8_ITERS7,    eax

  001bd	01 83 dc 02 00
	00		 add	 DWORD PTR [ebx+732], eax

; 1421 :    // return value (iterations done per point) is in eax
; 1422 :    }
; 1423 : }

  001c3	5f		 pop	 edi
  001c4	5e		 pop	 esi
  001c5	5b		 pop	 ebx
  001c6	8b e5		 mov	 esp, ebp
  001c8	5d		 pop	 ebp
  001c9	c3		 ret	 0
_iterate_amd_sse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _iterate_intel_sse2
_TEXT	SEGMENT
_ps_ptr$ = 8						; size = 4
_iterate_intel_sse2 PROC				; COMDAT

; 1191 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1192 :    __asm
; 1193 :    {
; 1194 :    mov      ebx,           ps_ptr      // Get pointstruct pointer

  00009	8b 5d 08	 mov	 ebx, DWORD PTR _ps_ptr$[ebp]

; 1195 :    movapd   xmm_yy01,      PS4_YY01    // Restore point states

  0000c	66 0f 28 93 80
	00 00 00	 movapd	 xmm2, XMMWORD PTR [ebx+128]

; 1196 :    movapd   xmm_y01,       PS4_Y01

  00014	66 0f 28 4b 40	 movapd	 xmm1, XMMWORD PTR [ebx+64]

; 1197 :    movapd   xmm_x23,       PS4_X23

  00019	66 0f 28 63 10	 movapd	 xmm4, XMMWORD PTR [ebx+16]

; 1198 :    movapd   xmm_x01,       PS4_X01

  0001e	66 0f 28 03	 movapd	 xmm0, XMMWORD PTR [ebx]

; 1199 :    movapd   xmm_two,       PS4_TWO

  00022	66 0f 28 bb c0
	01 00 00	 movapd	 xmm7, XMMWORD PTR [ebx+448]

; 1200 :    movapd   xmm_y23,       PS4_Y23

  0002a	66 0f 28 6b 50	 movapd	 xmm5, XMMWORD PTR [ebx+80]

; 1201 :    movapd   xmm_yy23,      PS4_YY23

  0002f	66 0f 28 b3 90
	00 00 00	 movapd	 xmm6, XMMWORD PTR [ebx+144]

; 1202 :    addpd    xmm_y01,       PS4_B01     // pre-add y01 to get correct initial condition

  00037	66 0f 58 8b 00
	01 00 00	 addpd	 xmm1, XMMWORD PTR [ebx+256]

; 1203 : 
; 1204 :    mov      eax,           2           // iteration counter (for each of the 4 points)

  0003f	b8 02 00 00 00	 mov	 eax, 2

; 1205 :    jmp      skip_top

  00044	eb 0f		 jmp	 SHORT $skip_top$3
$iter_loop$4:

; 1206 : 
; 1207 : iter_loop:                             // alignment doesn't seem to matter on Intel
; 1208 :    movapd   PS4_YY01,      xmm_yy01    // save yy01 for mag backout checking

  00046	66 0f 29 93 80
	00 00 00	 movapd	 XMMWORD PTR [ebx+128], xmm2

; 1209 :    movapd   PS4_X01,       xmm_x01     // save x01 for mag backout checking; contains xx01 - yy01 here

  0004e	66 0f 29 03	 movapd	 XMMWORD PTR [ebx], xmm0

; 1210 :    add      eax,           2           // update iteration counter

  00052	83 c0 02	 add	 eax, 2
$skip_top$3:

; 1211 : skip_top:
; 1212 :    mulpd    xmm_x23,       xmm_x23     // x23 *= x23

  00055	66 0f 59 e4	 mulpd	 xmm4, xmm4

; 1213 :    addpd    xmm_x01,       PS4_A01     // x01 += a01

  00059	66 0f 58 83 c0
	00 00 00	 addpd	 xmm0, XMMWORD PTR [ebx+192]

; 1214 :    addpd    xmm_y23,       xmm_y23     // y23 *= 2; faster here than mulpd xmm_y23, xmm_two

  00061	66 0f 58 ed	 addpd	 xmm5, xmm5

; 1215 :    movapd   xmm_yy01,      xmm_y01     // yy01 = y01

  00065	66 0f 28 d1	 movapd	 xmm2, xmm1

; 1216 :    movapd   PS4_X23,       xmm_x23     // save xx23 for magnitude backout checking

  00069	66 0f 29 63 10	 movapd	 XMMWORD PTR [ebx+16], xmm4

; 1217 :    mulpd    xmm_yy01,      xmm_yy01    // yy01 *= yy01

  0006e	66 0f 59 d2	 mulpd	 xmm2, xmm2

; 1218 :    subpd    xmm_x23,       xmm_yy23    // x23 -= yy23

  00072	66 0f 5c e6	 subpd	 xmm4, xmm6

; 1219 :    mulpd    xmm_y01,       xmm_x01     // y01 *= x01

  00076	66 0f 59 c8	 mulpd	 xmm1, xmm0

; 1220 :    addpd    xmm_y23,       PS4_B23     // y23 += b23

  0007a	66 0f 58 ab 10
	01 00 00	 addpd	 xmm5, XMMWORD PTR [ebx+272]

; 1221 :    mulpd    xmm_x01,       xmm_x01     // x01 *= x01

  00082	66 0f 59 c0	 mulpd	 xmm0, xmm0

; 1222 :    movapd   PS4_YY23,      xmm_yy23    // save yy23 for magnitude backout checking

  00086	66 0f 29 b3 90
	00 00 00	 movapd	 XMMWORD PTR [ebx+144], xmm6

; 1223 :    mulpd    xmm_y01,       xmm_two     // y01 *= 2; add slower here

  0008e	66 0f 59 cf	 mulpd	 xmm1, xmm7

; 1224 :    addpd    xmm_x23,       PS4_A23     // x23 += a23

  00092	66 0f 58 a3 d0
	00 00 00	 addpd	 xmm4, XMMWORD PTR [ebx+208]

; 1225 :    movapd   xmm_mag,       xmm_x01     // mag01 = x01

  0009a	66 0f 28 d8	 movapd	 xmm3, xmm0

; 1226 :    movapd   xmm_yy23,      xmm_y23     // yy23 = y23

  0009e	66 0f 28 f5	 movapd	 xmm6, xmm5

; 1227 :    subpd    xmm_x01,       xmm_yy01    // x01 -= yy01

  000a2	66 0f 5c c2	 subpd	 xmm0, xmm2

; 1228 :    mulpd    xmm_yy23,      xmm_yy23    // yy23 *= yy23

  000a6	66 0f 59 f6	 mulpd	 xmm6, xmm6

; 1229 :    addpd    xmm_y01,       PS4_B01     // y01 += b01

  000aa	66 0f 58 8b 00
	01 00 00	 addpd	 xmm1, XMMWORD PTR [ebx+256]

; 1230 :    mulpd    xmm_y23,       xmm_x23     // y23 *= x23

  000b2	66 0f 59 ec	 mulpd	 xmm5, xmm4

; 1231 :    // ----- Start of 2nd iteration block ------
; 1232 :    addpd    xmm_mag,       xmm_yy01

  000b6	66 0f 58 da	 addpd	 xmm3, xmm2

; 1233 :    mulpd    xmm_x23,       xmm_x23

  000ba	66 0f 59 e4	 mulpd	 xmm4, xmm4

; 1234 :    addpd    xmm_x01,       PS4_A01

  000be	66 0f 58 83 c0
	00 00 00	 addpd	 xmm0, XMMWORD PTR [ebx+192]

; 1235 :    mulpd    xmm_y23,       xmm_two

  000c6	66 0f 59 ef	 mulpd	 xmm5, xmm7

; 1236 :    movapd   xmm_yy01,      xmm_y01

  000ca	66 0f 28 d1	 movapd	 xmm2, xmm1

; 1237 :    movapd   PS4_MAG01,     xmm_mag     // new, mag store for normalized iteration count alg -- not much effect on speed

  000ce	66 0f 29 9b 40
	01 00 00	 movapd	 XMMWORD PTR [ebx+320], xmm3

; 1238 :    cmpnltpd xmm_mag,       PS4_RAD     // compare point 0, 1 magnitudes (mag >= rad): let cpu reorder these

  000d6	66 0f c2 9b 40
	02 00 00 05	 cmpnltpd xmm3, XMMWORD PTR [ebx+576]

; 1239 :    movmskpd edx,           xmm_mag     // save result in edx

  000df	66 0f 50 d3	 movmskpd edx, xmm3

; 1240 :    movapd   xmm_mag,       xmm_x23

  000e3	66 0f 28 dc	 movapd	 xmm3, xmm4

; 1241 :    mulpd    xmm_yy01,      xmm_yy01

  000e7	66 0f 59 d2	 mulpd	 xmm2, xmm2

; 1242 :    subpd    xmm_x23,       xmm_yy23

  000eb	66 0f 5c e6	 subpd	 xmm4, xmm6

; 1243 :    mulpd    xmm_y01,       xmm_x01

  000ef	66 0f 59 c8	 mulpd	 xmm1, xmm0

; 1244 :    addpd    xmm_y23,       PS4_B23

  000f3	66 0f 58 ab 10
	01 00 00	 addpd	 xmm5, XMMWORD PTR [ebx+272]

; 1245 :    mulpd    xmm_x01,       xmm_x01

  000fb	66 0f 59 c0	 mulpd	 xmm0, xmm0

; 1246 :    addpd    xmm_mag,       xmm_yy23

  000ff	66 0f 58 de	 addpd	 xmm3, xmm6

; 1247 :    mulpd    xmm_y01,       xmm_two

  00103	66 0f 59 cf	 mulpd	 xmm1, xmm7

; 1248 :    addpd    xmm_x23,       PS4_A23

  00107	66 0f 58 a3 d0
	00 00 00	 addpd	 xmm4, XMMWORD PTR [ebx+208]

; 1249 :    add      edx,           edx         // shift point 01 mag compare results left 2

  0010f	03 d2		 add	 edx, edx

; 1250 :    add      edx,           edx

  00111	03 d2		 add	 edx, edx

; 1251 :    movapd   xmm_yy23,      xmm_y23

  00113	66 0f 28 f5	 movapd	 xmm6, xmm5

; 1252 :    subpd    xmm_x01,       xmm_yy01

  00117	66 0f 5c c2	 subpd	 xmm0, xmm2

; 1253 :    movapd   PS4_MAG23,     xmm_mag     // new, mag store for normalized iteration count alg -- not much effect on speed

  0011b	66 0f 29 9b 50
	01 00 00	 movapd	 XMMWORD PTR [ebx+336], xmm3

; 1254 :    cmpnltpd xmm_mag,       PS4_RAD     // compare point 2, 3 magnitudes

  00123	66 0f c2 9b 40
	02 00 00 05	 cmpnltpd xmm3, XMMWORD PTR [ebx+576]

; 1255 :    mulpd    xmm_yy23,      xmm_yy23

  0012c	66 0f 59 f6	 mulpd	 xmm6, xmm6

; 1256 :    addpd    xmm_y01,       PS4_B01

  00130	66 0f 58 8b 00
	01 00 00	 addpd	 xmm1, XMMWORD PTR [ebx+256]

; 1257 :    movmskpd ecx,           xmm_mag

  00138	66 0f 50 cb	 movmskpd ecx, xmm3

; 1258 :    mulpd    xmm_y23,       xmm_x23

  0013c	66 0f 59 ec	 mulpd	 xmm5, xmm4

; 1259 :    or       ecx,           edx         // Continue iterating until max iters reached for this call,

  00140	0b ca		 or	 ecx, edx

; 1260 :    jnz      done                       // or one of the points diverged.

  00142	75 0c		 jne	 SHORT $done$5

; 1261 :    cmp      PS4_CUR_MAX_ITERS, eax     // No penalty for comparing from memory vs. register here

  00144	39 83 98 03 00
	00		 cmp	 DWORD PTR [ebx+920], eax

; 1262 :    jne      iter_loop

  0014a	0f 85 f6 fe ff
	ff		 jne	 $iter_loop$4
$done$5:

; 1263 : 
; 1264 : done:
; 1265 :    subpd    xmm_y01,       PS4_B01     // subtract out pre-add (see loop top)

  00150	66 0f 5c 8b 00
	01 00 00	 subpd	 xmm1, XMMWORD PTR [ebx+256]

; 1266 :    movapd   PS4_Y01,       xmm_y01     // save y01 state

  00158	66 0f 29 4b 40	 movapd	 XMMWORD PTR [ebx+64], xmm1

; 1267 :    movapd   PS4_Y23,       xmm_y23     // save y23 state

  0015d	66 0f 29 6b 50	 movapd	 XMMWORD PTR [ebx+80], xmm5

; 1268 : 
; 1269 :    // Get previous magnitudes. See AMD code
; 1270 :    mulpd    xmm_two,       PS4_YY01    // Use xmm_two for tmp var; tmp1 = 2 * yy01

  00162	66 0f 59 bb 80
	00 00 00	 mulpd	 xmm7, XMMWORD PTR [ebx+128]

; 1271 :    movapd   xmm_mag,       PS4_X23     // tmp2 = xx23

  0016a	66 0f 28 5b 10	 movapd	 xmm3, XMMWORD PTR [ebx+16]

; 1272 :    addpd    xmm_two,       PS4_X01     // get mag01 = xx01 - yy01 + 2 * yy01 = xx01 + yy01

  0016f	66 0f 58 3b	 addpd	 xmm7, XMMWORD PTR [ebx]

; 1273 :    addpd    xmm_mag,       PS4_YY23    // get mag23 = xx23 + yy23

  00173	66 0f 58 9b 90
	00 00 00	 addpd	 xmm3, XMMWORD PTR [ebx+144]

; 1274 :    movapd   PS4_MAGPREV01, xmm_two     // store prev_mag 01

  0017b	66 0f 29 bb 80
	01 00 00	 movapd	 XMMWORD PTR [ebx+384], xmm7

; 1275 :    movapd   PS4_MAGPREV23, xmm_mag     // store prev_mag 23

  00183	66 0f 29 9b 90
	01 00 00	 movapd	 XMMWORD PTR [ebx+400], xmm3

; 1276 : 
; 1277 :    xor      edx,           edx         // Get a 0

  0018b	33 d2		 xor	 edx, edx

; 1278 :    add      PS4_ITERCTR_L, eax         // Update iteration counter. Multiply by 36 to get effective flops.

  0018d	01 83 80 03 00
	00		 add	 DWORD PTR [ebx+896], eax

; 1279 :    adc      PS4_ITERCTR_H, edx         // Update iterctr high dword

  00193	11 93 84 03 00
	00		 adc	 DWORD PTR [ebx+900], edx

; 1280 : 
; 1281 :    movapd   PS4_YY01,      xmm_yy01    // save yy01 state

  00199	66 0f 29 93 80
	00 00 00	 movapd	 XMMWORD PTR [ebx+128], xmm2

; 1282 :    movapd   PS4_X23,       xmm_x23     // save x23 state

  001a1	66 0f 29 63 10	 movapd	 XMMWORD PTR [ebx+16], xmm4

; 1283 :    movapd   PS4_X01,       xmm_x01     // save x01 state

  001a6	66 0f 29 03	 movapd	 XMMWORD PTR [ebx], xmm0

; 1284 :    movapd   PS4_YY23,      xmm_yy23    // save yy23 state

  001aa	66 0f 29 b3 90
	00 00 00	 movapd	 XMMWORD PTR [ebx+144], xmm6

; 1285 : 
; 1286 :    add      PS4_ITERS0,    eax         // update point iteration counts

  001b2	01 83 c0 02 00
	00		 add	 DWORD PTR [ebx+704], eax

; 1287 :    add      PS4_ITERS1,    eax

  001b8	01 83 c4 02 00
	00		 add	 DWORD PTR [ebx+708], eax

; 1288 :    add      PS4_ITERS2,    eax

  001be	01 83 c8 02 00
	00		 add	 DWORD PTR [ebx+712], eax

; 1289 :    add      PS4_ITERS3,    eax

  001c4	01 83 cc 02 00
	00		 add	 DWORD PTR [ebx+716], eax

; 1290 :    }
; 1291 : }

  001ca	5f		 pop	 edi
  001cb	5e		 pop	 esi
  001cc	5b		 pop	 ebx
  001cd	8b e5		 mov	 esp, ebp
  001cf	5d		 pop	 ebp
  001d0	c3		 ret	 0
_iterate_intel_sse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _iterate_amd_sse2
_TEXT	SEGMENT
_ps_ptr$ = 8						; size = 4
_iterate_amd_sse2 PROC					; COMDAT

; 1045 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1046 :    __asm
; 1047 :    {
; 1048 :    // Tried getting rid of the xmm save/restore by having queue_point load directly into
; 1049 :    // the xmm registers (see qhold_load_xmm.c): overhead reduction is negligible.
; 1050 : 
; 1051 :    mov      ebx,           ps_ptr      // Get pointstruct pointer. PS4_ macros below reference [ebx + offset]

  00009	8b 5d 08	 mov	 ebx, DWORD PTR _ps_ptr$[ebp]

; 1052 :    movapd   xmm_x23,       PS4_X23     // Restore point states

  0000c	66 0f 28 63 10	 movapd	 xmm4, XMMWORD PTR [ebx+16]

; 1053 :    movapd   xmm_x01,       PS4_X01

  00011	66 0f 28 03	 movapd	 xmm0, XMMWORD PTR [ebx]

; 1054 :    movapd   xmm_two,       PS4_TWO

  00015	66 0f 28 bb c0
	01 00 00	 movapd	 xmm7, XMMWORD PTR [ebx+448]

; 1055 :    movapd   xmm_y23,       PS4_Y23

  0001d	66 0f 28 6b 50	 movapd	 xmm5, XMMWORD PTR [ebx+80]

; 1056 :    movapd   xmm_y01,       PS4_Y01

  00022	66 0f 28 4b 40	 movapd	 xmm1, XMMWORD PTR [ebx+64]

; 1057 :    movapd   xmm_yy23,      PS4_YY23

  00027	66 0f 28 b3 90
	00 00 00	 movapd	 xmm6, XMMWORD PTR [ebx+144]

; 1058 : 
; 1059 :    mov      edx,           DIV_EXP           // Exp for magnitude exponent comparison. Slower to compare to const directly

  0002f	ba 00 00 30 40	 mov	 edx, 1076887552		; 40300000H

; 1060 :    mov      ecx,           PS4_CUR_MAX_ITERS // max iters to do this call; always even

  00034	8b 8b 98 03 00
	00		 mov	 ecx, DWORD PTR [ebx+920]

; 1061 :    mov      eax,           0                 // iteration counter (for each of the 4 points)

  0003a	b8 00 00 00 00	 mov	 eax, 0

; 1062 :    jmp      skip_top                         // Jump past 1st 2 movapds for loop entry, eliminating

  0003f	eb 12		 jmp	 SHORT $skip_top$3

; 1063 :    nop                                       // need to restore yy01- lower overhead

  00041	90		 npad	 1

; 1064 :    nop

  00042	90		 npad	 1

; 1065 :    nop                                       // Achieve the magic alignment (see below)

  00043	90		 npad	 1

; 1066 :    nop

  00044	90		 npad	 1

; 1067 :    nop

  00045	90		 npad	 1

; 1068 :    nop

  00046	90		 npad	 1
$iter_loop$4:

; 1069 : 
; 1070 :    // Found that it's important for the end-of-loop branch to be on a 16-byte boundary
; 1071 :    // (code is slower if not). Choose instructions above to cause this.
; 1072 :    //
; 1073 :    // v1.0 update: The above no longer holds. Now the magic alignment seems random...
; 1074 :    // the number of nops above must be determined by trial and error.
; 1075 : 
; 1076 : iter_loop:
; 1077 :    movapd   PS4_YY01,      xmm_yy01    // save yy01 for mag backout checking

  00047	66 0f 29 93 80
	00 00 00	 movapd	 XMMWORD PTR [ebx+128], xmm2

; 1078 :    movapd   PS4_X01,       xmm_x01     // save x01 for mag backout checking; contains xx01 - yy01 here

  0004f	66 0f 29 03	 movapd	 XMMWORD PTR [ebx], xmm0
$skip_top$3:

; 1079 : skip_top:
; 1080 :    addpd    xmm_y01,       PS4_B01     // y01 += b01; faster at top of loop. Initial y01 = 0

  00053	66 0f 58 8b 00
	01 00 00	 addpd	 xmm1, XMMWORD PTR [ebx+256]

; 1081 :    mulpd    xmm_y23,       xmm_x23     // y23 *= x23; faster at top of loop.

  0005b	66 0f 59 ec	 mulpd	 xmm5, xmm4

; 1082 :    add      eax,           2           // update iteration counter; faster here than 2 insts below

  0005f	83 c0 02	 add	 eax, 2

; 1083 :    mulpd    xmm_x23,       xmm_x23     // x23 *= x23

  00062	66 0f 59 e4	 mulpd	 xmm4, xmm4

; 1084 :    addpd    xmm_x01,       PS4_A01     // x01 += a01

  00066	66 0f 58 83 c0
	00 00 00	 addpd	 xmm0, XMMWORD PTR [ebx+192]

; 1085 :    addpd    xmm_y23,       xmm_y23     // y23 *= 2; faster here than mulpd xmm_y23, xmm_two

  0006e	66 0f 58 ed	 addpd	 xmm5, xmm5

; 1086 :    movapd   xmm_yy01,      xmm_y01     // yy01 = y01

  00072	66 0f 28 d1	 movapd	 xmm2, xmm1

; 1087 :    movapd   PS4_X23,       xmm_x23     // save xx23 for magnitude backout checking

  00076	66 0f 29 63 10	 movapd	 XMMWORD PTR [ebx+16], xmm4

; 1088 :    mulpd    xmm_yy01,      xmm_yy01    // yy01 *= yy01

  0007b	66 0f 59 d2	 mulpd	 xmm2, xmm2

; 1089 :    subpd    xmm_x23,       xmm_yy23    // x23 -= yy23

  0007f	66 0f 5c e6	 subpd	 xmm4, xmm6

; 1090 :    mulpd    xmm_y01,       xmm_x01     // y01 *= x01

  00083	66 0f 59 c8	 mulpd	 xmm1, xmm0

; 1091 :    addpd    xmm_y23,       PS4_B23     // y23 += b23

  00087	66 0f 58 ab 10
	01 00 00	 addpd	 xmm5, XMMWORD PTR [ebx+272]

; 1092 :    mulpd    xmm_x01,       xmm_x01     // x01 *= x01

  0008f	66 0f 59 c0	 mulpd	 xmm0, xmm0

; 1093 :    movapd   PS4_YY23,      xmm_yy23    // save yy23 for magnitude backout checking

  00093	66 0f 29 b3 90
	00 00 00	 movapd	 XMMWORD PTR [ebx+144], xmm6

; 1094 :    mulpd    xmm_y01,       xmm_two     // y01 *= 2; add slower here; bb stall

  0009b	66 0f 59 cf	 mulpd	 xmm1, xmm7

; 1095 :    addpd    xmm_x23,       PS4_A23     // x23 += a23

  0009f	66 0f 58 a3 d0
	00 00 00	 addpd	 xmm4, XMMWORD PTR [ebx+208]

; 1096 :    movapd   xmm_mag,       xmm_x01     // mag01 = x01

  000a7	66 0f 28 d8	 movapd	 xmm3, xmm0

; 1097 :    movapd   xmm_yy23,      xmm_y23     // yy23 = y23

  000ab	66 0f 28 f5	 movapd	 xmm6, xmm5

; 1098 :    subpd    xmm_x01,       xmm_yy01    // x01 -= yy01

  000af	66 0f 5c c2	 subpd	 xmm0, xmm2

; 1099 :    mulpd    xmm_yy23,      xmm_yy23    // yy23 *= yy23

  000b3	66 0f 59 f6	 mulpd	 xmm6, xmm6

; 1100 :    addpd    xmm_y01,       PS4_B01     // y01 += b01

  000b7	66 0f 58 8b 00
	01 00 00	 addpd	 xmm1, XMMWORD PTR [ebx+256]

; 1101 :    mulpd    xmm_y23,       xmm_x23     // y23 *= x23

  000bf	66 0f 59 ec	 mulpd	 xmm5, xmm4

; 1102 :    // ----- Start of 2nd iteration block ------
; 1103 :    addpd    xmm_mag,       xmm_yy01

  000c3	66 0f 58 da	 addpd	 xmm3, xmm2

; 1104 :    mulpd    xmm_x23,       xmm_x23

  000c7	66 0f 59 e4	 mulpd	 xmm4, xmm4

; 1105 :    addpd    xmm_x01,       PS4_A01

  000cb	66 0f 58 83 c0
	00 00 00	 addpd	 xmm0, XMMWORD PTR [ebx+192]

; 1106 :    movapd   xmm_yy01,      xmm_y01     // these 2 instrs: faster in this order than reversed (fixes y23 dep?)

  000d3	66 0f 28 d1	 movapd	 xmm2, xmm1

; 1107 :    mulpd    xmm_y23,       xmm_two     // (yy01 is apparently just "marked" to get y01 here; doesn't cause a dep delay)

  000d7	66 0f 59 ef	 mulpd	 xmm5, xmm7

; 1108 :    movapd   PS4_MAG01,     xmm_mag     // save point 0,1 magnitudes for comparison

  000db	66 0f 29 9b 40
	01 00 00	 movapd	 XMMWORD PTR [ebx+320], xmm3

; 1109 :    movapd   xmm_mag,       xmm_x23

  000e3	66 0f 28 dc	 movapd	 xmm3, xmm4

; 1110 :    mulpd    xmm_yy01,      xmm_yy01

  000e7	66 0f 59 d2	 mulpd	 xmm2, xmm2

; 1111 :    subpd    xmm_x23,       xmm_yy23

  000eb	66 0f 5c e6	 subpd	 xmm4, xmm6

; 1112 :    mulpd    xmm_y01,       xmm_x01

  000ef	66 0f 59 c8	 mulpd	 xmm1, xmm0

; 1113 :    addpd    xmm_y23,       PS4_B23

  000f3	66 0f 58 ab 10
	01 00 00	 addpd	 xmm5, XMMWORD PTR [ebx+272]

; 1114 :    mulpd    xmm_x01,       xmm_x01

  000fb	66 0f 59 c0	 mulpd	 xmm0, xmm0

; 1115 :    addpd    xmm_mag,       xmm_yy23

  000ff	66 0f 58 de	 addpd	 xmm3, xmm6

; 1116 :    movapd   PS4_MAG23,     xmm_mag     // Save point 2,3 magnitudes. Best here, despite dep

  00103	66 0f 29 9b 50
	01 00 00	 movapd	 XMMWORD PTR [ebx+336], xmm3

; 1117 :    cmp      PS4_MEXP0,     edx         // Compare the magnitude exponents of points 0 and 1

  0010b	39 93 44 01 00
	00		 cmp	 DWORD PTR [ebx+324], edx

; 1118 :    cmovge   ecx,           eax         // to the divergence threshold. AMD doesn't seem to mind

  00111	0f 4d c8	 cmovge	 ecx, eax

; 1119 :    cmp      PS4_MEXP1,     edx         // the store fowarding issue, but Intel does.

  00114	39 93 4c 01 00
	00		 cmp	 DWORD PTR [ebx+332], edx

; 1120 :    cmovge   ecx,           eax         // Conditional moves set ecx to eax on divergence,

  0011a	0f 4d c8	 cmovge	 ecx, eax

; 1121 :    mulpd    xmm_y01,       xmm_two     // breaking the loop.

  0011d	66 0f 59 cf	 mulpd	 xmm1, xmm7

; 1122 :    addpd    xmm_x23,       PS4_A23     // add y, y and mul y, two seem equal speed here

  00121	66 0f 58 a3 d0
	00 00 00	 addpd	 xmm4, XMMWORD PTR [ebx+208]

; 1123 :    movapd   xmm_yy23,      xmm_y23

  00129	66 0f 28 f5	 movapd	 xmm6, xmm5

; 1124 :    subpd    xmm_x01,       xmm_yy01

  0012d	66 0f 5c c2	 subpd	 xmm0, xmm2

; 1125 :    mulpd    xmm_yy23,      xmm_yy23

  00131	66 0f 59 f6	 mulpd	 xmm6, xmm6

; 1126 :    cmp      PS4_MEXP2,     edx         // Compare the magnitude exponents of points 2 and 3.

  00135	39 93 54 01 00
	00		 cmp	 DWORD PTR [ebx+340], edx

; 1127 :    cmovge   ecx,           eax

  0013b	0f 4d c8	 cmovge	 ecx, eax

; 1128 :    cmp      PS4_MEXP3,     edx

  0013e	39 93 5c 01 00
	00		 cmp	 DWORD PTR [ebx+348], edx

; 1129 :    cmovge   ecx,           eax

  00144	0f 4d c8	 cmovge	 ecx, eax

; 1130 :    cmp      ecx,           eax         // Continue iterating until max iters reached for this call,

  00147	3b c8		 cmp	 ecx, eax

; 1131 :    jne      iter_loop                  // or one of the points diverged.

  00149	0f 85 f8 fe ff
	ff		 jne	 $iter_loop$4

; 1132 : 
; 1133 :    // Exited loop: save iterating point states, and update point iteration counts. Because
; 1134 :    // divergence detection is only done every 2 iterations, need to "back out" and see if
; 1135 :    // a point diverged the previous iteration. Calculate previous magnitudes from stored
; 1136 :    // values and save in expp. Caller can then use DIVERGED and DIVERGED_PREV macros
; 1137 :    // to detect if/when the point diverged.
; 1138 : 
; 1139 :    // Structure contents here: PS4.x = xx01 - yy01;  PS4.yy = yy01; PS4.x + 16 = xx23; PS4.yy + 16 = yy23
; 1140 :    // Order here seems fastest, despite dependencies
; 1141 :    // Really only need to calculate prev mags for points that diverged... could save overhead
; 1142 : 
; 1143 :    movapd   PS4_Y01,       xmm_y01     // save y01 state

  0014f	66 0f 29 4b 40	 movapd	 XMMWORD PTR [ebx+64], xmm1

; 1144 :    movapd   PS4_Y23,       xmm_y23     // save y23 state

  00154	66 0f 29 6b 50	 movapd	 XMMWORD PTR [ebx+80], xmm5

; 1145 : 
; 1146 :    mulpd    xmm_two,       PS4_YY01    // Use xmm_two for tmp var; tmp1 = 2 * yy01

  00159	66 0f 59 bb 80
	00 00 00	 mulpd	 xmm7, XMMWORD PTR [ebx+128]

; 1147 :    movapd   xmm_mag,       PS4_X23     // tmp2 = xx23

  00161	66 0f 28 5b 10	 movapd	 xmm3, XMMWORD PTR [ebx+16]

; 1148 :    addpd    xmm_two,       PS4_X01     // get mag01 = xx01 - yy01 + 2 * yy01 = xx01 + yy01

  00166	66 0f 58 3b	 addpd	 xmm7, XMMWORD PTR [ebx]

; 1149 :    addpd    xmm_mag,       PS4_YY23    // get mag23 = xx23 + yy23

  0016a	66 0f 58 9b 90
	00 00 00	 addpd	 xmm3, XMMWORD PTR [ebx+144]

; 1150 :    movapd   PS4_MAGPREV01, xmm_two     // store prev_mag 01

  00172	66 0f 29 bb 80
	01 00 00	 movapd	 XMMWORD PTR [ebx+384], xmm7

; 1151 :    movapd   PS4_MAGPREV23, xmm_mag     // store prev_mag 23

  0017a	66 0f 29 9b 90
	01 00 00	 movapd	 XMMWORD PTR [ebx+400], xmm3

; 1152 : 
; 1153 :    xor      ecx,           ecx         // Get a 0

  00182	33 c9		 xor	 ecx, ecx

; 1154 :    add      PS4_ITERCTR_L, eax         // Update iteration counter. Multiply by 36 to get effective flops.

  00184	01 83 80 03 00
	00		 add	 DWORD PTR [ebx+896], eax

; 1155 :    adc      PS4_ITERCTR_H, ecx         // Update iterctr high dword

  0018a	11 8b 84 03 00
	00		 adc	 DWORD PTR [ebx+900], ecx

; 1156 : 
; 1157 :    movapd   PS4_YY01,      xmm_yy01    // save yy01 state

  00190	66 0f 29 93 80
	00 00 00	 movapd	 XMMWORD PTR [ebx+128], xmm2

; 1158 :    movapd   PS4_X23,       xmm_x23     // save x23 state

  00198	66 0f 29 63 10	 movapd	 XMMWORD PTR [ebx+16], xmm4

; 1159 :    movapd   PS4_X01,       xmm_x01     // save x01 state

  0019d	66 0f 29 03	 movapd	 XMMWORD PTR [ebx], xmm0

; 1160 :    movapd   PS4_YY23,      xmm_yy23    // save yy23 state

  001a1	66 0f 29 b3 90
	00 00 00	 movapd	 XMMWORD PTR [ebx+144], xmm6

; 1161 : 
; 1162 :    add      PS4_ITERS0,    eax         // update point iteration counts

  001a9	01 83 c0 02 00
	00		 add	 DWORD PTR [ebx+704], eax

; 1163 :    add      PS4_ITERS1,    eax

  001af	01 83 c4 02 00
	00		 add	 DWORD PTR [ebx+708], eax

; 1164 :    add      PS4_ITERS2,    eax

  001b5	01 83 c8 02 00
	00		 add	 DWORD PTR [ebx+712], eax

; 1165 :    add      PS4_ITERS3,    eax

  001bb	01 83 cc 02 00
	00		 add	 DWORD PTR [ebx+716], eax

; 1166 : 
; 1167 :    // return value (iters done per point) is in eax
; 1168 : 
; 1169 :    // 0xF3 prefix for AMD single byte return fix: does seem to make a difference
; 1170 :    // Don't put any code between here and ret. Watch for compiler-inserted pops if
; 1171 :    // using extra registers.
; 1172 : 
; 1173 :    //pop      ebx        // compiler pushes ebx, ebp on entry
; 1174 :    //pop      ebp        // accessing ebp gives compiler warning
; 1175 :    //__emit(0xF3);
; 1176 :    //ret
; 1177 :    }
; 1178 : }

  001c1	5f		 pop	 edi
  001c2	5e		 pop	 esi
  001c3	5b		 pop	 ebx
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
_iterate_amd_sse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT @queue_point_c@12
_TEXT	SEGMENT
_i$1 = -3148						; size = 4
_szTmp$2 = -3144					; size = 1024
_szFileLine$3 = -2120					; size = 1024
_j$4 = -1096						; size = 4
_i$5 = -1092						; size = 4
_log_ended_early$ = -1088				; size = 4
_iters_log$ = -1084					; size = 4
_max_iters_reached$ = -1080				; size = 4
_re_width$ = -1076					; size = 8
_im_width$ = -1068					; size = 8
_center_im$ = -1060					; size = 8
_center_re$ = -1052					; size = 8
_szFilename$ = -1044					; size = 1024
_fp$ = -20						; size = 4
_iters$ = -16						; size = 4
_m$ = -12						; size = 4
_ps_ptr$ = -8						; size = 4
_calc_struct$ = -4					; size = 4
_iters_ptr$ = 8						; size = 4
@queue_point_c@12 PROC					; COMDAT
; _calc_struct$ = ecx
; _ps_ptr$ = edx

; 867  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 0e 00
	00		 sub	 esp, 3596		; 00000e0cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	89 55 f8	 mov	 DWORD PTR _ps_ptr$[ebp], edx
  0000f	89 4d fc	 mov	 DWORD PTR _calc_struct$[ebp], ecx

; 868  :    man_calc_struct *m;
; 869  :    unsigned iters;
; 870  : 
; 871  :    m = (man_calc_struct *) calc_struct;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _calc_struct$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR _m$[ebp], eax

; 872  : 
; 873  :    //-------
; 874  :    FILE* fp;
; 875  :    static int fileNo = 0;
; 876  :    static int currLines = 0;
; 877  :    char szFilename[1024];
; 878  :    if (currLines >= 1000000)

  00018	81 3d 00 00 00
	00 40 42 0f 00	 cmp	 DWORD PTR ?currLines@?1??queue_point_c@@9@9, 1000000 ; 000f4240H
  00022	7c 17		 jl	 SHORT $LN11@

; 879  :    {
; 880  : 	   currLines = 0;

  00024	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?currLines@?1??queue_point_c@@9@9, 0

; 881  : 	   fileNo++;

  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?fileNo@?1??queue_point_c@@9@9
  00033	83 c0 01	 add	 eax, 1
  00036	a3 00 00 00 00	 mov	 DWORD PTR ?fileNo@?1??queue_point_c@@9@9, eax
$LN11@:

; 882  :    }
; 883  :    sprintf_s(szFilename, 1024, "oversample_debug.%d.csv", fileNo);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?fileNo@?1??queue_point_c@@9@9
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET $SG40789
  00046	68 00 04 00 00	 push	 1024			; 00000400H
  0004b	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szFilename$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 _sprintf_s
  00057	83 c4 10	 add	 esp, 16			; 00000010H

; 884  :    fopen_s(&fp, szFilename, "a");

  0005a	68 00 00 00 00	 push	 OFFSET $SG40790
  0005f	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szFilename$[ebp]
  00065	50		 push	 eax
  00066	8d 4d ec	 lea	 ecx, DWORD PTR _fp$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 _fopen_s
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 885  :    double center_re = ps_ptr->ab_in[0];

  00072	b8 08 00 00 00	 mov	 eax, 8
  00077	6b c8 00	 imul	 ecx, eax, 0
  0007a	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  0007d	f2 0f 10 84 0a
	88 03 00 00	 movsd	 xmm0, QWORD PTR [edx+ecx+904]
  00086	f2 0f 11 85 e4
	fb ff ff	 movsd	 QWORD PTR _center_re$[ebp], xmm0

; 886  :    double center_im = ps_ptr->ab_in[1];

  0008e	b8 08 00 00 00	 mov	 eax, 8
  00093	c1 e0 00	 shl	 eax, 0
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00099	f2 0f 10 84 01
	88 03 00 00	 movsd	 xmm0, QWORD PTR [ecx+eax+904]
  000a2	f2 0f 11 85 dc
	fb ff ff	 movsd	 QWORD PTR _center_im$[ebp], xmm0

; 887  :    double im_width = m->img_im[0] - m->img_im[1];

  000aa	b8 08 00 00 00	 mov	 eax, 8
  000af	6b c8 00	 imul	 ecx, eax, 0
  000b2	8b 55 f4	 mov	 edx, DWORD PTR _m$[ebp]
  000b5	8b 82 d8 8d 00
	00		 mov	 eax, DWORD PTR [edx+36312]
  000bb	ba 08 00 00 00	 mov	 edx, 8
  000c0	c1 e2 00	 shl	 edx, 0
  000c3	8b 75 f4	 mov	 esi, DWORD PTR _m$[ebp]
  000c6	8b b6 d8 8d 00
	00		 mov	 esi, DWORD PTR [esi+36312]
  000cc	f2 0f 10 04 08	 movsd	 xmm0, QWORD PTR [eax+ecx]
  000d1	f2 0f 5c 04 16	 subsd	 xmm0, QWORD PTR [esi+edx]
  000d6	f2 0f 11 85 d4
	fb ff ff	 movsd	 QWORD PTR _im_width$[ebp], xmm0

; 888  :    double re_width = m->img_re[1] - m->img_re[0];

  000de	b8 08 00 00 00	 mov	 eax, 8
  000e3	c1 e0 00	 shl	 eax, 0
  000e6	8b 4d f4	 mov	 ecx, DWORD PTR _m$[ebp]
  000e9	8b 91 d4 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36308]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	6b c9 00	 imul	 ecx, ecx, 0
  000f7	8b 75 f4	 mov	 esi, DWORD PTR _m$[ebp]
  000fa	8b b6 d4 8d 00
	00		 mov	 esi, DWORD PTR [esi+36308]
  00100	f2 0f 10 04 02	 movsd	 xmm0, QWORD PTR [edx+eax]
  00105	f2 0f 5c 04 0e	 subsd	 xmm0, QWORD PTR [esi+ecx]
  0010a	f2 0f 11 85 cc
	fb ff ff	 movsd	 QWORD PTR _re_width$[ebp], xmm0

; 889  : 
; 890  :    int max_iters_reached = 0;

  00112	c7 85 c8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _max_iters_reached$[ebp], 0

; 891  :    #define SQUARE_SIZE		1
; 892  :    int iters_log[SQUARE_SIZE];
; 893  :    int log_ended_early = 0;

  0011c	c7 85 c0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _log_ended_early$[ebp], 0

; 894  :    for (int i = 0; i < SQUARE_SIZE; i++)

  00126	c7 85 bc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$5[ebp], 0
  00130	eb 0f		 jmp	 SHORT $LN4@
$LN2@:
  00132	8b 85 bc fb ff
	ff		 mov	 eax, DWORD PTR _i$5[ebp]
  00138	83 c0 01	 add	 eax, 1
  0013b	89 85 bc fb ff
	ff		 mov	 DWORD PTR _i$5[ebp], eax
$LN4@:
  00141	83 bd bc fb ff
	ff 01		 cmp	 DWORD PTR _i$5[ebp], 1
  00148	0f 8d 8b 03 00
	00		 jge	 $LN3@

; 895  :    {
; 896  : 	   memset(iters_log, 0, sizeof(iters_log));

  0014e	6a 04		 push	 4
  00150	6a 00		 push	 0
  00152	8d 85 c4 fb ff
	ff		 lea	 eax, DWORD PTR _iters_log$[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 _memset
  0015e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 897  : 	   for (int j = 0; !max_iters_reached && j < SQUARE_SIZE; j++)

  00161	c7 85 b8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$4[ebp], 0
  0016b	eb 0f		 jmp	 SHORT $LN7@
$LN5@:
  0016d	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR _j$4[ebp]
  00173	83 c0 01	 add	 eax, 1
  00176	89 85 b8 fb ff
	ff		 mov	 DWORD PTR _j$4[ebp], eax
$LN7@:
  0017c	83 bd c8 fb ff
	ff 00		 cmp	 DWORD PTR _max_iters_reached$[ebp], 0
  00183	0f 85 df 00 00
	00		 jne	 $LN6@
  00189	83 bd b8 fb ff
	ff 01		 cmp	 DWORD PTR _j$4[ebp], 1
  00190	0f 8d d2 00 00
	00		 jge	 $LN6@

; 898  : 	   {
; 899  : 		   ps_ptr->ab_in[0] = center_re - re_width / 2 + re_width * (1.0 * j / SQUARE_SIZE);

  00196	f2 0f 10 85 cc
	fb ff ff	 movsd	 xmm0, QWORD PTR _re_width$[ebp]
  0019e	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4000000000000000
  001a6	f2 0f 10 8d e4
	fb ff ff	 movsd	 xmm1, QWORD PTR _center_re$[ebp]
  001ae	f2 0f 5c c8	 subsd	 xmm1, xmm0
  001b2	f2 0f 2a 85 b8
	fb ff ff	 cvtsi2sd xmm0, DWORD PTR _j$4[ebp]
  001ba	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ff0000000000000
  001c2	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@3ff0000000000000
  001ca	f2 0f 59 85 cc
	fb ff ff	 mulsd	 xmm0, QWORD PTR _re_width$[ebp]
  001d2	f2 0f 58 c8	 addsd	 xmm1, xmm0
  001d6	b8 08 00 00 00	 mov	 eax, 8
  001db	6b c8 00	 imul	 ecx, eax, 0
  001de	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  001e1	f2 0f 11 8c 0a
	88 03 00 00	 movsd	 QWORD PTR [edx+ecx+904], xmm1

; 900  : 		   ps_ptr->ab_in[1] = center_im - im_width / 2 + im_width * (1.0 * i / SQUARE_SIZE);

  001ea	f2 0f 10 85 d4
	fb ff ff	 movsd	 xmm0, QWORD PTR _im_width$[ebp]
  001f2	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4000000000000000
  001fa	f2 0f 10 8d dc
	fb ff ff	 movsd	 xmm1, QWORD PTR _center_im$[ebp]
  00202	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00206	f2 0f 2a 85 bc
	fb ff ff	 cvtsi2sd xmm0, DWORD PTR _i$5[ebp]
  0020e	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00216	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0021e	f2 0f 59 85 d4
	fb ff ff	 mulsd	 xmm0, QWORD PTR _im_width$[ebp]
  00226	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0022a	b8 08 00 00 00	 mov	 eax, 8
  0022f	c1 e0 00	 shl	 eax, 0
  00232	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00235	f2 0f 11 8c 01
	88 03 00 00	 movsd	 QWORD PTR [ecx+eax+904], xmm1

; 901  : 		   iters = m->mandel_iterate(ps_ptr);

  0023e	8b 45 f8	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  00241	50		 push	 eax
  00242	8b 4d f4	 mov	 ecx, DWORD PTR _m$[ebp]
  00245	8b 91 04 78 00
	00		 mov	 edx, DWORD PTR [ecx+30724]
  0024b	ff d2		 call	 edx
  0024d	83 c4 04	 add	 esp, 4
  00250	89 45 f0	 mov	 DWORD PTR _iters$[ebp], eax

; 902  : 		   iters_log[j] = iters;

  00253	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR _j$4[ebp]
  00259	8b 4d f0	 mov	 ecx, DWORD PTR _iters$[ebp]
  0025c	89 8c 85 c4 fb
	ff ff		 mov	 DWORD PTR _iters_log$[ebp+eax*4], ecx

; 903  : 
; 904  : 		   //sprintf_s(szFileLine, 1024, "%16.16lf,%16.16lf,%d,%d,%d\n", center_re, center_im, i + 1, j + 1, iters);
; 905  : 		   //sprintf_s(szFileLine, 1024, "%16.16lf,%16.16lf,%16.16lf,%16.16lf,%d\r\n", center_re, center_im, ps_ptr->ab_in[0], ps_ptr->ab_in[1], iters);
; 906  : 		   //fputs(szFileLine, fp);
; 907  : 		   if (iters == m->max_iters)
; 908  : 		   {
; 909  : 			   //max_iters_reached = 1;
; 910  : 		   }
; 911  : 	   }

  00263	e9 05 ff ff ff	 jmp	 $LN5@
$LN6@:

; 912  : 
; 913  : 	   char szFileLine[1024];
; 914  : 	   memset(szFileLine, 0, sizeof(szFileLine));

  00268	68 00 04 00 00	 push	 1024			; 00000400H
  0026d	6a 00		 push	 0
  0026f	8d 85 b8 f7 ff
	ff		 lea	 eax, DWORD PTR _szFileLine$3[ebp]
  00275	50		 push	 eax
  00276	e8 00 00 00 00	 call	 _memset
  0027b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 915  : 	   char szTmp[1024];
; 916  : 	   if (i == 0)

  0027e	83 bd bc fb ff
	ff 00		 cmp	 DWORD PTR _i$5[ebp], 0
  00285	0f 85 81 00 00
	00		 jne	 $LN13@

; 917  : 	   {
; 918  : 		   sprintf_s(szTmp, sizeof(szTmp), "%16.16lf,%16.16lf",

  0028b	f2 0f 10 85 d4
	fb ff ff	 movsd	 xmm0, QWORD PTR _im_width$[ebp]
  00293	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4000000000000000
  0029b	f2 0f 10 8d dc
	fb ff ff	 movsd	 xmm1, QWORD PTR _center_im$[ebp]
  002a3	f2 0f 5c c8	 subsd	 xmm1, xmm0
  002a7	83 ec 08	 sub	 esp, 8
  002aa	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  002af	f2 0f 10 85 cc
	fb ff ff	 movsd	 xmm0, QWORD PTR _re_width$[ebp]
  002b7	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4000000000000000
  002bf	f2 0f 10 8d e4
	fb ff ff	 movsd	 xmm1, QWORD PTR _center_re$[ebp]
  002c7	f2 0f 5c c8	 subsd	 xmm1, xmm0
  002cb	83 ec 08	 sub	 esp, 8
  002ce	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  002d3	68 00 00 00 00	 push	 OFFSET $SG40794
  002d8	68 00 04 00 00	 push	 1024			; 00000400H
  002dd	8d 85 b8 f3 ff
	ff		 lea	 eax, DWORD PTR _szTmp$2[ebp]
  002e3	50		 push	 eax
  002e4	e8 00 00 00 00	 call	 _sprintf_s
  002e9	83 c4 1c	 add	 esp, 28			; 0000001cH

; 919  : 						center_re - re_width / 2,
; 920  : 						center_im - im_width / 2
; 921  : 		   );
; 922  : 		   strcat_s(szFileLine, sizeof(szFileLine), szTmp);

  002ec	8d 85 b8 f3 ff
	ff		 lea	 eax, DWORD PTR _szTmp$2[ebp]
  002f2	50		 push	 eax
  002f3	68 00 04 00 00	 push	 1024			; 00000400H
  002f8	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR _szFileLine$3[ebp]
  002fe	51		 push	 ecx
  002ff	e8 00 00 00 00	 call	 _strcat_s
  00304	83 c4 0c	 add	 esp, 12			; 0000000cH

; 923  : 	   }

  00307	e9 98 00 00 00	 jmp	 $LN16@
$LN13@:

; 924  : 	   else if (i == SQUARE_SIZE - 1)

  0030c	83 bd bc fb ff
	ff 00		 cmp	 DWORD PTR _i$5[ebp], 0
  00313	75 76		 jne	 SHORT $LN15@

; 925  : 	   {
; 926  : 		   sprintf_s(szTmp, sizeof(szTmp), "%16.16lf,%16.16lf",

  00315	f2 0f 10 85 d4
	fb ff ff	 movsd	 xmm0, QWORD PTR _im_width$[ebp]
  0031d	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4000000000000000
  00325	f2 0f 58 85 dc
	fb ff ff	 addsd	 xmm0, QWORD PTR _center_im$[ebp]
  0032d	83 ec 08	 sub	 esp, 8
  00330	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00335	f2 0f 10 85 cc
	fb ff ff	 movsd	 xmm0, QWORD PTR _re_width$[ebp]
  0033d	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4000000000000000
  00345	f2 0f 58 85 e4
	fb ff ff	 addsd	 xmm0, QWORD PTR _center_re$[ebp]
  0034d	83 ec 08	 sub	 esp, 8
  00350	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00355	68 00 00 00 00	 push	 OFFSET $SG40797
  0035a	68 00 04 00 00	 push	 1024			; 00000400H
  0035f	8d 85 b8 f3 ff
	ff		 lea	 eax, DWORD PTR _szTmp$2[ebp]
  00365	50		 push	 eax
  00366	e8 00 00 00 00	 call	 _sprintf_s
  0036b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 927  : 			   center_re + re_width / 2,
; 928  : 			   center_im + im_width / 2
; 929  : 			   );
; 930  : 		   strcat_s(szFileLine, sizeof(szFileLine), szTmp);

  0036e	8d 85 b8 f3 ff
	ff		 lea	 eax, DWORD PTR _szTmp$2[ebp]
  00374	50		 push	 eax
  00375	68 00 04 00 00	 push	 1024			; 00000400H
  0037a	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR _szFileLine$3[ebp]
  00380	51		 push	 ecx
  00381	e8 00 00 00 00	 call	 _strcat_s
  00386	83 c4 0c	 add	 esp, 12			; 0000000cH

; 931  : 	   }

  00389	eb 19		 jmp	 SHORT $LN16@
$LN15@:

; 932  : 	   else
; 933  : 	   {
; 934  : 		   strcat_s(szFileLine, sizeof(szFileLine), ",");

  0038b	68 00 00 00 00	 push	 OFFSET $SG40798
  00390	68 00 04 00 00	 push	 1024			; 00000400H
  00395	8d 85 b8 f7 ff
	ff		 lea	 eax, DWORD PTR _szFileLine$3[ebp]
  0039b	50		 push	 eax
  0039c	e8 00 00 00 00	 call	 _strcat_s
  003a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@:

; 935  : 	   }
; 936  : 	   for (int i = 0; i < SQUARE_SIZE; i++)

  003a4	c7 85 b4 f3 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1[ebp], 0
  003ae	eb 0f		 jmp	 SHORT $LN10@
$LN8@:
  003b0	8b 85 b4 f3 ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  003b6	83 c0 01	 add	 eax, 1
  003b9	89 85 b4 f3 ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN10@:
  003bf	83 bd b4 f3 ff
	ff 01		 cmp	 DWORD PTR _i$1[ebp], 1
  003c6	0f 8d 97 00 00
	00		 jge	 $LN9@

; 937  : 	   {
; 938  : 		   if (!log_ended_early)

  003cc	83 bd c0 fb ff
	ff 00		 cmp	 DWORD PTR _log_ended_early$[ebp], 0
  003d3	75 70		 jne	 SHORT $LN17@

; 939  : 		   {
; 940  : 			   sprintf_s(szTmp, sizeof(szTmp), ",%d", iters_log[i]);

  003d5	8b 85 b4 f3 ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  003db	8b 8c 85 c4 fb
	ff ff		 mov	 ecx, DWORD PTR _iters_log$[ebp+eax*4]
  003e2	51		 push	 ecx
  003e3	68 00 00 00 00	 push	 OFFSET $SG40801
  003e8	68 00 04 00 00	 push	 1024			; 00000400H
  003ed	8d 95 b8 f3 ff
	ff		 lea	 edx, DWORD PTR _szTmp$2[ebp]
  003f3	52		 push	 edx
  003f4	e8 00 00 00 00	 call	 _sprintf_s
  003f9	83 c4 10	 add	 esp, 16			; 00000010H

; 941  : 			   strcat_s(szFileLine, sizeof(szFileLine), szTmp);

  003fc	8d 85 b8 f3 ff
	ff		 lea	 eax, DWORD PTR _szTmp$2[ebp]
  00402	50		 push	 eax
  00403	68 00 04 00 00	 push	 1024			; 00000400H
  00408	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR _szFileLine$3[ebp]
  0040e	51		 push	 ecx
  0040f	e8 00 00 00 00	 call	 _strcat_s
  00414	83 c4 0c	 add	 esp, 12			; 0000000cH

; 942  : 			   if (iters_log[i] == m->max_iters)

  00417	8b 85 b4 f3 ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  0041d	8b 4d f4	 mov	 ecx, DWORD PTR _m$[ebp]
  00420	8b 94 85 c4 fb
	ff ff		 mov	 edx, DWORD PTR _iters_log$[ebp+eax*4]
  00427	3b 91 c0 8d 00
	00		 cmp	 edx, DWORD PTR [ecx+36288]
  0042d	75 14		 jne	 SHORT $LN19@

; 943  : 			   {
; 944  : 				   log_ended_early = 1;

  0042f	c7 85 c0 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _log_ended_early$[ebp], 1

; 945  : 				   log_ended_early = 0;

  00439	c7 85 c0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _log_ended_early$[ebp], 0
$LN19@:

; 946  : 			   }
; 947  : 		   }

  00443	eb 19		 jmp	 SHORT $LN18@
$LN17@:

; 948  : 		   else
; 949  : 		   {
; 950  : 			   strcat_s(szFileLine, sizeof(szFileLine), ",");

  00445	68 00 00 00 00	 push	 OFFSET $SG40803
  0044a	68 00 04 00 00	 push	 1024			; 00000400H
  0044f	8d 85 b8 f7 ff
	ff		 lea	 eax, DWORD PTR _szFileLine$3[ebp]
  00455	50		 push	 eax
  00456	e8 00 00 00 00	 call	 _strcat_s
  0045b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@:

; 951  : 		   }
; 952  : 	   }

  0045e	e9 4d ff ff ff	 jmp	 $LN8@
$LN9@:

; 953  : 	   strcat_s(szFileLine, sizeof(szFileLine), "\n");

  00463	68 00 00 00 00	 push	 OFFSET $SG40804
  00468	68 00 04 00 00	 push	 1024			; 00000400H
  0046d	8d 85 b8 f7 ff
	ff		 lea	 eax, DWORD PTR _szFileLine$3[ebp]
  00473	50		 push	 eax
  00474	e8 00 00 00 00	 call	 _strcat_s
  00479	83 c4 0c	 add	 esp, 12			; 0000000cH

; 954  : 	   currLines++;

  0047c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?currLines@?1??queue_point_c@@9@9
  00481	83 c0 01	 add	 eax, 1
  00484	a3 00 00 00 00	 mov	 DWORD PTR ?currLines@?1??queue_point_c@@9@9, eax

; 955  : 	   if (i > 1 && i == SQUARE_SIZE - 1)

  00489	83 bd bc fb ff
	ff 01		 cmp	 DWORD PTR _i$5[ebp], 1
  00490	7e 2f		 jle	 SHORT $LN20@
  00492	83 bd bc fb ff
	ff 00		 cmp	 DWORD PTR _i$5[ebp], 0
  00499	75 26		 jne	 SHORT $LN20@

; 956  : 	   {
; 957  : 		   strcat_s(szFileLine, sizeof(szFileLine), "\n");

  0049b	68 00 00 00 00	 push	 OFFSET $SG40806
  004a0	68 00 04 00 00	 push	 1024			; 00000400H
  004a5	8d 85 b8 f7 ff
	ff		 lea	 eax, DWORD PTR _szFileLine$3[ebp]
  004ab	50		 push	 eax
  004ac	e8 00 00 00 00	 call	 _strcat_s
  004b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 958  : 		   currLines++;

  004b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?currLines@?1??queue_point_c@@9@9
  004b9	83 c0 01	 add	 eax, 1
  004bc	a3 00 00 00 00	 mov	 DWORD PTR ?currLines@?1??queue_point_c@@9@9, eax
$LN20@:

; 959  : 	   }
; 960  : 	   fputs(szFileLine, fp);

  004c1	8b 45 ec	 mov	 eax, DWORD PTR _fp$[ebp]
  004c4	50		 push	 eax
  004c5	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR _szFileLine$3[ebp]
  004cb	51		 push	 ecx
  004cc	e8 00 00 00 00	 call	 _fputs
  004d1	83 c4 08	 add	 esp, 8

; 961  :    }

  004d4	e9 59 fc ff ff	 jmp	 $LN2@
$LN3@:

; 962  :    fclose(fp);

  004d9	8b 45 ec	 mov	 eax, DWORD PTR _fp$[ebp]
  004dc	50		 push	 eax
  004dd	e8 00 00 00 00	 call	 _fclose
  004e2	83 c4 04	 add	 esp, 4

; 963  :    //-------
; 964  : 
; 965  :    ps_ptr->ab_in[0] = center_re;

  004e5	b8 08 00 00 00	 mov	 eax, 8
  004ea	6b c8 00	 imul	 ecx, eax, 0
  004ed	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  004f0	f2 0f 10 85 e4
	fb ff ff	 movsd	 xmm0, QWORD PTR _center_re$[ebp]
  004f8	f2 0f 11 84 0a
	88 03 00 00	 movsd	 QWORD PTR [edx+ecx+904], xmm0

; 966  :    ps_ptr->ab_in[1] = center_im;

  00501	b8 08 00 00 00	 mov	 eax, 8
  00506	c1 e0 00	 shl	 eax, 0
  00509	8b 4d f8	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  0050c	f2 0f 10 85 dc
	fb ff ff	 movsd	 xmm0, QWORD PTR _center_im$[ebp]
  00514	f2 0f 11 84 01
	88 03 00 00	 movsd	 QWORD PTR [ecx+eax+904], xmm0

; 967  :    if (!max_iters_reached)

  0051d	83 bd c8 fb ff
	ff 00		 cmp	 DWORD PTR _max_iters_reached$[ebp], 0
  00524	75 2c		 jne	 SHORT $LN22@

; 968  :    {
; 969  : 	   iters = m->mandel_iterate(ps_ptr);  // No queuing- just iterate 1 point

  00526	8b 45 f8	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  00529	50		 push	 eax
  0052a	8b 4d f4	 mov	 ecx, DWORD PTR _m$[ebp]
  0052d	8b 91 04 78 00
	00		 mov	 edx, DWORD PTR [ecx+30724]
  00533	ff d2		 call	 edx
  00535	83 c4 04	 add	 esp, 4
  00538	89 45 f0	 mov	 DWORD PTR _iters$[ebp], eax

; 970  : 	   if (iters != m->max_iters)          // do this just to match iteration offset of ASM versions

  0053b	8b 45 f4	 mov	 eax, DWORD PTR _m$[ebp]
  0053e	8b 4d f0	 mov	 ecx, DWORD PTR _iters$[ebp]
  00541	3b 88 c0 8d 00
	00		 cmp	 ecx, DWORD PTR [eax+36288]
  00547	74 09		 je	 SHORT $LN22@

; 971  : 		   iters++;

  00549	8b 45 f0	 mov	 eax, DWORD PTR _iters$[ebp]
  0054c	83 c0 01	 add	 eax, 1
  0054f	89 45 f0	 mov	 DWORD PTR _iters$[ebp], eax
$LN22@:

; 972  :    }
; 973  : 
; 974  :    ps_ptr->iters_ptr[0] = iters_ptr;   // Store iters and mag

  00552	b8 04 00 00 00	 mov	 eax, 4
  00557	6b c8 00	 imul	 ecx, eax, 0
  0055a	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  0055d	8b 45 08	 mov	 eax, DWORD PTR _iters_ptr$[ebp]
  00560	89 84 0a 00 03
	00 00		 mov	 DWORD PTR [edx+ecx+768], eax

; 975  :    *ps_ptr->iters_ptr[0] = iters;

  00567	b8 04 00 00 00	 mov	 eax, 4
  0056c	6b c8 00	 imul	 ecx, eax, 0
  0056f	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  00572	8b 84 0a 00 03
	00 00		 mov	 eax, DWORD PTR [edx+ecx+768]
  00579	8b 4d f0	 mov	 ecx, DWORD PTR _iters$[ebp]
  0057c	89 08		 mov	 DWORD PTR [eax], ecx

; 976  :    ps_ptr->iterctr += iters;

  0057e	8b 45 f0	 mov	 eax, DWORD PTR _iters$[ebp]
  00581	33 c9		 xor	 ecx, ecx
  00583	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  00586	03 82 80 03 00
	00		 add	 eax, DWORD PTR [edx+896]
  0058c	13 8a 84 03 00
	00		 adc	 ecx, DWORD PTR [edx+900]
  00592	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  00595	89 82 80 03 00
	00		 mov	 DWORD PTR [edx+896], eax
  0059b	89 8a 84 03 00
	00		 mov	 DWORD PTR [edx+900], ecx

; 977  : 
; 978  :    MAG(m, ps_ptr->iters_ptr[0]) = (float) ps_ptr->mag[0];

  005a1	b8 08 00 00 00	 mov	 eax, 8
  005a6	6b c8 00	 imul	 ecx, eax, 0
  005a9	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  005ac	f2 0f 5a 84 0a
	40 01 00 00	 cvtsd2ss xmm0, QWORD PTR [edx+ecx+320]
  005b5	b8 04 00 00 00	 mov	 eax, 4
  005ba	6b c8 00	 imul	 ecx, eax, 0
  005bd	8b 55 f8	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  005c0	8b 84 0a 00 03
	00 00		 mov	 eax, DWORD PTR [edx+ecx+768]
  005c7	8b 4d f4	 mov	 ecx, DWORD PTR _m$[ebp]
  005ca	8b 91 ec 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36332]
  005d0	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 979  : }

  005d5	5f		 pop	 edi
  005d6	5e		 pop	 esi
  005d7	5b		 pop	 ebx
  005d8	8b e5		 mov	 esp, ebp
  005da	5d		 pop	 ebp
  005db	c2 04 00	 ret	 4
@queue_point_c@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _iterate_c
_TEXT	SEGMENT
_iter_ct$ = -64						; size = 4
_iters$ = -60						; size = 4
_rad$ = -56						; size = 8
_yy$ = -48						; size = 8
_xx$ = -40						; size = 8
_y$ = -32						; size = 8
_x$ = -24						; size = 8
_b$ = -16						; size = 8
_a$ = -8						; size = 8
_ps_ptr$ = 8						; size = 4
_iterate_c PROC						; COMDAT

; 834  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 835  :    double a, b, x, y, xx, yy, rad;
; 836  :    unsigned iters, iter_ct;
; 837  : 
; 838  :    iters = 0;

  0000c	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _iters$[ebp], 0

; 839  :    iter_ct = ps_ptr->cur_max_iters;

  00013	8b 45 08	 mov	 eax, DWORD PTR _ps_ptr$[ebp]
  00016	8b 88 98 03 00
	00		 mov	 ecx, DWORD PTR [eax+920]
  0001c	89 4d c0	 mov	 DWORD PTR _iter_ct$[ebp], ecx

; 840  : 
; 841  :    a = ps_ptr->ab_in[0];

  0001f	b8 08 00 00 00	 mov	 eax, 8
  00024	6b c8 00	 imul	 ecx, eax, 0
  00027	8b 55 08	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  0002a	f2 0f 10 84 0a
	88 03 00 00	 movsd	 xmm0, QWORD PTR [edx+ecx+904]
  00033	f2 0f 11 45 f8	 movsd	 QWORD PTR _a$[ebp], xmm0

; 842  :    b = ps_ptr->ab_in[1];

  00038	b8 08 00 00 00	 mov	 eax, 8
  0003d	c1 e0 00	 shl	 eax, 0
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _ps_ptr$[ebp]
  00043	f2 0f 10 84 01
	88 03 00 00	 movsd	 xmm0, QWORD PTR [ecx+eax+904]
  0004c	f2 0f 11 45 f0	 movsd	 QWORD PTR _b$[ebp], xmm0

; 843  :    rad = DIVERGED_THRESH;

  00051	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4030000000000000
  00059	f2 0f 11 45 c8	 movsd	 QWORD PTR _rad$[ebp], xmm0

; 844  :    x = y = xx = yy = 0.0;

  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	f2 0f 11 45 d0	 movsd	 QWORD PTR _yy$[ebp], xmm0
  00066	f2 0f 10 45 d0	 movsd	 xmm0, QWORD PTR _yy$[ebp]
  0006b	f2 0f 11 45 d8	 movsd	 QWORD PTR _xx$[ebp], xmm0
  00070	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR _xx$[ebp]
  00075	f2 0f 11 45 e0	 movsd	 QWORD PTR _y$[ebp], xmm0
  0007a	f2 0f 10 45 e0	 movsd	 xmm0, QWORD PTR _y$[ebp]
  0007f	f2 0f 11 45 e8	 movsd	 QWORD PTR _x$[ebp], xmm0
$LN4@iterate_c:

; 845  : 
; 846  :    do
; 847  :    {
; 848  :       y = (x + x) * y + b;

  00084	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _x$[ebp]
  00089	f2 0f 58 45 e8	 addsd	 xmm0, QWORD PTR _x$[ebp]
  0008e	f2 0f 59 45 e0	 mulsd	 xmm0, QWORD PTR _y$[ebp]
  00093	f2 0f 58 45 f0	 addsd	 xmm0, QWORD PTR _b$[ebp]
  00098	f2 0f 11 45 e0	 movsd	 QWORD PTR _y$[ebp], xmm0

; 849  :       x = xx - yy + a;

  0009d	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR _xx$[ebp]
  000a2	f2 0f 5c 45 d0	 subsd	 xmm0, QWORD PTR _yy$[ebp]
  000a7	f2 0f 58 45 f8	 addsd	 xmm0, QWORD PTR _a$[ebp]
  000ac	f2 0f 11 45 e8	 movsd	 QWORD PTR _x$[ebp], xmm0

; 850  :       yy = y * y;

  000b1	f2 0f 10 45 e0	 movsd	 xmm0, QWORD PTR _y$[ebp]
  000b6	f2 0f 59 45 e0	 mulsd	 xmm0, QWORD PTR _y$[ebp]
  000bb	f2 0f 11 45 d0	 movsd	 QWORD PTR _yy$[ebp], xmm0

; 851  :       xx = x * x;

  000c0	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _x$[ebp]
  000c5	f2 0f 59 45 e8	 mulsd	 xmm0, QWORD PTR _x$[ebp]
  000ca	f2 0f 11 45 d8	 movsd	 QWORD PTR _xx$[ebp], xmm0

; 852  :       iters++;

  000cf	8b 45 c4	 mov	 eax, DWORD PTR _iters$[ebp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	89 45 c4	 mov	 DWORD PTR _iters$[ebp], eax

; 853  :       if ((xx + yy) >= rad)

  000d8	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR _xx$[ebp]
  000dd	f2 0f 58 45 d0	 addsd	 xmm0, QWORD PTR _yy$[ebp]
  000e2	66 0f 2f 45 c8	 comisd	 xmm0, QWORD PTR _rad$[ebp]
  000e7	72 02		 jb	 SHORT $LN5@iterate_c

; 854  :          break;

  000e9	eb 0b		 jmp	 SHORT $LN3@iterate_c
$LN5@iterate_c:

; 855  :    }
; 856  :    while (--iter_ct);

  000eb	8b 45 c0	 mov	 eax, DWORD PTR _iter_ct$[ebp]
  000ee	83 e8 01	 sub	 eax, 1
  000f1	89 45 c0	 mov	 DWORD PTR _iter_ct$[ebp], eax
  000f4	75 8e		 jne	 SHORT $LN4@iterate_c
$LN3@iterate_c:

; 857  : 
; 858  :    // Store final count and magnitude (squared)
; 859  : 
; 860  :    ps_ptr->mag[0] = xx + yy;  // use this for tmp storage (mag stored to array below)

  000f6	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR _xx$[ebp]
  000fb	f2 0f 58 45 d0	 addsd	 xmm0, QWORD PTR _yy$[ebp]
  00100	b8 08 00 00 00	 mov	 eax, 8
  00105	6b c8 00	 imul	 ecx, eax, 0
  00108	8b 55 08	 mov	 edx, DWORD PTR _ps_ptr$[ebp]
  0010b	f2 0f 11 84 0a
	40 01 00 00	 movsd	 QWORD PTR [edx+ecx+320], xmm0

; 861  : 
; 862  :    return iters;

  00114	8b 45 c4	 mov	 eax, DWORD PTR _iters$[ebp]

; 863  : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
_iterate_c ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _update_re_im_mag
_TEXT	SEGMENT
_m$ = -36						; size = 4
_y$ = -32						; size = 4
_x$ = -28						; size = 4
_yz$ = -24						; size = 8
_xz$ = -16						; size = 8
_tmp_mag$ = -8						; size = 8
_zoom_box$ = 8						; size = 4
_in_outn$ = 12						; size = 4
_x0$ = 16						; size = 4
_y0$ = 20						; size = 4
_x1$ = 24						; size = 4
_y1$ = 28						; size = 4
_update_re_im_mag PROC					; COMDAT

; 780  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 781  :    double tmp_mag, xz, yz;
; 782  :    int x, y;
; 783  :    man_calc_struct *m;
; 784  : 
; 785  :    m = &main_man_calc_struct;

  00009	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 786  : 
; 787  :    tmp_mag = m->mag;

  00010	8b 45 dc	 mov	 eax, DWORD PTR _m$[ebp]
  00013	f2 0f 10 80 b8
	8d 00 00	 movsd	 xmm0, QWORD PTR [eax+36280]
  0001b	f2 0f 11 45 f8	 movsd	 QWORD PTR _tmp_mag$[ebp], xmm0

; 788  : 
; 789  :    if (!zoom_box) // just zoom in or out

  00020	83 7d 08 00	 cmp	 DWORD PTR _zoom_box$[ebp], 0
  00024	75 3d		 jne	 SHORT $LN2@update_re_

; 790  :    {
; 791  :       x = x0;     // point center

  00026	8b 45 10	 mov	 eax, DWORD PTR _x0$[ebp]
  00029	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax

; 792  :       y = y0;

  0002c	8b 45 14	 mov	 eax, DWORD PTR _y0$[ebp]
  0002f	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax

; 793  :       if (in_outn)

  00032	83 7d 0c 00	 cmp	 DWORD PTR _in_outn$[ebp], 0
  00036	74 14		 je	 SHORT $LN4@update_re_

; 794  :          tmp_mag *= MAG_ZOOM_FACTOR;

  00038	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _tmp_mag$[ebp]
  0003d	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4000000000000000
  00045	f2 0f 11 45 f8	 movsd	 QWORD PTR _tmp_mag$[ebp], xmm0
  0004a	eb 12		 jmp	 SHORT $LN5@update_re_
$LN4@update_re_:

; 795  :       else
; 796  :          tmp_mag *= (1.0 / MAG_ZOOM_FACTOR);

  0004c	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _tmp_mag$[ebp]
  00051	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00059	f2 0f 11 45 f8	 movsd	 QWORD PTR _tmp_mag$[ebp], xmm0
$LN5@update_re_:

; 797  :    }

  0005e	e9 98 00 00 00	 jmp	 $LN3@update_re_
$LN2@update_re_:

; 798  :    // Zoom based on box. For zooming in, uses the box size and center to set the
; 799  :    // new point and magnification
; 800  :    else
; 801  :    {
; 802  :       x = abs(x0 - x1);

  00063	8b 45 10	 mov	 eax, DWORD PTR _x0$[ebp]
  00066	2b 45 18	 sub	 eax, DWORD PTR _x1$[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _abs
  0006f	83 c4 04	 add	 esp, 4
  00072	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax

; 803  :       y = abs(y0 - y1);

  00075	8b 45 14	 mov	 eax, DWORD PTR _y0$[ebp]
  00078	2b 45 1c	 sub	 eax, DWORD PTR _y1$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _abs
  00081	83 c4 04	 add	 esp, 4
  00084	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax

; 804  : 
; 805  :       // Get smaller of xzoom and yzoom
; 806  :       xz = (double) m->xsize / (double) x;

  00087	8b 45 dc	 mov	 eax, DWORD PTR _m$[ebp]
  0008a	f2 0f 2a 80 88
	8d 00 00	 cvtsi2sd xmm0, DWORD PTR [eax+36232]
  00092	f2 0f 2a 4d e4	 cvtsi2sd xmm1, DWORD PTR _x$[ebp]
  00097	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0009b	f2 0f 11 45 f0	 movsd	 QWORD PTR _xz$[ebp], xmm0

; 807  :       yz = (double) m->ysize / (double) y;

  000a0	8b 45 dc	 mov	 eax, DWORD PTR _m$[ebp]
  000a3	f2 0f 2a 80 8c
	8d 00 00	 cvtsi2sd xmm0, DWORD PTR [eax+36236]
  000ab	f2 0f 2a 4d e0	 cvtsi2sd xmm1, DWORD PTR _y$[ebp]
  000b0	f2 0f 5e c1	 divsd	 xmm0, xmm1
  000b4	f2 0f 11 45 e8	 movsd	 QWORD PTR _yz$[ebp], xmm0

; 808  : 
; 809  :       if (xz < yz)

  000b9	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _yz$[ebp]
  000be	66 0f 2f 45 f0	 comisd	 xmm0, QWORD PTR _xz$[ebp]
  000c3	76 11		 jbe	 SHORT $LN6@update_re_

; 810  :          tmp_mag *= xz;

  000c5	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _tmp_mag$[ebp]
  000ca	f2 0f 59 45 f0	 mulsd	 xmm0, QWORD PTR _xz$[ebp]
  000cf	f2 0f 11 45 f8	 movsd	 QWORD PTR _tmp_mag$[ebp], xmm0
  000d4	eb 0f		 jmp	 SHORT $LN7@update_re_
$LN6@update_re_:

; 811  :       else
; 812  :          tmp_mag *= yz;

  000d6	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _tmp_mag$[ebp]
  000db	f2 0f 59 45 e8	 mulsd	 xmm0, QWORD PTR _yz$[ebp]
  000e0	f2 0f 11 45 f8	 movsd	 QWORD PTR _tmp_mag$[ebp], xmm0
$LN7@update_re_:

; 813  : 
; 814  :       x = (x0 + x1) >> 1; // new point center:

  000e5	8b 45 10	 mov	 eax, DWORD PTR _x0$[ebp]
  000e8	03 45 18	 add	 eax, DWORD PTR _x1$[ebp]
  000eb	d1 f8		 sar	 eax, 1
  000ed	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax

; 815  :       y = (y0 + y1) >> 1; // center of zoom box

  000f0	8b 45 14	 mov	 eax, DWORD PTR _y0$[ebp]
  000f3	03 45 1c	 add	 eax, DWORD PTR _y1$[ebp]
  000f6	d1 f8		 sar	 eax, 1
  000f8	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax
$LN3@update_re_:

; 816  :    }
; 817  : 
; 818  :    // Get new point center, based on x, y
; 819  : 
; 820  :    //if (in_outn) // uncomment to not center when zooming out
; 821  :    update_re_im(m, x - (m->xsize >> 1), y - (m->ysize >> 1)); // re/im already updated with any pan offsets here

  000fb	8b 45 dc	 mov	 eax, DWORD PTR _m$[ebp]
  000fe	8b 88 8c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36236]
  00104	d1 f9		 sar	 ecx, 1
  00106	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00109	2b c1		 sub	 eax, ecx
  0010b	99		 cdq
  0010c	52		 push	 edx
  0010d	50		 push	 eax
  0010e	8b 55 dc	 mov	 edx, DWORD PTR _m$[ebp]
  00111	8b 82 88 8d 00
	00		 mov	 eax, DWORD PTR [edx+36232]
  00117	d1 f8		 sar	 eax, 1
  00119	8b 4d e4	 mov	 ecx, DWORD PTR _x$[ebp]
  0011c	2b c8		 sub	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	99		 cdq
  00121	52		 push	 edx
  00122	50		 push	 eax
  00123	8b 55 dc	 mov	 edx, DWORD PTR _m$[ebp]
  00126	52		 push	 edx
  00127	e8 00 00 00 00	 call	 _update_re_im
  0012c	83 c4 14	 add	 esp, 20			; 00000014H

; 822  : 
; 823  :    // Update mag
; 824  :    if (tmp_mag >= MAG_MIN) // preserve closest min, to allow

  0012f	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _tmp_mag$[ebp]
  00134	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3f947ae147ae147b
  0013c	72 10		 jb	 SHORT $LN8@update_re_

; 825  :       m->mag = tmp_mag;       // zooming back to original mag

  0013e	8b 45 dc	 mov	 eax, DWORD PTR _m$[ebp]
  00141	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _tmp_mag$[ebp]
  00146	f2 0f 11 80 b8
	8d 00 00	 movsd	 QWORD PTR [eax+36280], xmm0
$LN8@update_re_:

; 826  : }

  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	5b		 pop	 ebx
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c3		 ret	 0
_update_re_im_mag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _update_re_im
_TEXT	SEGMENT
tv131 = -72						; size = 8
tv87 = -72						; size = 8
_m$ = 8							; size = 4
_xoffs$ = 12						; size = 8
_yoffs$ = 20						; size = 8
_update_re_im PROC					; COMDAT

; 763  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 764  :    m->re += get_re_im_offs(m, xoffs);

  00009	8b 45 10	 mov	 eax, DWORD PTR _xoffs$[ebp+4]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _xoffs$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _get_re_im_offs
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	dd 5d b8	 fstp	 QWORD PTR tv87[ebp]
  00020	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00023	f2 0f 10 45 b8	 movsd	 xmm0, QWORD PTR tv87[ebp]
  00028	f2 0f 58 80 a8
	8d 00 00	 addsd	 xmm0, QWORD PTR [eax+36264]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  00033	f2 0f 11 81 a8
	8d 00 00	 movsd	 QWORD PTR [ecx+36264], xmm0

; 765  :    m->im -= get_re_im_offs(m, yoffs);

  0003b	8b 45 18	 mov	 eax, DWORD PTR _yoffs$[ebp+4]
  0003e	50		 push	 eax
  0003f	8b 4d 14	 mov	 ecx, DWORD PTR _yoffs$[ebp]
  00042	51		 push	 ecx
  00043	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 _get_re_im_offs
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	dd 5d b8	 fstp	 QWORD PTR tv131[ebp]
  00052	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00055	f2 0f 10 80 b0
	8d 00 00	 movsd	 xmm0, QWORD PTR [eax+36272]
  0005d	f2 0f 5c 45 b8	 subsd	 xmm0, QWORD PTR tv131[ebp]
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  00065	f2 0f 11 81 b0
	8d 00 00	 movsd	 QWORD PTR [ecx+36272], xmm0

; 766  :    m->pan_xoffs = 0;

  0006d	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00070	c7 80 98 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36248], 0
  0007a	c7 80 9c 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36252], 0

; 767  :    m->pan_yoffs = 0;

  00084	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00087	c7 80 a0 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36256], 0
  00091	c7 80 a4 8d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+36260], 0

; 768  : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_update_re_im ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_re_im_offs
_TEXT	SEGMENT
tv79 = -72						; size = 8
_m$ = 8							; size = 4
_offs$ = 12						; size = 8
_get_re_im_offs PROC					; COMDAT

; 752  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 753  :   return (((double) offs * 4.0) / (double) m->min_dimension) / m->mag;

  00009	8b 55 10	 mov	 edx, DWORD PTR _offs$[ebp+4]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _offs$[ebp]
  0000f	e8 00 00 00 00	 call	 __ltod3
  00014	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4010000000000000
  0001c	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0001f	f2 0f 2a 88 90
	8d 00 00	 cvtsi2sd xmm1, DWORD PTR [eax+36240]
  00027	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0002e	f2 0f 5e 81 b8
	8d 00 00	 divsd	 xmm0, QWORD PTR [ecx+36280]
  00036	f2 0f 11 45 b8	 movsd	 QWORD PTR tv79[ebp], xmm0
  0003b	dd 45 b8	 fld	 QWORD PTR tv79[ebp]

; 754  : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_get_re_im_offs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _reset_fps_values
_TEXT	SEGMENT
_reset_fps_values PROC					; COMDAT

; 737  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 738  :    total_frames = 0;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _total_frames, 0

; 739  :    interval_frames = 0;

  00013	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _interval_frames, 0

; 740  :    calc_interval_time = 0.0;

  0001d	0f 57 c0	 xorps	 xmm0, xmm0
  00020	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _calc_interval_time, xmm0

; 741  :    calc_total_time = 0.0;

  00028	0f 57 c0	 xorps	 xmm0, xmm0
  0002b	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _calc_total_time, xmm0

; 742  :    interval_time = 0.0;

  00033	0f 57 c0	 xorps	 xmm0, xmm0
  00036	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _interval_time, xmm0

; 743  :    total_time = 0.0;

  0003e	0f 57 c0	 xorps	 xmm0, xmm0
  00041	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _total_time, xmm0

; 744  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_reset_fps_values ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _reset_thread_load_counters
_TEXT	SEGMENT
_m$ = -8						; size = 4
_i$ = -4						; size = 4
_reset_thread_load_counters PROC			; COMDAT

; 726  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 727  :    int i;
; 728  :    man_calc_struct *m;
; 729  : 
; 730  :    m = &main_man_calc_struct;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 731  :    for (i = 0; i < MAX_THREADS; i++)

  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@reset_thre
$LN2@reset_thre:
  00019	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@reset_thre:
  00022	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00026	7d 22		 jge	 SHORT $LN1@reset_thre

; 732  :       m->thread_states[i].total_iters = 0;

  00028	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 168
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _m$[ebp]
  00032	c7 84 01 a0 78
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+30880], 0
  0003d	c7 84 01 a4 78
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+30884], 0
  00048	eb cf		 jmp	 SHORT $LN2@reset_thre
$LN1@reset_thre:

; 733  : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_reset_thread_load_counters ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_keys_pressed
_TEXT	SEGMENT
_key$ = -8						; size = 4
_i$ = -4						; size = 4
_get_keys_pressed PROC					; COMDAT

; 710  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 711  :    int i, key = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _key$[ebp], 0

; 712  :    static SHORT vkeys[] = {VK_LEFT, 'A', VK_RIGHT, 'D', VK_UP, 'W', VK_DOWN, 'S', VK_CONTROL, VK_SHIFT};
; 713  :    static int keybits[] = {KEY_LEFT, KEY_LEFT, KEY_RIGHT, KEY_RIGHT, KEY_UP, KEY_UP,
; 714  :                            KEY_DOWN, KEY_DOWN, KEY_CTRL, KEY_SHIFT};
; 715  : 
; 716  :    for (i = 0; i < NUM_ELEM(vkeys); i++)

  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@get_keys_p
$LN2@get_keys_p:
  00019	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@get_keys_p:
  00022	83 7d fc 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  00026	73 2f		 jae	 SHORT $LN3@get_keys_p

; 717  :       if (GetAsyncKeyState(vkeys[i]) & KEYDOWN_BIT)

  00028	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002b	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?vkeys@?1??get_keys_pressed@@9@9[eax*2]
  00033	51		 push	 ecx
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetAsyncKeyState@4
  0003a	0f bf d0	 movsx	 edx, ax
  0003d	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  00043	74 10		 je	 SHORT $LN5@get_keys_p

; 718  :          key |= keybits[i];

  00045	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _key$[ebp]
  0004b	0b 0c 85 00 00
	00 00		 or	 ecx, DWORD PTR ?keybits@?1??get_keys_pressed@@9@9[eax*4]
  00052	89 4d f8	 mov	 DWORD PTR _key$[ebp], ecx
$LN5@get_keys_p:
  00055	eb c2		 jmp	 SHORT $LN2@get_keys_p
$LN3@get_keys_p:

; 719  : 
; 720  :    return key;

  00057	8b 45 f8	 mov	 eax, DWORD PTR _key$[ebp]

; 721  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_get_keys_pressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_seconds_elapsed
_TEXT	SEGMENT
tv76 = -80						; size = 8
tv70 = -72						; size = 4
_t$ = -4						; size = 4
_start_time$ = 8					; size = 4
_get_seconds_elapsed PROC				; COMDAT

; 681  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 682  :    TIME_UNIT t;
; 683  :    #ifdef USE_PERFORMANCE_COUNTER
; 684  :    QueryPerformanceFrequency(&f);
; 685  :    QueryPerformanceCounter(&t);
; 686  :    t.QuadPart -= start_time.QuadPart;
; 687  :    if (f.QuadPart)
; 688  :       return (double) t.QuadPart / (double) f.QuadPart;
; 689  :    return 1e10;
; 690  :    #else
; 691  :    // Need to use TIME_UNIT (dword) to avoid wrapping issues with timeGetTime().
; 692  :    // Can subtract in DWORD domain, but not double.
; 693  :    t = timeGetTime() - start_time;

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0000f	2b 45 08	 sub	 eax, DWORD PTR _start_time$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 694  :    return 1e-3 * (double) t;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  00018	89 45 b8	 mov	 DWORD PTR tv70[ebp], eax
  0001b	f2 0f 2a 45 b8	 cvtsi2sd xmm0, DWORD PTR tv70[ebp]
  00020	8b 4d b8	 mov	 ecx, DWORD PTR tv70[ebp]
  00023	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00026	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  0002f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3f50624dd2f1a9fc
  00037	f2 0f 11 45 b0	 movsd	 QWORD PTR tv76[ebp], xmm0
  0003c	dd 45 b0	 fld	 QWORD PTR tv76[ebp]

; 695  :    #endif
; 696  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_get_seconds_elapsed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _get_timer
_TEXT	SEGMENT
_get_timer PROC						; COMDAT

; 669  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 670  :    #ifdef USE_PERFORMANCE_COUNTER
; 671  :    TIME_UNIT t;
; 672  :    QueryPerformanceCounter(&t);
; 673  :    return t;
; 674  :    #else
; 675  :    return timeGetTime();

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0

; 676  :    #endif
; 677  : }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_get_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _add_user_palettes_and_logfiles
_TEXT	SEGMENT
_ind$ = -16						; size = 4
_n$ = -12						; size = 4
_i$ = -8						; size = 4
_h$ = -4						; size = 4
_add_user_palettes_and_logfiles PROC			; COMDAT

; 648  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 649  :    HANDLE h = hwnd_dialog;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  0000e	89 45 fc	 mov	 DWORD PTR _h$[ebp], eax

; 650  :    int i, n = NUM_ELEM(file_strs);

  00011	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _n$[ebp], 2

; 651  :    LRESULT ind;
; 652  : 
; 653  :    SendDlgItemMessage(h, IDC_PALETTE, CB_DIR, DDL_READONLY | DDL_READWRITE, (LPARAM) "*.pal");

  00018	68 00 00 00 00	 push	 OFFSET $SG40626
  0001d	6a 01		 push	 1
  0001f	68 45 01 00 00	 push	 325			; 00000145H
  00024	68 03 04 00 00	 push	 1027			; 00000403H
  00029	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 654  :    SendDlgItemMessage(h, IDC_PALETTE, CB_DIR, DDL_READONLY | DDL_READWRITE, (LPARAM) "*.bmp");

  00033	68 00 00 00 00	 push	 OFFSET $SG40627
  00038	6a 01		 push	 1
  0003a	68 45 01 00 00	 push	 325			; 00000145H
  0003f	68 03 04 00 00	 push	 1027			; 00000403H
  00044	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  00047	50		 push	 eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 655  :    SendDlgItemMessage(h, IDC_LOGFILE, CB_DIR, DDL_READONLY | DDL_READWRITE, (LPARAM) "*.log");

  0004e	68 00 00 00 00	 push	 OFFSET $SG40628
  00053	6a 01		 push	 1
  00055	68 45 01 00 00	 push	 325			; 00000145H
  0005a	68 07 04 00 00	 push	 1031			; 00000407H
  0005f	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  00062	50		 push	 eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 656  : 
; 657  :    // Delete any logfiles that were already in the presets list (don't want to list them twice)
; 658  :    for (i = 0; i < n; i++)

  00069	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00070	eb 09		 jmp	 SHORT $LN4@add_user_p
$LN2@add_user_p:
  00072	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00075	83 c0 01	 add	 eax, 1
  00078	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@add_user_p:
  0007b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007e	3b 45 f4	 cmp	 eax, DWORD PTR _n$[ebp]
  00081	7d 4d		 jge	 SHORT $LN1@add_user_p

; 659  :       if ((ind = SendDlgItemMessage(h, IDC_LOGFILE, CB_FINDSTRINGEXACT, n - 1, (LPARAM) file_strs[i])) >= n)

  00083	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00086	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _file_strs[eax*4]
  0008d	51		 push	 ecx
  0008e	8b 55 f4	 mov	 edx, DWORD PTR _n$[ebp]
  00091	83 ea 01	 sub	 edx, 1
  00094	52		 push	 edx
  00095	68 58 01 00 00	 push	 344			; 00000158H
  0009a	68 07 04 00 00	 push	 1031			; 00000407H
  0009f	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  000a2	50		 push	 eax
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
  000a9	89 45 f0	 mov	 DWORD PTR _ind$[ebp], eax
  000ac	8b 4d f0	 mov	 ecx, DWORD PTR _ind$[ebp]
  000af	3b 4d f4	 cmp	 ecx, DWORD PTR _n$[ebp]
  000b2	7c 1a		 jl	 SHORT $LN5@add_user_p

; 660  :          SendDlgItemMessage(h, IDC_LOGFILE, CB_DELETESTRING, (WPARAM) ind, 0);

  000b4	6a 00		 push	 0
  000b6	8b 45 f0	 mov	 eax, DWORD PTR _ind$[ebp]
  000b9	50		 push	 eax
  000ba	68 44 01 00 00	 push	 324			; 00000144H
  000bf	68 07 04 00 00	 push	 1031			; 00000407H
  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _h$[ebp]
  000c7	51		 push	 ecx
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
$LN5@add_user_p:
  000ce	eb a2		 jmp	 SHORT $LN2@add_user_p
$LN1@add_user_p:

; 661  : }

  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
_add_user_palettes_and_logfiles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _read_cfg_file
_TEXT	SEGMENT
tv79 = -72						; size = 4
_m$ = -4						; size = 4
_read_cfg_file PROC					; COMDAT

; 616  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 617  :    man_calc_struct *m;
; 618  : 
; 619  :    m = &main_man_calc_struct;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 620  : 
; 621  :    // The cfg file is just another logfile, but it shouldn't have any images in it.
; 622  :    // If it does, the settings will be reset after each image.
; 623  :    //
; 624  :    // This file will update the values in the cfg_settings structure. If it's missing,
; 625  :    // the default settings in the structure will be used.
; 626  : 
; 627  :    invalidate_settings(&cur_file_settings); // initialize all to "no change"

  00010	68 00 00 00 00	 push	 OFFSET _cur_file_settings
  00015	e8 00 00 00 00	 call	 _invalidate_settings
  0001a	83 c4 04	 add	 esp, 4

; 628  : 
; 629  :    log_read(CFG_FILE, NULL, 1); // NULL = no error message on failure to read

  0001d	6a 01		 push	 1
  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET $SG40608
  00026	e8 00 00 00 00	 call	 _log_read
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 630  : 
; 631  :    copy_changed_settings(&cfg_settings, &cur_file_settings, 1); // 1 = copy to default_val also

  0002e	6a 01		 push	 1
  00030	68 00 00 00 00	 push	 OFFSET _cur_file_settings
  00035	68 00 00 00 00	 push	 OFFSET _cfg_settings
  0003a	e8 00 00 00 00	 call	 _copy_changed_settings
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 632  : 
; 633  :    // maybe eliminate these separate variables later
; 634  :    m->xsize = prev_xsize = cfg_settings.xsize.val;

  00042	a1 54 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+84
  00047	a3 00 00 00 00	 mov	 DWORD PTR _prev_xsize, eax
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  0004f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _prev_xsize
  00055	89 91 88 8d 00
	00		 mov	 DWORD PTR [ecx+36232], edx

; 635  :    m->ysize = prev_ysize = cfg_settings.ysize.val;

  0005b	a1 68 00 00 00	 mov	 eax, DWORD PTR _cfg_settings+104
  00060	a3 00 00 00 00	 mov	 DWORD PTR _prev_ysize, eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  00068	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _prev_ysize
  0006e	89 91 8c 8d 00
	00		 mov	 DWORD PTR [ecx+36236], edx

; 636  : 
; 637  :    m->min_dimension = m->xsize > m->ysize ? m->ysize : m->xsize; // just so 1st dialog box doesn't get div by 0

  00074	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  0007a	8b 90 88 8d 00
	00		 mov	 edx, DWORD PTR [eax+36232]
  00080	3b 91 8c 8d 00
	00		 cmp	 edx, DWORD PTR [ecx+36236]
  00086	7e 0e		 jle	 SHORT $LN3@read_cfg_f
  00088	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  0008b	8b 88 8c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36236]
  00091	89 4d b8	 mov	 DWORD PTR tv79[ebp], ecx
  00094	eb 0c		 jmp	 SHORT $LN4@read_cfg_f
$LN3@read_cfg_f:
  00096	8b 55 fc	 mov	 edx, DWORD PTR _m$[ebp]
  00099	8b 82 88 8d 00
	00		 mov	 eax, DWORD PTR [edx+36232]
  0009f	89 45 b8	 mov	 DWORD PTR tv79[ebp], eax
$LN4@read_cfg_f:
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  000a5	8b 55 b8	 mov	 edx, DWORD PTR tv79[ebp]
  000a8	89 91 90 8d 00
	00		 mov	 DWORD PTR [ecx+36240], edx

; 638  :    m->max_iters_color = cfg_settings.max_iters_color.val;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  000b1	8b 0d 7c 00 00
	00		 mov	 ecx, DWORD PTR _cfg_settings+124
  000b7	89 88 00 8e 00
	00		 mov	 DWORD PTR [eax+36352], ecx

; 639  : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_read_cfg_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _log_get
_TEXT	SEGMENT
_m$ = -8						; size = 4
_e$ = -4						; size = 4
_next_prevn$ = 8					; size = 4
_log_get PROC						; COMDAT

; 582  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 583  :    log_entry *e;
; 584  :    man_calc_struct *m;
; 585  : 
; 586  :    m = &main_man_calc_struct;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 587  : 
; 588  :    if (log_entries == NULL)

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _log_entries, 0
  00017	75 07		 jne	 SHORT $LN2@log_get

; 589  :       return NULL;

  00019	33 c0		 xor	 eax, eax
  0001b	e9 c2 00 00 00	 jmp	 $LN1@log_get
$LN2@log_get:

; 590  : 
; 591  :    if (next_prevn)

  00020	83 7d 08 00	 cmp	 DWORD PTR _next_prevn$[ebp], 0
  00024	74 2a		 je	 SHORT $LN3@log_get

; 592  :    {
; 593  :       if (++log_pos > log_count - 1)

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR _log_pos
  0002b	83 c0 01	 add	 eax, 1
  0002e	a3 00 00 00 00	 mov	 DWORD PTR _log_pos, eax
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _log_count
  00039	83 e9 01	 sub	 ecx, 1
  0003c	39 0d 00 00 00
	00		 cmp	 DWORD PTR _log_pos, ecx
  00042	7e 0a		 jle	 SHORT $LN5@log_get

; 594  :          // log_pos = log_count - 1; // stop at end
; 595  :          log_pos = 0;                // wrap to beginning

  00044	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _log_pos, 0
$LN5@log_get:

; 596  :    }

  0004e	eb 1c		 jmp	 SHORT $LN6@log_get
$LN3@log_get:

; 597  :    else
; 598  :       if (--log_pos < 0)

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR _log_pos
  00055	83 e8 01	 sub	 eax, 1
  00058	a3 00 00 00 00	 mov	 DWORD PTR _log_pos, eax
  0005d	79 0d		 jns	 SHORT $LN6@log_get

; 599  :          // log_pos = 0;            // stop at beginning
; 600  :          log_pos = log_count - 1;   // wrap to end

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _log_count
  00064	83 e8 01	 sub	 eax, 1
  00067	a3 00 00 00 00	 mov	 DWORD PTR _log_pos, eax
$LN6@log_get:

; 601  : 
; 602  :    e = &log_entries[log_pos];

  0006c	69 05 00 00 00
	00 28 01 00 00	 imul	 eax, DWORD PTR _log_pos, 296
  00076	03 05 00 00 00
	00		 add	 eax, DWORD PTR _log_entries
  0007c	89 45 fc	 mov	 DWORD PTR _e$[ebp], eax

; 603  : 
; 604  :    m->re = e->re;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _e$[ebp]
  00085	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  00089	f2 0f 11 80 a8
	8d 00 00	 movsd	 QWORD PTR [eax+36264], xmm0

; 605  :    m->im = e->im;

  00091	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  00094	8b 4d fc	 mov	 ecx, DWORD PTR _e$[ebp]
  00097	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [ecx+8]
  0009c	f2 0f 11 80 b0
	8d 00 00	 movsd	 QWORD PTR [eax+36272], xmm0

; 606  :    m->mag = e->mag;

  000a4	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _e$[ebp]
  000aa	f2 0f 10 41 10	 movsd	 xmm0, QWORD PTR [ecx+16]
  000af	f2 0f 11 80 b8
	8d 00 00	 movsd	 QWORD PTR [eax+36280], xmm0

; 607  :    m->max_iters = e->max_iters;

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _e$[ebp]
  000bd	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000c0	89 90 c0 8d 00
	00		 mov	 DWORD PTR [eax+36288], edx

; 608  :    if (!(status & STAT_PALETTE_LOCKED))

  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  000cb	83 e0 20	 and	 eax, 32			; 00000020H
  000ce	75 0f		 jne	 SHORT $LN7@log_get

; 609  :       m->palette = e->palette;

  000d0	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _e$[ebp]
  000d6	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000d9	89 90 f4 8d 00
	00		 mov	 DWORD PTR [eax+36340], edx
$LN7@log_get:

; 610  : 
; 611  :    return e;

  000df	8b 45 fc	 mov	 eax, DWORD PTR _e$[ebp]
$LN1@log_get:

; 612  : }

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
_log_get ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _log_update
_TEXT	SEGMENT
_m$ = -776						; size = 4
_fp$ = -772						; size = 4
_p$ = -768						; size = 256
_s$ = -512						; size = 512
_file$ = 8						; size = 4
_reset_pos$ = 12					; size = 4
_log_update PROC					; COMDAT

; 538  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 03 00
	00		 sub	 esp, 904		; 00000388H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 539  :    char s[512], p[256];
; 540  :    FILE *fp;
; 541  :    man_calc_struct *m;
; 542  : 
; 543  :    m = &main_man_calc_struct;

  0000c	c7 85 f8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 544  : 
; 545  :    if (fopen_s(&fp, file, "at")) // open for append

  00016	68 00 00 00 00	 push	 OFFSET $SG40575
  0001b	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0001e	50		 push	 eax
  0001f	8d 8d fc fc ff
	ff		 lea	 ecx, DWORD PTR _fp$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _fopen_s
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	85 c0		 test	 eax, eax
  00030	74 3a		 je	 SHORT $LN2@log_update

; 546  :    {
; 547  :       sprintf_s(s, sizeof(s), "Could not open '%s' for write.", file);

  00032	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET $SG40576
  0003b	68 00 02 00 00	 push	 512			; 00000200H
  00040	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 _sprintf_s
  0004c	83 c4 10	 add	 esp, 16			; 00000010H

; 548  :       MessageBox(NULL, s, NULL, MB_OK | MB_ICONSTOP | MB_TASKMODAL);

  0004f	68 10 20 00 00	 push	 8208			; 00002010H
  00054	6a 00		 push	 0
  00056	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0005c	50		 push	 eax
  0005d	6a 00		 push	 0
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 549  :       return 0;

  00065	33 c0		 xor	 eax, eax
  00067	e9 4e 01 00 00	 jmp	 $LN1@log_update
$LN2@log_update:

; 550  :    }
; 551  : 
; 552  :    // For palette, use either number (for builtin palette), or "file" for user file
; 553  :    if (m->palette < num_builtin_palettes)

  0006c	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00072	8b 88 f4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36340]
  00078	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _num_builtin_palettes
  0007e	73 28		 jae	 SHORT $LN3@log_update

; 554  :       sprintf_s(p, sizeof(p), "%d", m->palette);

  00080	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  00086	8b 88 f4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36340]
  0008c	51		 push	 ecx
  0008d	68 00 00 00 00	 push	 OFFSET $SG40579
  00092	68 00 01 00 00	 push	 256			; 00000100H
  00097	8d 95 00 fd ff
	ff		 lea	 edx, DWORD PTR _p$[ebp]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _sprintf_s
  000a3	83 c4 10	 add	 esp, 16			; 00000010H
  000a6	eb 1e		 jmp	 SHORT $LN4@log_update
$LN3@log_update:

; 555  :    else
; 556  :       sprintf_s(p, sizeof(p), "\"%s\"", palette_file);

  000a8	68 00 00 00 00	 push	 OFFSET _palette_file
  000ad	68 00 00 00 00	 push	 OFFSET $SG40580
  000b2	68 00 01 00 00	 push	 256			; 00000100H
  000b7	8d 85 00 fd ff
	ff		 lea	 eax, DWORD PTR _p$[ebp]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _sprintf_s
  000c3	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@log_update:

; 557  : 
; 558  :    if (m->pal_xor) // add palette modification if it's in effect - v1.07

  000c6	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  000cc	83 b8 fc 8d 00
	00 00		 cmp	 DWORD PTR [eax+36348], 0
  000d3	74 3c		 je	 SHORT $LN5@log_update

; 559  :    {
; 560  :       sprintf_s(s, sizeof(s), "\npal_xor 0x%06X", m->pal_xor);

  000d5	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  000db	8b 88 fc 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36348]
  000e1	51		 push	 ecx
  000e2	68 00 00 00 00	 push	 OFFSET $SG40582
  000e7	68 00 02 00 00	 push	 512			; 00000200H
  000ec	8d 95 00 fe ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  000f2	52		 push	 edx
  000f3	e8 00 00 00 00	 call	 _sprintf_s
  000f8	83 c4 10	 add	 esp, 16			; 00000010H

; 561  :       fputs(s, fp);

  000fb	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  00101	50		 push	 eax
  00102	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00108	51		 push	 ecx
  00109	e8 00 00 00 00	 call	 _fputs
  0010e	83 c4 08	 add	 esp, 8
$LN5@log_update:

; 562  :    }
; 563  :    // Logfile read function ignores any leading items
; 564  :    sprintf_s(s, sizeof(s),

  00111	8d 85 00 fd ff
	ff		 lea	 eax, DWORD PTR _p$[ebp]
  00117	50		 push	 eax
  00118	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  0011e	8b 91 c0 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36288]
  00124	52		 push	 edx
  00125	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR _m$[ebp]
  0012b	83 ec 08	 sub	 esp, 8
  0012e	f2 0f 10 80 b8
	8d 00 00	 movsd	 xmm0, QWORD PTR [eax+36280]
  00136	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0013b	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00141	83 ec 08	 sub	 esp, 8
  00144	f2 0f 10 81 b0
	8d 00 00	 movsd	 xmm0, QWORD PTR [ecx+36272]
  0014c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00151	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR _m$[ebp]
  00157	83 ec 08	 sub	 esp, 8
  0015a	f2 0f 10 82 a8
	8d 00 00	 movsd	 xmm0, QWORD PTR [edx+36264]
  00162	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00167	68 00 00 00 00	 push	 OFFSET $SG40583
  0016c	68 00 02 00 00	 push	 512			; 00000200H
  00171	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 _sprintf_s
  0017d	83 c4 2c	 add	 esp, 44			; 0000002cH

; 565  :               "\nReal     %-16.16lf\n"
; 566  :               "Imag     %-16.16lf\n"
; 567  :               "Mag      %-16lf\n"
; 568  :               "Iters    %d\n"
; 569  :               "Palette  %s\n",
; 570  :               m->re, m->im, m->mag, m->max_iters, p);
; 571  : 
; 572  :    fputs(s, fp);

  00180	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  00186	50		 push	 eax
  00187	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  0018d	51		 push	 ecx
  0018e	e8 00 00 00 00	 call	 _fputs
  00193	83 c4 08	 add	 esp, 8

; 573  :    fclose(fp);

  00196	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 _fclose
  001a2	83 c4 04	 add	 esp, 4

; 574  : 
; 575  :    // Now reread the logfile (need to reallocate array) - a bit inefficient but who cares...
; 576  :    // Keep current position
; 577  :    return log_read(file, "", reset_pos);

  001a5	8b 45 0c	 mov	 eax, DWORD PTR _reset_pos$[ebp]
  001a8	50		 push	 eax
  001a9	68 00 00 00 00	 push	 OFFSET $SG40584
  001ae	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  001b1	51		 push	 ecx
  001b2	e8 00 00 00 00	 call	 _log_read
  001b7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@log_update:

; 578  : }

  001ba	5f		 pop	 edi
  001bb	5e		 pop	 esi
  001bc	5b		 pop	 ebx
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c3		 ret	 0
_log_update ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _log_read
_TEXT	SEGMENT
_fp$ = -12						; size = 4
_count$ = -8						; size = 4
_i$ = -4						; size = 4
_file$ = 8						; size = 4
_msg$ = 12						; size = 4
_init_pos$ = 16						; size = 4
_log_read PROC						; COMDAT

; 496  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 497  :    int i, count;
; 498  :    FILE *fp;
; 499  : 
; 500  :    log_count = 0;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _log_count, 0

; 501  :    if (init_pos)

  00013	83 7d 10 00	 cmp	 DWORD PTR _init_pos$[ebp], 0
  00017	74 15		 je	 SHORT $LN8@log_read

; 502  :    {
; 503  :       log_pos = -1;

  00019	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _log_pos, -1

; 504  :       file_tot_time = 0.0; // for benchmarking

  00023	0f 57 c0	 xorps	 xmm0, xmm0
  00026	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _file_tot_time, xmm0
$LN8@log_read:

; 505  :    }
; 506  : 
; 507  :    // Kind of inefficient: scan once to get length, then scan again to fill in array
; 508  :    if ((fp = open_file(file, msg, 0)) == NULL)

  0002e	6a 00		 push	 0
  00030	8b 45 0c	 mov	 eax, DWORD PTR _msg$[ebp]
  00033	50		 push	 eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _open_file
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	89 45 f4	 mov	 DWORD PTR _fp$[ebp], eax
  00043	83 7d f4 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00047	75 07		 jne	 SHORT $LN9@log_read

; 509  :       return 0;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 e7 00 00 00	 jmp	 $LN1@log_read
$LN9@log_read:

; 510  : 
; 511  :    for (count = 0; log_read_entry(NULL, fp); count++)

  00050	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00057	eb 09		 jmp	 SHORT $LN4@log_read
$LN2@log_read:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN4@log_read:
  00062	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  00065	50		 push	 eax
  00066	6a 00		 push	 0
  00068	e8 00 00 00 00	 call	 _log_read_entry
  0006d	83 c4 08	 add	 esp, 8
  00070	85 c0		 test	 eax, eax
  00072	74 02		 je	 SHORT $LN3@log_read

; 512  :       ;

  00074	eb e3		 jmp	 SHORT $LN2@log_read
$LN3@log_read:

; 513  : 
; 514  :    log_count = count;

  00076	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00079	a3 00 00 00 00	 mov	 DWORD PTR _log_count, eax

; 515  : 
; 516  :    fclose(fp);

  0007e	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _fclose
  00087	83 c4 04	 add	 esp, 4

; 517  : 
; 518  :    if (!count)

  0008a	83 7d f8 00	 cmp	 DWORD PTR _count$[ebp], 0
  0008e	75 07		 jne	 SHORT $LN10@log_read

; 519  :       return 0; // normal cfg files will return here

  00090	33 c0		 xor	 eax, eax
  00092	e9 a0 00 00 00	 jmp	 $LN1@log_read
$LN10@log_read:

; 520  : 
; 521  :    if (log_entries != NULL)   // Allocate the array and fill it in

  00097	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _log_entries, 0
  0009e	74 0e		 je	 SHORT $LN11@log_read

; 522  :       free(log_entries);

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _log_entries
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _free
  000ab	83 c4 04	 add	 esp, 4
$LN11@log_read:

; 523  :    if ((log_entries = (log_entry *) malloc(count * sizeof(log_entry))) == NULL)

  000ae	69 45 f8 28 01
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 296
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _malloc
  000bb	83 c4 04	 add	 esp, 4
  000be	a3 00 00 00 00	 mov	 DWORD PTR _log_entries, eax
  000c3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _log_entries, 0
  000ca	75 04		 jne	 SHORT $LN12@log_read

; 524  :       return 0;

  000cc	33 c0		 xor	 eax, eax
  000ce	eb 67		 jmp	 SHORT $LN1@log_read
$LN12@log_read:

; 525  : 
; 526  :    if ((fp = open_file(file, "", 0)) == NULL)

  000d0	6a 00		 push	 0
  000d2	68 00 00 00 00	 push	 OFFSET $SG40559
  000d7	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 _open_file
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e3	89 45 f4	 mov	 DWORD PTR _fp$[ebp], eax
  000e6	83 7d f4 00	 cmp	 DWORD PTR _fp$[ebp], 0
  000ea	75 04		 jne	 SHORT $LN13@log_read

; 527  :       return 0;

  000ec	33 c0		 xor	 eax, eax
  000ee	eb 47		 jmp	 SHORT $LN1@log_read
$LN13@log_read:

; 528  :    for (i = 0; i < count; i++)

  000f0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000f7	eb 09		 jmp	 SHORT $LN7@log_read
$LN5@log_read:
  000f9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000fc	83 c0 01	 add	 eax, 1
  000ff	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@log_read:
  00102	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00105	3b 45 f8	 cmp	 eax, DWORD PTR _count$[ebp]
  00108	7d 1c		 jge	 SHORT $LN6@log_read

; 529  :       log_read_entry(&log_entries[i], fp);

  0010a	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  0010d	50		 push	 eax
  0010e	69 4d fc 28 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 296
  00115	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _log_entries
  0011b	51		 push	 ecx
  0011c	e8 00 00 00 00	 call	 _log_read_entry
  00121	83 c4 08	 add	 esp, 8
  00124	eb d3		 jmp	 SHORT $LN5@log_read
$LN6@log_read:

; 530  : 
; 531  :    fclose(fp);

  00126	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _fclose
  0012f	83 c4 04	 add	 esp, 4

; 532  : 
; 533  :    return 1;

  00132	b8 01 00 00 00	 mov	 eax, 1
$LN1@log_read:

; 534  : }

  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	5b		 pop	 ebx
  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c3		 ret	 0
_log_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _open_file
_TEXT	SEGMENT
tv66 = -328						; size = 4
_fp$ = -260						; size = 4
_s$ = -256						; size = 256
_file$ = 8						; size = 4
_msg$ = 12						; size = 4
_bin$ = 16						; size = 4
_open_file PROC						; COMDAT

; 477  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 478  :    char s[256];
; 479  :    FILE *fp;
; 480  : 
; 481  :    if (fopen_s(&fp, file, bin ? "rb" : "rt"))

  0000c	83 7d 10 00	 cmp	 DWORD PTR _bin$[ebp], 0
  00010	74 0c		 je	 SHORT $LN5@open_file
  00012	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], OFFSET $SG40522
  0001c	eb 0a		 jmp	 SHORT $LN6@open_file
$LN5@open_file:
  0001e	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], OFFSET $SG40523
$LN6@open_file:
  00028	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00032	51		 push	 ecx
  00033	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _fp$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 _fopen_s
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	85 c0		 test	 eax, eax
  00044	74 44		 je	 SHORT $LN2@open_file

; 482  :    {
; 483  :       if (msg != NULL)

  00046	83 7d 0c 00	 cmp	 DWORD PTR _msg$[ebp], 0
  0004a	74 3a		 je	 SHORT $LN3@open_file

; 484  :       {
; 485  :          sprintf_s(s, sizeof(s), "Could not open '%s' for read.%s", file, msg);

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _msg$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00053	51		 push	 ecx
  00054	68 00 00 00 00	 push	 OFFSET $SG40525
  00059	68 00 01 00 00	 push	 256			; 00000100H
  0005e	8d 95 00 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _sprintf_s
  0006a	83 c4 14	 add	 esp, 20			; 00000014H

; 486  :          MessageBox(NULL, s, "Warning", MB_OK | MB_ICONWARNING | MB_TASKMODAL);

  0006d	68 30 20 00 00	 push	 8240			; 00002030H
  00072	68 00 00 00 00	 push	 OFFSET $SG40526
  00077	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0007d	50		 push	 eax
  0007e	6a 00		 push	 0
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN3@open_file:

; 487  :       }
; 488  :       return NULL;

  00086	33 c0		 xor	 eax, eax
  00088	eb 06		 jmp	 SHORT $LN1@open_file
$LN2@open_file:

; 489  :    }
; 490  :    return fp;

  0008a	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
$LN1@open_file:

; 491  : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_open_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _log_read_entry
_TEXT	SEGMENT
tv238 = -1552						; size = 4
_c$ = -1353						; size = 1
_str$ = -1352						; size = 4
_strs$ = -1348						; size = 1280
_f$ = -68						; size = 4
_s$ = -64						; size = 4
_val$ = -60						; size = 4
_ind$ = -56						; size = 4
_n$ = -52						; size = 4
_j$ = -48						; size = 4
_i$ = -44						; size = 4
_vals$ = -40						; size = 40
_entry$ = 8						; size = 4
_fp$ = 12						; size = 4
_log_read_entry PROC					; COMDAT

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 06 00
	00		 sub	 esp, 1552		; 00000610H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 371  :    double vals[5];
; 372  :    int i, j, n, ind, val;
; 373  :    setting *s, *f;
; 374  :    unsigned char strs[5][256], *str, c;
; 375  : 
; 376  :    // Initialize cur file settings structure to all invalid (no change)
; 377  :    invalidate_settings(&cur_file_settings);

  0000c	68 00 00 00 00	 push	 OFFSET _cur_file_settings
  00011	e8 00 00 00 00	 call	 _invalidate_settings
  00016	83 c4 04	 add	 esp, 4

; 378  : 
; 379  :    // Read re, im, mag, iters, pal, and optional commands. To support legacy logfiles,
; 380  :    // the five main fields don't need any leading items (they can be just numbers). Any
; 381  :    // leading item before a number will be ignored, unless it's a recognized setting.
; 382  :    for (i = 0; i < 5;)

  00019	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@log_read_e:
  00020	83 7d d4 05	 cmp	 DWORD PTR _i$[ebp], 5
  00024	0f 8d 53 02 00
	00		 jge	 $LN3@log_read_e

; 383  :    {
; 384  :       if (feof(fp))

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _fp$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _feof
  00033	83 c4 04	 add	 esp, 4
  00036	85 c0		 test	 eax, eax
  00038	74 07		 je	 SHORT $LN17@log_read_e

; 385  :          return 0;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 8a 03 00 00	 jmp	 $LN1@log_read_e
$LN17@log_read_e:

; 386  :       if (fgets((char *) &strs[i][0], sizeof(strs[0]), fp) == NULL)

  00041	8b 45 0c	 mov	 eax, DWORD PTR _fp$[ebp]
  00044	50		 push	 eax
  00045	68 00 01 00 00	 push	 256			; 00000100H
  0004a	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  0004d	c1 e1 08	 shl	 ecx, 8
  00050	8d 94 0d bc fa
	ff ff		 lea	 edx, DWORD PTR _strs$[ebp+ecx]
  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	6b c8 00	 imul	 ecx, eax, 0
  0005f	03 d1		 add	 edx, ecx
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 _fgets
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	85 c0		 test	 eax, eax
  0006c	75 07		 jne	 SHORT $LN18@log_read_e

; 387  :          return 0;

  0006e	33 c0		 xor	 eax, eax
  00070	e9 56 03 00 00	 jmp	 $LN1@log_read_e
$LN18@log_read_e:

; 388  : 
; 389  :       str = &strs[i][0];

  00075	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00078	c1 e0 08	 shl	 eax, 8
  0007b	8d 8c 05 bc fa
	ff ff		 lea	 ecx, DWORD PTR _strs$[ebp+eax]
  00082	ba 01 00 00 00	 mov	 edx, 1
  00087	6b c2 00	 imul	 eax, edx, 0
  0008a	03 c8		 add	 ecx, eax
  0008c	89 8d b8 fa ff
	ff		 mov	 DWORD PTR _str$[ebp], ecx

; 390  : 
; 391  :       // Skip any leading whitespace
; 392  :       ind = -1;

  00092	c7 45 c8 ff ff
	ff ff		 mov	 DWORD PTR _ind$[ebp], -1
$LN35@log_read_e:

; 393  :       do
; 394  :          c = str[++ind];

  00099	8b 45 c8	 mov	 eax, DWORD PTR _ind$[ebp]
  0009c	83 c0 01	 add	 eax, 1
  0009f	89 45 c8	 mov	 DWORD PTR _ind$[ebp], eax
  000a2	8b 8d b8 fa ff
	ff		 mov	 ecx, DWORD PTR _str$[ebp]
  000a8	03 4d c8	 add	 ecx, DWORD PTR _ind$[ebp]
  000ab	8a 11		 mov	 dl, BYTE PTR [ecx]
  000ad	88 95 b7 fa ff
	ff		 mov	 BYTE PTR _c$[ebp], dl

; 395  :       while (c == ' ' || c == '\t'); // null will terminate loop

  000b3	0f b6 85 b7 fa
	ff ff		 movzx	 eax, BYTE PTR _c$[ebp]
  000ba	83 f8 20	 cmp	 eax, 32			; 00000020H
  000bd	74 da		 je	 SHORT $LN35@log_read_e
  000bf	0f b6 85 b7 fa
	ff ff		 movzx	 eax, BYTE PTR _c$[ebp]
  000c6	83 f8 09	 cmp	 eax, 9
  000c9	74 ce		 je	 SHORT $LN35@log_read_e

; 396  : 
; 397  :       // For added robustness, resync on "real", so corrupted files won't get us out of sync.
; 398  :       if (!_strnicmp(&str[ind], "real", 4))

  000cb	6a 04		 push	 4
  000cd	68 00 00 00 00	 push	 OFFSET $SG40493
  000d2	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _str$[ebp]
  000d8	03 45 c8	 add	 eax, DWORD PTR _ind$[ebp]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 __strnicmp
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e4	85 c0		 test	 eax, eax
  000e6	75 07		 jne	 SHORT $LN19@log_read_e

; 399  :          i = 0;

  000e8	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN19@log_read_e:

; 400  : 
; 401  :       // Look for any optional commands or settings. This should stay reasonably fast
; 402  :       // even with large logfiles.
; 403  : 
; 404  :       s = (setting *) &cfg_settings;      // treat structs as arrays

  000ef	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _s$[ebp], OFFSET _cfg_settings

; 405  :       f = (setting *) &cur_file_settings;

  000f6	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _f$[ebp], OFFSET _cur_file_settings

; 406  :       for (j = 0; j < sizeof(cfg_settings) / sizeof(setting); j++)

  000fd	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00104	eb 09		 jmp	 SHORT $LN10@log_read_e
$LN8@log_read_e:
  00106	8b 45 d0	 mov	 eax, DWORD PTR _j$[ebp]
  00109	83 c0 01	 add	 eax, 1
  0010c	89 45 d0	 mov	 DWORD PTR _j$[ebp], eax
$LN10@log_read_e:
  0010f	83 7d d0 0d	 cmp	 DWORD PTR _j$[ebp], 13	; 0000000dH
  00113	0f 83 96 00 00
	00		 jae	 $LN9@log_read_e

; 407  :          if (!_strnicmp(&str[ind], s[j].name, (size_t) n = strlen(s[j].name))) // not case sensitive

  00119	6b 45 d0 14	 imul	 eax, DWORD PTR _j$[ebp], 20
  0011d	8b 4d c0	 mov	 ecx, DWORD PTR _s$[ebp]
  00120	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00123	52		 push	 edx
  00124	e8 00 00 00 00	 call	 _strlen
  00129	83 c4 04	 add	 esp, 4
  0012c	89 45 cc	 mov	 DWORD PTR _n$[ebp], eax
  0012f	8b 45 cc	 mov	 eax, DWORD PTR _n$[ebp]
  00132	50		 push	 eax
  00133	6b 4d d0 14	 imul	 ecx, DWORD PTR _j$[ebp], 20
  00137	8b 55 c0	 mov	 edx, DWORD PTR _s$[ebp]
  0013a	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0013d	50		 push	 eax
  0013e	8b 8d b8 fa ff
	ff		 mov	 ecx, DWORD PTR _str$[ebp]
  00144	03 4d c8	 add	 ecx, DWORD PTR _ind$[ebp]
  00147	51		 push	 ecx
  00148	e8 00 00 00 00	 call	 __strnicmp
  0014d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00150	85 c0		 test	 eax, eax
  00152	75 56		 jne	 SHORT $LN20@log_read_e

; 408  :          {
; 409  :             // Can use the function for reading a palette RGB value here (it will read
; 410  :             // normal integers too). As a side effect any 24 bit value can be specified
; 411  :             // as three individual bytes if desired...
; 412  :             // Some settings are palette values.
; 413  : 
; 414  :             get_palette_rgb_val(ind + n, str, sizeof(strs[0]), &val);

  00154	8d 45 c4	 lea	 eax, DWORD PTR _val$[ebp]
  00157	50		 push	 eax
  00158	68 00 01 00 00	 push	 256			; 00000100H
  0015d	8b 8d b8 fa ff
	ff		 mov	 ecx, DWORD PTR _str$[ebp]
  00163	51		 push	 ecx
  00164	8b 55 c8	 mov	 edx, DWORD PTR _ind$[ebp]
  00167	03 55 cc	 add	 edx, DWORD PTR _n$[ebp]
  0016a	52		 push	 edx
  0016b	e8 00 00 00 00	 call	 _get_palette_rgb_val
  00170	83 c4 10	 add	 esp, 16			; 00000010H

; 415  : 
; 416  :             if (val >= s[j].min && val <= s[j].max)  // set value if it's within legal range

  00173	6b 45 d0 14	 imul	 eax, DWORD PTR _j$[ebp], 20
  00177	8b 4d c0	 mov	 ecx, DWORD PTR _s$[ebp]
  0017a	8b 55 c4	 mov	 edx, DWORD PTR _val$[ebp]
  0017d	3b 54 01 0c	 cmp	 edx, DWORD PTR [ecx+eax+12]
  00181	7c 1e		 jl	 SHORT $LN21@log_read_e
  00183	6b 45 d0 14	 imul	 eax, DWORD PTR _j$[ebp], 20
  00187	8b 4d c0	 mov	 ecx, DWORD PTR _s$[ebp]
  0018a	8b 55 c4	 mov	 edx, DWORD PTR _val$[ebp]
  0018d	3b 54 01 10	 cmp	 edx, DWORD PTR [ecx+eax+16]
  00191	7f 0e		 jg	 SHORT $LN21@log_read_e

; 417  :                f[j].val = val;

  00193	6b 45 d0 14	 imul	 eax, DWORD PTR _j$[ebp], 20
  00197	8b 4d bc	 mov	 ecx, DWORD PTR _f$[ebp]
  0019a	8b 55 c4	 mov	 edx, DWORD PTR _val$[ebp]
  0019d	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx
$LN21@log_read_e:

; 418  :             c = 0;  // found a setting; skip the stuff below

  001a1	c6 85 b7 fa ff
	ff 00		 mov	 BYTE PTR _c$[ebp], 0

; 419  :             break;

  001a8	eb 05		 jmp	 SHORT $LN9@log_read_e
$LN20@log_read_e:

; 420  :          }

  001aa	e9 57 ff ff ff	 jmp	 $LN8@log_read_e
$LN9@log_read_e:

; 421  :       if (!c)

  001af	0f b6 85 b7 fa
	ff ff		 movzx	 eax, BYTE PTR _c$[ebp]
  001b6	85 c0		 test	 eax, eax
  001b8	75 05		 jne	 SHORT $LN22@log_read_e

; 422  :          continue;

  001ba	e9 61 fe ff ff	 jmp	 $LN2@log_read_e
$LN22@log_read_e:

; 423  : 
; 424  :       // Might have an image parameter here (a number with or without leading items).
; 425  :       // Strip out any leading non-numeric/non-quote chars, and ignore comments.
; 426  :       for (j = ind; j < sizeof(strs[0]); j++)

  001bf	8b 45 c8	 mov	 eax, DWORD PTR _ind$[ebp]
  001c2	89 45 d0	 mov	 DWORD PTR _j$[ebp], eax
  001c5	eb 09		 jmp	 SHORT $LN13@log_read_e
$LN11@log_read_e:
  001c7	8b 45 d0	 mov	 eax, DWORD PTR _j$[ebp]
  001ca	83 c0 01	 add	 eax, 1
  001cd	89 45 d0	 mov	 DWORD PTR _j$[ebp], eax
$LN13@log_read_e:
  001d0	81 7d d0 00 01
	00 00		 cmp	 DWORD PTR _j$[ebp], 256	; 00000100H
  001d7	73 72		 jae	 SHORT $LN12@log_read_e

; 427  :       {
; 428  :          if ((c = str[j]) == '/')  // '/' starts a comment

  001d9	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _str$[ebp]
  001df	03 45 d0	 add	 eax, DWORD PTR _j$[ebp]
  001e2	8a 08		 mov	 cl, BYTE PTR [eax]
  001e4	88 8d b7 fa ff
	ff		 mov	 BYTE PTR _c$[ebp], cl
  001ea	0f b6 95 b7 fa
	ff ff		 movzx	 edx, BYTE PTR _c$[ebp]
  001f1	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  001f4	75 07		 jne	 SHORT $LN23@log_read_e

; 429  :             c = 0;

  001f6	c6 85 b7 fa ff
	ff 00		 mov	 BYTE PTR _c$[ebp], 0
$LN23@log_read_e:

; 430  :          if ( (c >= '0' && c <= '9') || c == '-' || c == '.' || c == '\"' || !c)

  001fd	0f b6 85 b7 fa
	ff ff		 movzx	 eax, BYTE PTR _c$[ebp]
  00204	83 f8 30	 cmp	 eax, 48			; 00000030H
  00207	7c 0c		 jl	 SHORT $LN26@log_read_e
  00209	0f b6 85 b7 fa
	ff ff		 movzx	 eax, BYTE PTR _c$[ebp]
  00210	83 f8 39	 cmp	 eax, 57			; 00000039H
  00213	7e 2f		 jle	 SHORT $LN25@log_read_e
$LN26@log_read_e:
  00215	0f b6 85 b7 fa
	ff ff		 movzx	 eax, BYTE PTR _c$[ebp]
  0021c	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0021f	74 23		 je	 SHORT $LN25@log_read_e
  00221	0f b6 85 b7 fa
	ff ff		 movzx	 eax, BYTE PTR _c$[ebp]
  00228	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0022b	74 17		 je	 SHORT $LN25@log_read_e
  0022d	0f b6 85 b7 fa
	ff ff		 movzx	 eax, BYTE PTR _c$[ebp]
  00234	83 f8 22	 cmp	 eax, 34			; 00000022H
  00237	74 0b		 je	 SHORT $LN25@log_read_e
  00239	0f b6 85 b7 fa
	ff ff		 movzx	 eax, BYTE PTR _c$[ebp]
  00240	85 c0		 test	 eax, eax
  00242	75 02		 jne	 SHORT $LN24@log_read_e
$LN25@log_read_e:

; 431  :             break;

  00244	eb 05		 jmp	 SHORT $LN12@log_read_e
$LN24@log_read_e:

; 432  :       }

  00246	e9 7c ff ff ff	 jmp	 $LN11@log_read_e
$LN12@log_read_e:

; 433  :       if (c)

  0024b	0f b6 85 b7 fa
	ff ff		 movzx	 eax, BYTE PTR _c$[ebp]
  00252	85 c0		 test	 eax, eax
  00254	74 22		 je	 SHORT $LN27@log_read_e

; 434  :       {
; 435  :          // Got something that looks like a number or a " if we get here. Any bad
; 436  :          // values will be set to 0.0 (ok). J is long lived (see below)
; 437  :          vals[i] = atof(&str[j]);

  00256	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _str$[ebp]
  0025c	03 45 d0	 add	 eax, DWORD PTR _j$[ebp]
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 _atof
  00265	83 c4 04	 add	 esp, 4
  00268	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  0026b	dd 5c cd d8	 fstp	 QWORD PTR _vals$[ebp+ecx*8]

; 438  :          i++; // look for next entry

  0026f	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00272	83 c0 01	 add	 eax, 1
  00275	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN27@log_read_e:

; 439  :       }
; 440  :    }

  00278	e9 a3 fd ff ff	 jmp	 $LN2@log_read_e
$LN3@log_read_e:

; 441  : 
; 442  :    // All values good: update mandelbrot parms
; 443  :    if (entry != NULL)

  0027d	83 7d 08 00	 cmp	 DWORD PTR _entry$[ebp], 0
  00281	0f 84 3f 01 00
	00		 je	 $LN29@log_read_e

; 444  :    {
; 445  :       // Fill in the entry, including optional fields (if they're still at -1, nothing will happen later).
; 446  :       entry->re = vals[0];

  00287	b8 08 00 00 00	 mov	 eax, 8
  0028c	6b c8 00	 imul	 ecx, eax, 0
  0028f	8b 55 08	 mov	 edx, DWORD PTR _entry$[ebp]
  00292	f2 0f 10 44 0d
	d8		 movsd	 xmm0, QWORD PTR _vals$[ebp+ecx]
  00298	f2 0f 11 02	 movsd	 QWORD PTR [edx], xmm0

; 447  :       entry->im = vals[1];

  0029c	b8 08 00 00 00	 mov	 eax, 8
  002a1	c1 e0 00	 shl	 eax, 0
  002a4	8b 4d 08	 mov	 ecx, DWORD PTR _entry$[ebp]
  002a7	f2 0f 10 44 05
	d8		 movsd	 xmm0, QWORD PTR _vals$[ebp+eax]
  002ad	f2 0f 11 41 08	 movsd	 QWORD PTR [ecx+8], xmm0

; 448  :       entry->mag = vals[2];

  002b2	b8 08 00 00 00	 mov	 eax, 8
  002b7	d1 e0		 shl	 eax, 1
  002b9	8b 4d 08	 mov	 ecx, DWORD PTR _entry$[ebp]
  002bc	f2 0f 10 44 05
	d8		 movsd	 xmm0, QWORD PTR _vals$[ebp+eax]
  002c2	f2 0f 11 41 10	 movsd	 QWORD PTR [ecx+16], xmm0

; 449  :       entry->max_iters = (unsigned) vals[3];

  002c7	b8 08 00 00 00	 mov	 eax, 8
  002cc	6b c8 03	 imul	 ecx, eax, 3
  002cf	f2 0f 10 44 0d
	d8		 movsd	 xmm0, QWORD PTR _vals$[ebp+ecx]
  002d5	e8 00 00 00 00	 call	 __dtoui3
  002da	8b 55 08	 mov	 edx, DWORD PTR _entry$[ebp]
  002dd	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 450  :       entry->palette = (unsigned) vals[4];

  002e0	b8 08 00 00 00	 mov	 eax, 8
  002e5	c1 e0 02	 shl	 eax, 2
  002e8	f2 0f 10 44 05
	d8		 movsd	 xmm0, QWORD PTR _vals$[ebp+eax]
  002ee	e8 00 00 00 00	 call	 __dtoui3
  002f3	8b 4d 08	 mov	 ecx, DWORD PTR _entry$[ebp]
  002f6	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 451  : 
; 452  :       entry->log_settings = cur_file_settings; // Copy any settings found above

  002f9	8b 7d 08	 mov	 edi, DWORD PTR _entry$[ebp]
  002fc	83 c7 20	 add	 edi, 32			; 00000020H
  002ff	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00304	be 00 00 00 00	 mov	 esi, OFFSET _cur_file_settings
  00309	f3 a5		 rep movsd

; 453  : 
; 454  :       // For user palette files (palette starts with " in logfile), use the position in the
; 455  :       // dropdown list. Assumes dropdown list is already populated. As a side effect this also
; 456  :       // allows the user to specify a builtin palette by either name (e.g. "Muted") or number (3)
; 457  :       if (str[j] == '\"')

  0030b	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _str$[ebp]
  00311	03 45 d0	 add	 eax, DWORD PTR _j$[ebp]
  00314	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00317	83 f9 22	 cmp	 ecx, 34			; 00000022H
  0031a	0f 85 a6 00 00
	00		 jne	 $LN29@log_read_e

; 458  :       {
; 459  :          for (i = j + 1; i < sizeof(strs[0]); i++) // Replace any trailing " with a null

  00320	8b 45 d0	 mov	 eax, DWORD PTR _j$[ebp]
  00323	83 c0 01	 add	 eax, 1
  00326	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
  00329	eb 09		 jmp	 SHORT $LN16@log_read_e
$LN14@log_read_e:
  0032b	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0032e	83 c0 01	 add	 eax, 1
  00331	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN16@log_read_e:
  00334	81 7d d4 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  0033b	73 31		 jae	 SHORT $LN15@log_read_e

; 460  :          {
; 461  :             if (str[i] == '\"')

  0033d	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _str$[ebp]
  00343	03 45 d4	 add	 eax, DWORD PTR _i$[ebp]
  00346	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00349	83 f9 22	 cmp	 ecx, 34			; 00000022H
  0034c	75 0c		 jne	 SHORT $LN30@log_read_e

; 462  :                str[i] = 0;

  0034e	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _str$[ebp]
  00354	03 45 d4	 add	 eax, DWORD PTR _i$[ebp]
  00357	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN30@log_read_e:

; 463  :             if (!str[i])

  0035a	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _str$[ebp]
  00360	03 45 d4	 add	 eax, DWORD PTR _i$[ebp]
  00363	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00366	85 c9		 test	 ecx, ecx
  00368	75 02		 jne	 SHORT $LN31@log_read_e

; 464  :                break;

  0036a	eb 02		 jmp	 SHORT $LN15@log_read_e
$LN31@log_read_e:

; 465  :          }

  0036c	eb bd		 jmp	 SHORT $LN14@log_read_e
$LN15@log_read_e:

; 466  :          // Get palette from dropdown list. If not found, set to default palette.
; 467  :          i = (int) SendDlgItemMessage(hwnd_dialog, IDC_PALETTE, CB_FINDSTRINGEXACT,

  0036e	8b 45 d0	 mov	 eax, DWORD PTR _j$[ebp]
  00371	8b 8d b8 fa ff
	ff		 mov	 ecx, DWORD PTR _str$[ebp]
  00377	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0037b	52		 push	 edx
  0037c	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_builtin_palettes
  00381	83 e8 01	 sub	 eax, 1
  00384	50		 push	 eax
  00385	68 58 01 00 00	 push	 344			; 00000158H
  0038a	68 03 04 00 00	 push	 1027			; 00000403H
  0038f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_dialog
  00395	51		 push	 ecx
  00396	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
  0039c	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax

; 468  :                                       num_builtin_palettes - 1, (LPARAM) &str[j + 1]);
; 469  :          entry->palette = (i != CB_ERR) ? i : DEFAULT_PAL;

  0039f	83 7d d4 ff	 cmp	 DWORD PTR _i$[ebp], -1
  003a3	74 0b		 je	 SHORT $LN33@log_read_e
  003a5	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  003a8	89 85 f0 f9 ff
	ff		 mov	 DWORD PTR tv238[ebp], eax
  003ae	eb 0a		 jmp	 SHORT $LN34@log_read_e
$LN33@log_read_e:
  003b0	c7 85 f0 f9 ff
	ff 02 00 00 00	 mov	 DWORD PTR tv238[ebp], 2
$LN34@log_read_e:
  003ba	8b 4d 08	 mov	 ecx, DWORD PTR _entry$[ebp]
  003bd	8b 95 f0 f9 ff
	ff		 mov	 edx, DWORD PTR tv238[ebp]
  003c3	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
$LN29@log_read_e:

; 470  :       }
; 471  :    }
; 472  :    return 1;

  003c6	b8 01 00 00 00	 mov	 eax, 1
$LN1@log_read_e:

; 473  : }

  003cb	5f		 pop	 edi
  003cc	5e		 pop	 esi
  003cd	5b		 pop	 ebx
  003ce	8b e5		 mov	 esp, ebp
  003d0	5d		 pop	 ebp
  003d1	c3		 ret	 0
_log_read_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _invalidate_settings
_TEXT	SEGMENT
_d$ = -8						; size = 4
_i$ = -4						; size = 4
_dest$ = 8						; size = 4
_invalidate_settings PROC				; COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 356  :    int i;
; 357  :    setting *d;
; 358  :    d = (setting *) dest; // treat struct as array

  00009	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _d$[ebp], eax

; 359  :    for (i = 0; i < sizeof(cfg_settings) / sizeof(setting); i++)

  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00016	eb 09		 jmp	 SHORT $LN4@invalidate
$LN2@invalidate:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001b	83 c0 01	 add	 eax, 1
  0001e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@invalidate:
  00021	83 7d fc 0d	 cmp	 DWORD PTR _i$[ebp], 13	; 0000000dH
  00025	73 11		 jae	 SHORT $LN1@invalidate

; 360  :       d[i].val = -1;

  00027	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _d$[ebp]
  0002e	c7 44 01 04 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+4], -1
  00036	eb e0		 jmp	 SHORT $LN2@invalidate
$LN1@invalidate:

; 361  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
_invalidate_settings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _autoreset_settings
_TEXT	SEGMENT
_d$ = -8						; size = 4
_i$ = -4						; size = 4
_dest$ = 8						; size = 4
_autoreset_settings PROC				; COMDAT

; 344  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 345  :    int i;
; 346  :    setting *d;
; 347  :    d = (setting *) dest; // treat struct as array

  00009	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _d$[ebp], eax

; 348  :    for (i = 0; i < sizeof(cfg_settings) / sizeof(setting); i++)

  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00016	eb 09		 jmp	 SHORT $LN4@autoreset_
$LN2@autoreset_:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001b	83 c0 01	 add	 eax, 1
  0001e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@autoreset_:
  00021	83 7d fc 0d	 cmp	 DWORD PTR _i$[ebp], 13	; 0000000dH
  00025	73 33		 jae	 SHORT $LN1@autoreset_

; 349  :       if (SETTING_AUTORESET(&d[i]))

  00027	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0002b	b9 01 00 00 00	 mov	 ecx, 1
  00030	6b d1 00	 imul	 edx, ecx, 0
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _d$[ebp]
  00036	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00039	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0003d	83 e1 20	 and	 ecx, 32			; 00000020H
  00040	75 16		 jne	 SHORT $LN5@autoreset_

; 350  :          d[i].val = d[i].default_val;

  00042	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00046	6b 4d fc 14	 imul	 ecx, DWORD PTR _i$[ebp], 20
  0004a	8b 55 f8	 mov	 edx, DWORD PTR _d$[ebp]
  0004d	8b 75 f8	 mov	 esi, DWORD PTR _d$[ebp]
  00050	8b 44 06 08	 mov	 eax, DWORD PTR [esi+eax+8]
  00054	89 44 0a 04	 mov	 DWORD PTR [edx+ecx+4], eax
$LN5@autoreset_:
  00058	eb be		 jmp	 SHORT $LN2@autoreset_
$LN1@autoreset_:

; 351  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_autoreset_settings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _copy_changed_settings
_TEXT	SEGMENT
_d$ = -12						; size = 4
_s$ = -8						; size = 4
_i$ = -4						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_copy_to_default$ = 16					; size = 4
_copy_changed_settings PROC				; COMDAT

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 327  :    int i;
; 328  :    setting *s, *d;
; 329  : 
; 330  :    s = (setting *) src;   // treat structs as arrays

  00009	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 331  :    d = (setting *) dest;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00012	89 45 f4	 mov	 DWORD PTR _d$[ebp], eax

; 332  :    for (i = 0; i < sizeof(cfg_settings) / sizeof(setting); i++)

  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001c	eb 09		 jmp	 SHORT $LN4@copy_chang
$LN2@copy_chang:
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00021	83 c0 01	 add	 eax, 1
  00024	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@copy_chang:
  00027	83 7d fc 0d	 cmp	 DWORD PTR _i$[ebp], 13	; 0000000dH
  0002b	73 42		 jae	 SHORT $LN1@copy_chang

; 333  :       if (s[i].val >= 0)

  0002d	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00034	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  00039	7c 32		 jl	 SHORT $LN5@copy_chang

; 334  :       {
; 335  :          d[i].val = s[i].val;

  0003b	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0003f	6b 4d fc 14	 imul	 ecx, DWORD PTR _i$[ebp], 20
  00043	8b 55 f4	 mov	 edx, DWORD PTR _d$[ebp]
  00046	8b 75 f8	 mov	 esi, DWORD PTR _s$[ebp]
  00049	8b 44 06 04	 mov	 eax, DWORD PTR [esi+eax+4]
  0004d	89 44 0a 04	 mov	 DWORD PTR [edx+ecx+4], eax

; 336  :          if (copy_to_default)

  00051	83 7d 10 00	 cmp	 DWORD PTR _copy_to_default$[ebp], 0
  00055	74 16		 je	 SHORT $LN5@copy_chang

; 337  :             d[i].default_val = s[i].val;

  00057	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0005b	6b 4d fc 14	 imul	 ecx, DWORD PTR _i$[ebp], 20
  0005f	8b 55 f4	 mov	 edx, DWORD PTR _d$[ebp]
  00062	8b 75 f8	 mov	 esi, DWORD PTR _s$[ebp]
  00065	8b 44 06 04	 mov	 eax, DWORD PTR [esi+eax+4]
  00069	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax
$LN5@copy_chang:

; 338  :       }

  0006d	eb af		 jmp	 SHORT $LN2@copy_chang
$LN1@copy_chang:

; 339  : }

  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_copy_changed_settings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _do_man_calculate
_TEXT	SEGMENT
_m$ = -8						; size = 4
_cursor$ = -4						; size = 4
_recalc_all$ = 8					; size = 4
_do_man_calculate PROC					; COMDAT

; 3629 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3630 :    HCURSOR cursor;
; 3631 :    man_calc_struct *m;
; 3632 : 
; 3633 :    m = &main_man_calc_struct;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 3634 : 
; 3635 :    m->max_iters &= ~1;                 // make max iters even (required by optimized algorithm)

  00010	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  00013	8b 88 c0 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36288]
  00019	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0001c	8b 55 f8	 mov	 edx, DWORD PTR _m$[ebp]
  0001f	89 8a c0 8d 00
	00		 mov	 DWORD PTR [edx+36288], ecx

; 3636 :    if (m->max_iters != m->max_iters_last) // need to recalculate all if max iters changed

  00025	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR _m$[ebp]
  0002b	8b 90 c0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36288]
  00031	3b 91 c4 8d 00
	00		 cmp	 edx, DWORD PTR [ecx+36292]
  00037	74 0d		 je	 SHORT $LN2@do_man_cal

; 3637 :       status |= STAT_NEED_RECALC;

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  0003e	83 c8 01	 or	 eax, 1
  00041	a3 00 00 00 00	 mov	 DWORD PTR _status, eax
$LN2@do_man_cal:

; 3638 :    if (status & STAT_NEED_RECALC)   // if need recalculation,

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  0004b	83 e0 01	 and	 eax, 1
  0004e	74 07		 je	 SHORT $LN3@do_man_cal

; 3639 :       recalc_all = 1;               // force info update and wait cursor

  00050	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _recalc_all$[ebp], 1
$LN3@do_man_cal:

; 3640 :    if (recalc_all)

  00057	83 7d 08 00	 cmp	 DWORD PTR _recalc_all$[ebp], 0
  0005b	74 72		 je	 SHORT $LN4@do_man_cal

; 3641 :    {
; 3642 :       update_re_im(m, m->pan_xoffs, m->pan_yoffs); // could be recalculating for palette- renormalize

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  00060	8b 88 a4 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36260]
  00066	51		 push	 ecx
  00067	8b 90 a0 8d 00
	00		 mov	 edx, DWORD PTR [eax+36256]
  0006d	52		 push	 edx
  0006e	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  00071	8b 88 9c 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36252]
  00077	51		 push	 ecx
  00078	8b 90 98 8d 00
	00		 mov	 edx, DWORD PTR [eax+36248]
  0007e	52		 push	 edx
  0007f	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _update_re_im
  00088	83 c4 14	 add	 esp, 20			; 00000014H

; 3643 :       reset_quadrants();                  // reset quadrants to UL only

  0008b	e8 00 00 00 00	 call	 _reset_quadrants

; 3644 :       if (!do_rtzoom)                     // If not realtime zooming

  00090	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _do_rtzoom, 0
  00097	75 24		 jne	 SHORT $LN5@do_man_cal

; 3645 :       {
; 3646 :          print_status_line(1);   // print status line and reset fps timing values

  00099	6a 01		 push	 1
  0009b	e8 00 00 00 00	 call	 _print_status_line
  000a0	83 c4 04	 add	 esp, 4

; 3647 :          reset_fps_values();

  000a3	e8 00 00 00 00	 call	 _reset_fps_values

; 3648 :          cursor = GetCursor();   // save current cursor and set wait cursor

  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursor@0
  000ae	89 45 fc	 mov	 DWORD PTR _cursor$[ebp], eax

; 3649 :          SetCursor(wait_cursor);

  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _wait_cursor
  000b6	50		 push	 eax
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
$LN5@do_man_cal:

; 3650 :       }
; 3651 :       get_dialog_fields();                // do this always, so we can change max_iters while zooming, etc.

  000bd	e8 00 00 00 00	 call	 _get_dialog_fields

; 3652 :       status &= ~STAT_RECALC_FOR_PALETTE; // no longer need to recalc for palette

  000c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _status
  000c7	83 e0 fd	 and	 eax, -3			; fffffffdH
  000ca	a3 00 00 00 00	 mov	 DWORD PTR _status, eax
$LN4@do_man_cal:

; 3653 :    }
; 3654 : 
; 3655 :    man_calculate_quadrants();

  000cf	e8 00 00 00 00	 call	 _man_calculate_quadrants

; 3656 :    m->max_iters_last = m->max_iters;  // last iters actually calculated, for palette code

  000d4	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  000d7	8b 4d f8	 mov	 ecx, DWORD PTR _m$[ebp]
  000da	8b 91 c0 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36288]
  000e0	89 90 c4 8d 00
	00		 mov	 DWORD PTR [eax+36292], edx

; 3657 : 
; 3658 :    InvalidateRect(hwnd_main, NULL, 0); // cause repaint with image data

  000e6	6a 00		 push	 0
  000e8	6a 00		 push	 0
  000ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  000ef	50		 push	 eax
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 3659 :    UpdateWindow(hwnd_main);

  000f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  000fb	50		 push	 eax
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UpdateWindow@4

; 3660 : 
; 3661 :    // Don't update this stuff if realtime zooming. Will be done at intervals
; 3662 :    if (recalc_all && !do_rtzoom)

  00102	83 7d 08 00	 cmp	 DWORD PTR _recalc_all$[ebp], 0
  00106	74 34		 je	 SHORT $LN1@do_man_cal
  00108	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _do_rtzoom, 0
  0010f	75 2b		 jne	 SHORT $LN1@do_man_cal

; 3663 :    {
; 3664 :       SetWindowText(hwnd_info, get_image_info(1));       // update time, GFlops

  00111	6a 01		 push	 1
  00113	e8 00 00 00 00	 call	 _get_image_info
  00118	83 c4 04	 add	 esp, 4
  0011b	50		 push	 eax
  0011c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_info
  00121	50		 push	 eax
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 3665 :       print_status_line(0);

  00128	6a 00		 push	 0
  0012a	e8 00 00 00 00	 call	 _print_status_line
  0012f	83 c4 04	 add	 esp, 4

; 3666 :       SetCursor(cursor);                                 // restore old cursor

  00132	8b 45 fc	 mov	 eax, DWORD PTR _cursor$[ebp]
  00135	50		 push	 eax
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
$LN1@do_man_cal:

; 3667 :    }
; 3668 : }

  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
_do_man_calculate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1834 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1835 :         int _Result;
; 1836 :         va_list _ArgList;
; 1837 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1838 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  0001c	52		 push	 edx
  0001d	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 __vsprintf_s_l
  00026	83 c4 14	 add	 esp, 20			; 00000014H
  00029	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1839 :         __crt_va_end(_ArgList);

  0002c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1840 :         return _Result;

  00033	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1841 :     }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
tv73 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1493 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00025	52		 push	 edx
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s
  0002e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00031	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

  00034	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00038	7d 09		 jge	 SHORT $LN3@vsprintf_s
  0003a	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv73[ebp], -1
  00041	eb 06		 jmp	 SHORT $LN4@vsprintf_s
$LN3@vsprintf_s:
  00043	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00046	89 45 b8	 mov	 DWORD PTR tv73[ebp], eax
$LN4@vsprintf_s:
  00049	8b 45 b8	 mov	 eax, DWORD PTR tv73[ebp]

; 1499 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\quickman.c
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_m$ = -80						; size = 4
_wndclass$ = -76					; size = 48
_msg$ = -28						; size = 28
_hInst$ = 8						; size = 4
_hPrev$ = 12						; size = 4
_lpCmd$ = 16						; size = 4
_nShow$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 4811 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 4812 :    MSG msg;
; 4813 :    WNDCLASSEX wndclass;
; 4814 :    static char *classname = "ManWin";
; 4815 :    man_calc_struct *m;
; 4816 : 
; 4817 :    hinstance = hInst;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _hInst$[ebp]
  0000f	a3 00 00 00 00	 mov	 DWORD PTR _hinstance, eax

; 4818 : 
; 4819 :    m = &main_man_calc_struct;

  00014	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], OFFSET _main_man_calc_struct

; 4820 : 
; 4821 :    // Read any default settings from quickman.cfg. Do this early, because it can change almost
; 4822 :    // anything used below.
; 4823 :    read_cfg_file();

  0001b	e8 00 00 00 00	 call	 _read_cfg_file

; 4824 :    get_cpu_info();

  00020	e8 00 00 00 00	 call	 _get_cpu_info

; 4825 :    get_system_metrics();

  00025	e8 00 00 00 00	 call	 _get_system_metrics

; 4826 :    init_man();

  0002a	e8 00 00 00 00	 call	 _init_man

; 4827 :    if (!(num_builtin_palettes = init_palettes(DIVERGED_THRESH)))

  0002f	83 ec 08	 sub	 esp, 8
  00032	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4030000000000000
  0003a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0003f	e8 00 00 00 00	 call	 _init_palettes
  00044	83 c4 08	 add	 esp, 8
  00047	a3 00 00 00 00	 mov	 DWORD PTR _num_builtin_palettes, eax
  0004c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _num_builtin_palettes, 0
  00053	75 07		 jne	 SHORT $LN4@WinMain

; 4828 :       return 0;

  00055	33 c0		 xor	 eax, eax
  00057	e9 22 02 00 00	 jmp	 $LN1@WinMain
$LN4@WinMain:

; 4829 : 
; 4830 :    memset(&wndclass, 0, sizeof(WNDCLASSEX)); // create a window class for our main window

  0005c	6a 30		 push	 48			; 00000030H
  0005e	6a 00		 push	 0
  00060	8d 45 b4	 lea	 eax, DWORD PTR _wndclass$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memset
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4831 :    wndclass.lpszClassName = classname;

  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?classname@?1??WinMain@@9@9
  00071	89 45 dc	 mov	 DWORD PTR _wndclass$[ebp+40], eax

; 4832 :    wndclass.cbSize = sizeof(WNDCLASSEX);

  00074	c7 45 b4 30 00
	00 00		 mov	 DWORD PTR _wndclass$[ebp], 48 ; 00000030H

; 4833 :    wndclass.style = CS_HREDRAW | CS_VREDRAW;

  0007b	c7 45 b8 03 00
	00 00		 mov	 DWORD PTR _wndclass$[ebp+4], 3

; 4834 :    wndclass.lpfnWndProc = MainWndProc;

  00082	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _wndclass$[ebp+8], OFFSET _MainWndProc@16

; 4835 :    wndclass.hInstance = hInst;

  00089	8b 45 08	 mov	 eax, DWORD PTR _hInst$[ebp]
  0008c	89 45 c8	 mov	 DWORD PTR _wndclass$[ebp+20], eax

; 4836 :    wndclass.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_MAN));       // use mini mandelbrot icon

  0008f	6a 6b		 push	 107			; 0000006bH
  00091	8b 45 08	 mov	 eax, DWORD PTR _hInst$[ebp]
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8
  0009b	89 45 cc	 mov	 DWORD PTR _wndclass$[ebp+24], eax

; 4837 :    wndclass.hIconSm = NULL;                                          // derive small icon from normal one

  0009e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _wndclass$[ebp+44], 0

; 4838 :    wndclass.hCursor = arrow_cursor = LoadCursor(NULL, IDC_ARROW);    // we set other cursors based on nav mode

  000a5	68 00 7f 00 00	 push	 32512			; 00007f00H
  000aa	6a 00		 push	 0
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  000b2	a3 00 00 00 00	 mov	 DWORD PTR _arrow_cursor, eax
  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _arrow_cursor
  000bc	89 45 d0	 mov	 DWORD PTR _wndclass$[ebp+28], eax

; 4839 :    wndclass.hbrBackground = NULL;                                    // don't need this

  000bf	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _wndclass$[ebp+32], 0

; 4840 :    RegisterClassEx(&wndclass);

  000c6	8d 45 b4	 lea	 eax, DWORD PTR _wndclass$[ebp]
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassExA@4

; 4841 : 
; 4842 :    // Load cursors - wait, zoom, hand open, and hand closed
; 4843 :    wait_cursor = LoadCursor(NULL, IDC_WAIT);

  000d0	68 02 7f 00 00	 push	 32514			; 00007f02H
  000d5	6a 00		 push	 0
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  000dd	a3 00 00 00 00	 mov	 DWORD PTR _wait_cursor, eax

; 4844 :    mag_cursor = LoadCursor(hInst, MAKEINTRESOURCE(IDC_MAG));

  000e2	6a 6a		 push	 106			; 0000006aH
  000e4	8b 45 08	 mov	 eax, DWORD PTR _hInst$[ebp]
  000e7	50		 push	 eax
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  000ee	a3 00 00 00 00	 mov	 DWORD PTR _mag_cursor, eax

; 4845 :    rtzoom_cursor = mag_zoom_cursor = LoadCursor(hInst, MAKEINTRESOURCE(IDC_RTZOOM));

  000f3	6a 6f		 push	 111			; 0000006fH
  000f5	8b 45 08	 mov	 eax, DWORD PTR _hInst$[ebp]
  000f8	50		 push	 eax
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  000ff	a3 00 00 00 00	 mov	 DWORD PTR _mag_zoom_cursor, eax
  00104	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _mag_zoom_cursor
  0010a	89 0d 00 00 00
	00		 mov	 DWORD PTR _rtzoom_cursor, ecx

; 4846 :    hopen_cursor = LoadCursor(hInst, MAKEINTRESOURCE(IDC_HAND_OPEN));

  00110	6a 6e		 push	 110			; 0000006eH
  00112	8b 45 08	 mov	 eax, DWORD PTR _hInst$[ebp]
  00115	50		 push	 eax
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  0011c	a3 00 00 00 00	 mov	 DWORD PTR _hopen_cursor, eax

; 4847 :    hclosed_cursor = LoadCursor(hInst, MAKEINTRESOURCE(IDC_HAND_CLOSED));

  00121	6a 6d		 push	 109			; 0000006dH
  00123	8b 45 08	 mov	 eax, DWORD PTR _hInst$[ebp]
  00126	50		 push	 eax
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  0012d	a3 00 00 00 00	 mov	 DWORD PTR _hclosed_cursor, eax

; 4848 : 
; 4849 :    hwnd_main = CreateWindow(  // Create our main window

  00132	6a 00		 push	 0
  00134	8b 45 08	 mov	 eax, DWORD PTR _hInst$[ebp]
  00137	50		 push	 eax
  00138	6a 00		 push	 0
  0013a	6a 00		 push	 0
  0013c	8b 4d b0	 mov	 ecx, DWORD PTR _m$[ebp]
  0013f	8b 91 8c 8d 00
	00		 mov	 edx, DWORD PTR [ecx+36236]
  00145	03 15 00 00 00
	00		 add	 edx, DWORD PTR _y_border
  0014b	52		 push	 edx
  0014c	8b 45 b0	 mov	 eax, DWORD PTR _m$[ebp]
  0014f	8b 88 88 8d 00
	00		 mov	 ecx, DWORD PTR [eax+36232]
  00155	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _x_border
  0015b	51		 push	 ecx
  0015c	6a 14		 push	 20			; 00000014H
  0015e	68 8c 00 00 00	 push	 140			; 0000008cH
  00163	68 00 00 cf 00	 push	 13565952		; 00cf0000H
  00168	68 00 00 00 00	 push	 OFFSET $SG42313
  0016d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?classname@?1??WinMain@@9@9
  00173	52		 push	 edx
  00174	6a 00		 push	 0
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  0017c	a3 00 00 00 00	 mov	 DWORD PTR _hwnd_main, eax

; 4850 :       classname,
; 4851 :       "QuickMAN 1.10  |  F1: Help",
; 4852 :       WS_OVERLAPPEDWINDOW,    // Style
; 4853 :       140, // CW_USEDEFAULT,  // Initial x; come up at a good location on my laptop...
; 4854 :       20,  // CW_USEDEFAULT,  // Initial y
; 4855 :       m->xsize + x_border,    // Size
; 4856 :       m->ysize + y_border,
; 4857 :       NULL,                   // No parent window
; 4858 :       NULL,                   // No menu
; 4859 :       hInst,                  // This program instance
; 4860 :       NULL                    // Creation parameters
; 4861 :       );
; 4862 : 
; 4863 :    // Init common controls; required for < WinXP, and apparently for some Pentium 4 systems
; 4864 :    InitCommonControls();

  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitCommonControls@0

; 4865 : 
; 4866 :    #ifndef USE_PERFORMANCE_COUNTER
; 4867 :    // Set timer resolution to 1ms (if supported). Seems to take awhile to take effect.
; 4868 :    // timegettime() will return inaccurate results if it's called too soon after this...
; 4869 :    timeBeginPeriod(1); // fancy_intro will absorb initialization time

  00187	6a 01		 push	 1
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeBeginPeriod@4

; 4870 :    #endif
; 4871 : 
; 4872 :    UpdateWindow(hwnd_main);

  0018f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_main
  00194	50		 push	 eax
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UpdateWindow@4

; 4873 :    update_dialog(1, 1);          // 1 = hide, 1 = move

  0019b	6a 01		 push	 1
  0019d	6a 01		 push	 1
  0019f	e8 00 00 00 00	 call	 _update_dialog
  001a4	83 c4 08	 add	 esp, 8

; 4874 :    ShowWindow(hwnd_main, nShow); // causes dialog to become visible

  001a7	8b 45 14	 mov	 eax, DWORD PTR _nShow$[ebp]
  001aa	50		 push	 eax
  001ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_main
  001b1	51		 push	 ecx
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 4875 :    UpdateWindow(hwnd_dialog);

  001b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _hwnd_dialog
  001bd	50		 push	 eax
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UpdateWindow@4

; 4876 : 
; 4877 :    add_user_palettes_and_logfiles();            // Add user palettes and logfiles to their dropdown menus

  001c4	e8 00 00 00 00	 call	 _add_user_palettes_and_logfiles

; 4878 :    log_read(logfile, "\nDid you extract all the files from the QuickMAN .zip archive?", 1);                        // Read logfile- add_user_palettes() must be called before this

  001c9	6a 01		 push	 1
  001cb	68 00 00 00 00	 push	 OFFSET $SG42314
  001d0	68 00 00 00 00	 push	 OFFSET _logfile
  001d5	e8 00 00 00 00	 call	 _log_read
  001da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4879 :    fancy_intro();                               // Zoom in to home image

  001dd	e8 00 00 00 00	 call	 _fancy_intro
$LN2@WinMain:

; 4880 : 
; 4881 :    while(1)                                     // Main loop

  001e2	b8 01 00 00 00	 mov	 eax, 1
  001e7	85 c0		 test	 eax, eax
  001e9	74 6e		 je	 SHORT $LN3@WinMain

; 4882 :    {
; 4883 :       if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))

  001eb	6a 01		 push	 1
  001ed	6a 00		 push	 0
  001ef	6a 00		 push	 0
  001f1	6a 00		 push	 0
  001f3	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  001f6	50		 push	 eax
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  001fd	85 c0		 test	 eax, eax
  001ff	74 33		 je	 SHORT $LN5@WinMain

; 4884 :       {
; 4885 :          if (msg.message == WM_QUIT)

  00201	83 7d e8 12	 cmp	 DWORD PTR _msg$[ebp+4], 18 ; 00000012H
  00205	75 02		 jne	 SHORT $LN7@WinMain

; 4886 :             break;

  00207	eb 50		 jmp	 SHORT $LN3@WinMain
$LN7@WinMain:

; 4887 :          if (!IsDialogMessage(hwnd_dialog, &msg)) // only process messages not for dialog box

  00209	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  0020c	50		 push	 eax
  0020d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hwnd_dialog
  00213	51		 push	 ecx
  00214	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDialogMessageA@8
  0021a	85 c0		 test	 eax, eax
  0021c	75 14		 jne	 SHORT $LN8@WinMain

; 4888 :          {
; 4889 :             TranslateMessage(&msg);

  0021e	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  00221	50		 push	 eax
  00222	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TranslateMessage@4

; 4890 :             DispatchMessage(&msg);

  00228	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  0022b	50		 push	 eax
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DispatchMessageA@4
$LN8@WinMain:

; 4891 :          }
; 4892 :       }

  00232	eb 23		 jmp	 SHORT $LN9@WinMain
$LN5@WinMain:

; 4893 :       else
; 4894 :       {
; 4895 :          // Do heavy computation here
; 4896 :          if (!do_zooming() && !do_panning() && !do_recalc())

  00234	e8 00 00 00 00	 call	 _do_zooming
  00239	85 c0		 test	 eax, eax
  0023b	75 1a		 jne	 SHORT $LN9@WinMain
  0023d	e8 00 00 00 00	 call	 _do_panning
  00242	85 c0		 test	 eax, eax
  00244	75 11		 jne	 SHORT $LN9@WinMain
  00246	e8 00 00 00 00	 call	 _do_recalc
  0024b	85 c0		 test	 eax, eax
  0024d	75 08		 jne	 SHORT $LN9@WinMain

; 4897 :             Sleep(2); // don't use 100% of CPU when idle. Also see do_panning()

  0024f	6a 02		 push	 2
  00251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN9@WinMain:

; 4898 :       }
; 4899 :    }

  00257	eb 89		 jmp	 SHORT $LN2@WinMain
$LN3@WinMain:

; 4900 : 
; 4901 :    #ifndef USE_PERFORMANCE_COUNTER
; 4902 :    timeEndPeriod(1);

  00259	6a 01		 push	 1
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeEndPeriod@4

; 4903 :    #endif
; 4904 : 
; 4905 :    free_man_mem(&main_man_calc_struct);

  00261	68 00 00 00 00	 push	 OFFSET _main_man_calc_struct
  00266	e8 00 00 00 00	 call	 _free_man_mem
  0026b	83 c4 04	 add	 esp, 4

; 4906 :    free_man_mem(&save_man_calc_struct);

  0026e	68 00 00 00 00	 push	 OFFSET _save_man_calc_struct
  00273	e8 00 00 00 00	 call	 _free_man_mem
  00278	83 c4 04	 add	 esp, 4

; 4907 : 
; 4908 :    return (int) msg.wParam;

  0027b	8b 45 ec	 mov	 eax, DWORD PTR _msg$[ebp+8]
$LN1@WinMain:

; 4909 : }

  0027e	5f		 pop	 edi
  0027f	5e		 pop	 esi
  00280	5b		 pop	 ebx
  00281	8b e5		 mov	 esp, ebp
  00283	5d		 pop	 ebp
  00284	c2 10 00	 ret	 16			; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
END
