; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	D:\Stanley\Desktop\quickman_v110\source\imagesave.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG32186 DB	'The PNG library returned an error. Possible causes:', 0aH
	DB	0aH, '1. The image you are trying to save may be too large.', 0aH
	DB	'2. The filename for the image is invalid.', 00H
	ORG $+3
$SG32204 DB	'1.2.33', 00H
	ORG $+1
$SG32207 DB	'wb', 00H
_DATA	ENDS
PUBLIC	_png_error
PUBLIC	_png_save_start
PUBLIC	_png_save_write_row
PUBLIC	_png_save_end
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_fopen_s:PROC
EXTRN	_fclose:PROC
EXTRN	_png_create_write_struct:PROC
EXTRN	_png_create_info_struct:PROC
EXTRN	_png_destroy_write_struct:PROC
EXTRN	_png_init_io:PROC
EXTRN	_png_set_compression_level:PROC
EXTRN	_png_set_IHDR:PROC
EXTRN	_png_write_info:PROC
EXTRN	_png_write_row:PROC
EXTRN	_png_write_end:PROC
EXTRN	_png_set_bgr:PROC
EXTRN	__setjmp3:PROC
_BSS	SEGMENT
_png	DD	01H DUP (?)
_pnginfo DD	01H DUP (?)
_png_fp	DD	01H DUP (?)
_BSS	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\imagesave.c
;	COMDAT _png_save_end
_TEXT	SEGMENT
_png_save_end PROC					; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 129  :    if (setjmp(png_jmpbuf(png)))

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _png
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 __setjmp3
  00016	83 c4 08	 add	 esp, 8
  00019	85 c0		 test	 eax, eax
  0001b	74 27		 je	 SHORT $LN2@png_save_e

; 130  :    {
; 131  :       // any pnglib errors jump here
; 132  :       png_destroy_write_struct(&png, &pnginfo);

  0001d	68 00 00 00 00	 push	 OFFSET _pnginfo
  00022	68 00 00 00 00	 push	 OFFSET _png
  00027	e8 00 00 00 00	 call	 _png_destroy_write_struct
  0002c	83 c4 08	 add	 esp, 8

; 133  :       fclose(png_fp);

  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR _png_fp
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _fclose
  0003a	83 c4 04	 add	 esp, 4

; 134  :       return png_error();

  0003d	e8 00 00 00 00	 call	 _png_error
  00042	eb 35		 jmp	 SHORT $LN1@png_save_e
$LN2@png_save_e:

; 135  :    }
; 136  : 
; 137  :    png_write_end(png, NULL);

  00044	6a 00		 push	 0
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _png
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _png_write_end
  00051	83 c4 08	 add	 esp, 8

; 138  :    png_destroy_write_struct(&png, &pnginfo);

  00054	68 00 00 00 00	 push	 OFFSET _pnginfo
  00059	68 00 00 00 00	 push	 OFFSET _png
  0005e	e8 00 00 00 00	 call	 _png_destroy_write_struct
  00063	83 c4 08	 add	 esp, 8

; 139  :    fclose(png_fp);

  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR _png_fp
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _fclose
  00071	83 c4 04	 add	 esp, 4

; 140  :    return 1;

  00074	b8 01 00 00 00	 mov	 eax, 1
$LN1@png_save_e:

; 141  : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_png_save_end ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\imagesave.c
;	COMDAT _png_save_write_row
_TEXT	SEGMENT
_row$ = 8						; size = 4
_png_save_write_row PROC				; COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 115  :    if (setjmp(png_jmpbuf(png)))

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _png
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 __setjmp3
  00016	83 c4 08	 add	 esp, 8
  00019	85 c0		 test	 eax, eax
  0001b	74 27		 je	 SHORT $LN2@png_save_w

; 116  :    {
; 117  :       // any pnglib errors jump here
; 118  :       png_destroy_write_struct(&png, &pnginfo);

  0001d	68 00 00 00 00	 push	 OFFSET _pnginfo
  00022	68 00 00 00 00	 push	 OFFSET _png
  00027	e8 00 00 00 00	 call	 _png_destroy_write_struct
  0002c	83 c4 08	 add	 esp, 8

; 119  :       fclose(png_fp);

  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR _png_fp
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _fclose
  0003a	83 c4 04	 add	 esp, 4

; 120  :       return png_error();

  0003d	e8 00 00 00 00	 call	 _png_error
  00042	eb 18		 jmp	 SHORT $LN1@png_save_w
$LN2@png_save_w:

; 121  :    }
; 122  :    png_write_row(png, row);

  00044	8b 45 08	 mov	 eax, DWORD PTR _row$[ebp]
  00047	50		 push	 eax
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _png
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _png_write_row
  00054	83 c4 08	 add	 esp, 8

; 123  :    return 1;

  00057	b8 01 00 00 00	 mov	 eax, 1
$LN1@png_save_w:

; 124  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_png_save_write_row ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\imagesave.c
;	COMDAT _png_save_start
_TEXT	SEGMENT
_file$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_png_save_start PROC					; COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 80   :    if ((png = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL)) == NULL)

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	68 00 00 00 00	 push	 OFFSET $SG32204
  00014	e8 00 00 00 00	 call	 _png_create_write_struct
  00019	83 c4 10	 add	 esp, 16			; 00000010H
  0001c	a3 00 00 00 00	 mov	 DWORD PTR _png, eax
  00021	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _png, 0
  00028	75 0a		 jne	 SHORT $LN2@png_save_s

; 81   :       return png_error();

  0002a	e8 00 00 00 00	 call	 _png_error
  0002f	e9 fe 00 00 00	 jmp	 $LN1@png_save_s
$LN2@png_save_s:

; 82   : 
; 83   :    if ((pnginfo = png_create_info_struct(png)) == NULL || fopen_s(&png_fp, file, "wb"))

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR _png
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _png_create_info_struct
  0003f	83 c4 04	 add	 esp, 4
  00042	a3 00 00 00 00	 mov	 DWORD PTR _pnginfo, eax
  00047	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pnginfo, 0
  0004e	74 1a		 je	 SHORT $LN4@png_save_s
  00050	68 00 00 00 00	 push	 OFFSET $SG32207
  00055	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00058	50		 push	 eax
  00059	68 00 00 00 00	 push	 OFFSET _png_fp
  0005e	e8 00 00 00 00	 call	 _fopen_s
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	85 c0		 test	 eax, eax
  00068	74 19		 je	 SHORT $LN3@png_save_s
$LN4@png_save_s:

; 84   :    {
; 85   :       png_destroy_write_struct(&png, NULL);

  0006a	6a 00		 push	 0
  0006c	68 00 00 00 00	 push	 OFFSET _png
  00071	e8 00 00 00 00	 call	 _png_destroy_write_struct
  00076	83 c4 08	 add	 esp, 8

; 86   :       return png_error();

  00079	e8 00 00 00 00	 call	 _png_error
  0007e	e9 af 00 00 00	 jmp	 $LN1@png_save_s
$LN3@png_save_s:

; 87   :    }
; 88   : 
; 89   :    if (setjmp(png_jmpbuf(png)))

  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR _png
  00088	6a 00		 push	 0
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 __setjmp3
  00090	83 c4 08	 add	 esp, 8
  00093	85 c0		 test	 eax, eax
  00095	74 27		 je	 SHORT $LN5@png_save_s

; 90   :    {
; 91   :       // Any pnglib errors jump here
; 92   :       png_destroy_write_struct(&png, &pnginfo);

  00097	68 00 00 00 00	 push	 OFFSET _pnginfo
  0009c	68 00 00 00 00	 push	 OFFSET _png
  000a1	e8 00 00 00 00	 call	 _png_destroy_write_struct
  000a6	83 c4 08	 add	 esp, 8

; 93   :       fclose(png_fp);

  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _png_fp
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _fclose
  000b4	83 c4 04	 add	 esp, 4

; 94   :       return png_error();

  000b7	e8 00 00 00 00	 call	 _png_error
  000bc	eb 74		 jmp	 SHORT $LN1@png_save_s
$LN5@png_save_s:

; 95   :    }
; 96   : 
; 97   :    png_init_io(png, png_fp);

  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR _png_fp
  000c3	50		 push	 eax
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _png
  000ca	51		 push	 ecx
  000cb	e8 00 00 00 00	 call	 _png_init_io
  000d0	83 c4 08	 add	 esp, 8

; 98   :    png_set_bgr(png);  // Set B,G,R color order: necessary for correct palette mapping

  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _png
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _png_set_bgr
  000de	83 c4 04	 add	 esp, 4

; 99   : 
; 100  :    // Set Zlib compression levels; 0 = none; 9 = best. 3-6 are supposed to be almost as
; 101  :    // good as 9 for images. Test: 6- 43s 17519kb; 9- 45s 18573kb; 9 sometimes gives worse compression
; 102  :    png_set_compression_level(png, 6);

  000e1	6a 06		 push	 6
  000e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _png
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _png_set_compression_level
  000ee	83 c4 08	 add	 esp, 8

; 103  : 
; 104  :    png_set_IHDR(png, pnginfo, width, height, 8, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE,

  000f1	6a 00		 push	 0
  000f3	6a 00		 push	 0
  000f5	6a 00		 push	 0
  000f7	6a 02		 push	 2
  000f9	6a 08		 push	 8
  000fb	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  00102	51		 push	 ecx
  00103	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pnginfo
  00109	52		 push	 edx
  0010a	a1 00 00 00 00	 mov	 eax, DWORD PTR _png
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 _png_set_IHDR
  00115	83 c4 24	 add	 esp, 36			; 00000024H

; 105  :                 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
; 106  : 
; 107  :    png_write_info(png, pnginfo);

  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR _pnginfo
  0011d	50		 push	 eax
  0011e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _png
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 _png_write_info
  0012a	83 c4 08	 add	 esp, 8

; 108  :    return 1;

  0012d	b8 01 00 00 00	 mov	 eax, 1
$LN1@png_save_s:

; 109  : }

  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	5b		 pop	 ebx
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
_png_save_start ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File d:\stanley\desktop\quickman_v110\source\imagesave.c
;	COMDAT _png_error
_TEXT	SEGMENT
_png_error PROC						; COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 69   :    MessageBox(NULL, "The PNG library returned an error. Possible causes:\n\n"

  00009	68 10 20 00 00	 push	 8208			; 00002010H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET $SG32186
  00015	6a 00		 push	 0
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 70   :                     "1. The image you are trying to save may be too large.\n"
; 71   :                     "2. The filename for the image is invalid.",
; 72   :                     NULL, MB_OK | MB_ICONSTOP | MB_TASKMODAL);
; 73   :    return 0;

  0001d	33 c0		 xor	 eax, eax

; 74   : }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_png_error ENDP
_TEXT	ENDS
END
